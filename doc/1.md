## actor_client与actor_server
* 每个进程都需要有一个actor_client或actor_server<br/>
通常一个区服只有一个进程中包含actor_server<br/>
其他所有进程都必须包含actor_client<br/>
actor_client 用来纪录保存<b>actor_guid与服务器id的对应关系</b><br/>
actor_client相当于actor框架的<b>路由器</b>，为actor提供路由功能<br/>
而actor_server负责分发各个actor_client中本地的actor_guid对应关系

## naddress
* actor_client actor_server 用naddress来管理actor地址<br/>
管理的对应关系如下<br/>
1、[actor_guid:actor_id]  -> [i32_serverid:server_id]<br/>
2、[i16_actortype:actor_type]  -> [set<actor_guid:actor_id>]<br/>
3、[i32_serverid:server_id] -> [i32_sessionid:session_id]<br/>
4、[actor_guid:actor_id] -> [i32_serverid:gateway_server_id]<br/>

## nguid
* 64bit整形
16位:类型ENUM_ACTOR<br/>
16位:区服id<br/>
32位:数据id<br/>
// ############ 64 bit ######### //<br/>
// #actor_type###areaid###id#### //<br/>
// #16bit########16bit####32bit# //<br/>

## handle_pram
* actor对象间传递消息的媒介，<br/>
通过其对类型的隐藏（类型复显主要依赖nrfun）由actor_manage交给其所管理的actor（当然如果actor不在本进程则交给actor_client由其路由给actor）


## nrfun
* 用于注册actor需要处理的消息，利用泛型与匿名函数将协议号与消息类型进行关联

## actor_base
* 所有actor对象的基类<br/>
1. 对db的支持<br/>
2. 对网络的支持<br/>
3. 对定时任务的支持<br/>
在actor_manage中管理所有actor对象的actor_base指针


## actor
* 继承自actor_base，主要是对actor_base补充支持<br/>
1. 注册actor对象需要处理哪些消息<br/>
2. 对actor对象广播的支持<br/>
3. 对线程调用的支持<br/>

## actor_create
* actor切换进程(暂时actor内部临时数据无法迁移)

## ntimer
* 借助时间轮time_wheel为actor_base提供定时能力

## actor_manage
* 管理所在进程的actor_base指针与nthread指针，<br/>
提供代码任意位置给进程中的任意actor传递消息，<br/>
再配合actor_client的路由功能即可完成跨进程消息传递

## nactor_type
* nactor_type<actor对象类型>即可获取actor对象的ENUM_ACTOR类型

## actor_cross
* 跨服actor对象,<br/>
可以支持多个区服访问,<br/>
在tab_servers.csv中设置哪些区服进程可以访问

## actor_role
* 玩家在服务器上的实例，一般进行逻辑访问首先发送给actor_role，<br/>
1. 比如获取服务器时间(通过protobuf协议消息pbnet::PROBUFF_NET_GET_TIME),<br/>
actor_role实现了对pbnet::PROBUFF_NET_GET_TIME的处理<br/>
```
bool actor_role::handle(message<pbnet::PROBUFF_NET_GET_TIME>& adata);
```
2. 如果客户端想访问邮件系统actor_mail,<br/>
那么可以借助
```
template <ENUM_ACTOR ACTOR, typename T>
bool actor_role::handle_forward(message<T>& adata)
```
当然其也能转发给跨服的actor对象<br/>
3. 通过对消息pbnet::PROBUFF_NET_CMD的实现来支持客户端命令
```
bool actor_role::handle(message<pbnet::PROBUFF_NET_CMD>& adata)
```

## actor_manage_role
* 主要通过实现
```
bool handle(message<pbnet::PROBUFF_NET_ROLE_LOGIN>& adata);
```
加载玩家在服务器上的对象

## actor_gateway
* 主要是对actor_gatewayc2g与actor_gatewayg2c提供支持<br/>
主要是分离client to game与game to client<br/>
内部通过gateway_info<br/>
让区服、数据id关联网关的socket和连接的基本信息<br/>
也让网关的socket关联连接的基本信息<br/>
```
// key area  value key roleid
std::map<i16_area, std::map<i32_actordataid, gateway_socket>> m_info;
// key socket
std::map<i32_socket, gateway_socket*> m_sockinfo;
```

## actor_gatewayc2g
* 客户端主连的网关进程,<br/>
将客户端的消息传递给game服务器

## actor_gatewayg2c
* 客户端主连的网关进程,<br/>
将game服务器的消息传递给客户端

## actor_kcp
* 主要是通过其创建kcp连接对象

## actor_log
* 主要通过nlog实现对日志的落地,<br/>
可以部署在任意进程任意机器，<br/>
也可以通过对nlog的变形记录不同类型不同格式的日志例如经分日志(BI日志)

## actor_login
* 主要是对消息pbnet::PROBUFF_NET_ACOUNT_LOGIN的处理来实现玩家的登录<br/>
并且根据网关进程与game进程的实时负载情况确定玩家连接的服务器

## actor_reloadcsv_distribute
* 对csv表格数据进行线上同步分发,主要是动态更新表数据

## actor_reloadcsv
* 对比表数据版本进行数据更新

## actor_robot
* 用来模拟客户端的机器人actor对象

## actor_manage_robot
* 主要是管理actor_robot对象和接收处理命令行窗口的输入

## data_modified
* 主要服务于db数据，使用其简单包装数据,即可在其获取中确认数据是否被修改<br/>
其提供两个函数<br/>
1. 函数[TDBTAB& get(bool achange = true)] 此函数主要是会被修改，如果强行传入false，<br/>
也不限制获取可修改TDBTAB的引用，但是需要明确的是一定不要修改此引用，否则数据可能不会被保存<br/>
2. 函数[const TDBTAB& getconst()const] 此函数只能获取const TDBTAB引用，其预示不可被修改也不会触发自动保存

## ndb_modular
* 对actor对象提供db数据支持
* 函数[std::map<nguid, data_modified<TDATA>>& data()]获取全部数据
* 函数[data_modified<TDATA>* get()]在其派生类实现的虚函数[virtual void set_id();]不为-1即可获取数据，<br/>
因为-1为加载全部数据此时此函数无效调用
* 函数[void foreach(const std::function<void(data_modified<TDATA>&)>& afun)] 可遍历所有数据
* 函数[data_modified<TDATA>* get(nguid aid)] 获取指定id对应的数据，没有即创建，<br/>
因为会创建所以此函数还会检查“虚函数[virtual void set_id();]是否为-1”，<br/>
只有-1或者指定的id == 虚函数[virtual void set_id();]才可以创建
* 函数[data_modified<TDATA>* find(nguid aid)] 查找指定id获取对应数据
* 函数[void erase(nguid aid)]删除指定id对应的数据
* 函数[data_modified<TDATA>* add(i64_actorid aid, const TDATA& adbtab)] 添加数据
* 函数[void remove(int64_t aid)]移除数据
