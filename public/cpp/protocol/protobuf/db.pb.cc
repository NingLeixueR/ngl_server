// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: db.proto

#include "db.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace pbdb {
PROTOBUF_CONSTEXPR db_account::db_account(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_account_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.m_passworld_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.m_id_)*/int64_t{0}
  , /*decltype(_impl_.m_roleid_)*/int64_t{0}
  , /*decltype(_impl_.m_area_)*/0} {}
struct db_accountDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_accountDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_accountDefaultTypeInternal() {}
  union {
    db_account _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_accountDefaultTypeInternal _db_account_default_instance_;
PROTOBUF_CONSTEXPR db_brief::db_brief(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.m_id_)*/int64_t{0}
  , /*decltype(_impl_.m_lv_)*/0
  , /*decltype(_impl_.m_moneygold_)*/0
  , /*decltype(_impl_.m_moneysilver_)*/0
  , /*decltype(_impl_.m_vip_)*/0
  , /*decltype(_impl_.m_notalkutc_)*/0
  , /*decltype(_impl_.m_createutc_)*/0} {}
struct db_briefDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_briefDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_briefDefaultTypeInternal() {}
  union {
    db_brief _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_briefDefaultTypeInternal _db_brief_default_instance_;
PROTOBUF_CONSTEXPR db_role_recharge::db_role_recharge(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_rechargeid_)*/0
  , /*decltype(_impl_.m_utc_)*/0} {}
struct db_role_rechargeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_role_rechargeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_role_rechargeDefaultTypeInternal() {}
  union {
    db_role_recharge _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_role_rechargeDefaultTypeInternal _db_role_recharge_default_instance_;
PROTOBUF_CONSTEXPR db_role::db_role(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_recharge_)*/{}
  , /*decltype(_impl_.m_base_)*/nullptr
  , /*decltype(_impl_.m_id_)*/int64_t{0}} {}
struct db_roleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_roleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_roleDefaultTypeInternal() {}
  union {
    db_role _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_roleDefaultTypeInternal _db_role_default_instance_;
PROTOBUF_CONSTEXPR item::item(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_id_)*/0
  , /*decltype(_impl_.m_tid_)*/0
  , /*decltype(_impl_.m_count_)*/0
  , /*decltype(_impl_.m_lv_)*/0
  , /*decltype(_impl_.m_star_)*/0} {}
struct itemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR itemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~itemDefaultTypeInternal() {}
  union {
    item _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 itemDefaultTypeInternal _item_default_instance_;
PROTOBUF_CONSTEXPR db_bag_MItemsEntry_DoNotUse::db_bag_MItemsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct db_bag_MItemsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_bag_MItemsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_bag_MItemsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    db_bag_MItemsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_bag_MItemsEntry_DoNotUseDefaultTypeInternal _db_bag_MItemsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR db_bag::db_bag(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_items_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.m_id_)*/int64_t{0}
  , /*decltype(_impl_.m_maxid_)*/0} {}
struct db_bagDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_bagDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_bagDefaultTypeInternal() {}
  union {
    db_bag _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_bagDefaultTypeInternal _db_bag_default_instance_;
PROTOBUF_CONSTEXPR db_keyvalue::db_keyvalue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.m_id_)*/int64_t{0}} {}
struct db_keyvalueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_keyvalueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_keyvalueDefaultTypeInternal() {}
  union {
    db_keyvalue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_keyvalueDefaultTypeInternal _db_keyvalue_default_instance_;
PROTOBUF_CONSTEXPR db_rolekeyvalue_MDataEntry_DoNotUse::db_rolekeyvalue_MDataEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct db_rolekeyvalue_MDataEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_rolekeyvalue_MDataEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_rolekeyvalue_MDataEntry_DoNotUseDefaultTypeInternal() {}
  union {
    db_rolekeyvalue_MDataEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_rolekeyvalue_MDataEntry_DoNotUseDefaultTypeInternal _db_rolekeyvalue_MDataEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR db_rolekeyvalue::db_rolekeyvalue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_data_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.m_id_)*/int64_t{0}} {}
struct db_rolekeyvalueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_rolekeyvalueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_rolekeyvalueDefaultTypeInternal() {}
  union {
    db_rolekeyvalue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_rolekeyvalueDefaultTypeInternal _db_rolekeyvalue_default_instance_;
PROTOBUF_CONSTEXPR mailitem::mailitem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_itemtid_)*/0
  , /*decltype(_impl_.m_count_)*/0} {}
struct mailitemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR mailitemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~mailitemDefaultTypeInternal() {}
  union {
    mailitem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 mailitemDefaultTypeInternal _mailitem_default_instance_;
PROTOBUF_CONSTEXPR mail::mail(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_items_)*/{}
  , /*decltype(_impl_.m_prams_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.m_content_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.m_id_)*/0
  , /*decltype(_impl_.m_createutc_)*/0
  , /*decltype(_impl_.m_tid_)*/0
  , /*decltype(_impl_.m_read_)*/false
  , /*decltype(_impl_.m_draw_)*/false} {}
struct mailDefaultTypeInternal {
  PROTOBUF_CONSTEXPR mailDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~mailDefaultTypeInternal() {}
  union {
    mail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 mailDefaultTypeInternal _mail_default_instance_;
PROTOBUF_CONSTEXPR db_mail_MMailEntry_DoNotUse::db_mail_MMailEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct db_mail_MMailEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_mail_MMailEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_mail_MMailEntry_DoNotUseDefaultTypeInternal() {}
  union {
    db_mail_MMailEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_mail_MMailEntry_DoNotUseDefaultTypeInternal _db_mail_MMailEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR db_mail::db_mail(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_mail_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.m_id_)*/int64_t{0}} {}
struct db_mailDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_mailDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_mailDefaultTypeInternal() {}
  union {
    db_mail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_mailDefaultTypeInternal _db_mail_default_instance_;
PROTOBUF_CONSTEXPR db_guild::db_guild(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_members_)*/{}
  , /*decltype(_impl_._m_members_cached_byte_size_)*/{0}
  , /*decltype(_impl_.m_guild_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.m_id_)*/int64_t{0}
  , /*decltype(_impl_.m_leader_)*/int64_t{0}} {}
struct db_guildDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_guildDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_guildDefaultTypeInternal() {}
  union {
    db_guild _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_guildDefaultTypeInternal _db_guild_default_instance_;
PROTOBUF_CONSTEXPR db_notice::db_notice(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_notice_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.m_id_)*/int64_t{0}
  , /*decltype(_impl_.m_starttime_)*/0
  , /*decltype(_impl_.m_finishtime_)*/0} {}
struct db_noticeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_noticeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_noticeDefaultTypeInternal() {}
  union {
    db_notice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_noticeDefaultTypeInternal _db_notice_default_instance_;
PROTOBUF_CONSTEXPR rankitem::rankitem(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_value_)*/int64_t{0}
  , /*decltype(_impl_.m_time_)*/0} {}
struct rankitemDefaultTypeInternal {
  PROTOBUF_CONSTEXPR rankitemDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~rankitemDefaultTypeInternal() {}
  union {
    rankitem _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 rankitemDefaultTypeInternal _rankitem_default_instance_;
PROTOBUF_CONSTEXPR db_ranklist_MItemsEntry_DoNotUse::db_ranklist_MItemsEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct db_ranklist_MItemsEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_ranklist_MItemsEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_ranklist_MItemsEntry_DoNotUseDefaultTypeInternal() {}
  union {
    db_ranklist_MItemsEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_ranklist_MItemsEntry_DoNotUseDefaultTypeInternal _db_ranklist_MItemsEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR db_ranklist::db_ranklist(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_items_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.m_id_)*/int64_t{0}} {}
struct db_ranklistDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_ranklistDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_ranklistDefaultTypeInternal() {}
  union {
    db_ranklist _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_ranklistDefaultTypeInternal _db_ranklist_default_instance_;
PROTOBUF_CONSTEXPR db_activity_drawcompliance_MRewardEntry_DoNotUse::db_activity_drawcompliance_MRewardEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct db_activity_drawcompliance_MRewardEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_activity_drawcompliance_MRewardEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_activity_drawcompliance_MRewardEntry_DoNotUseDefaultTypeInternal() {}
  union {
    db_activity_drawcompliance_MRewardEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_activity_drawcompliance_MRewardEntry_DoNotUseDefaultTypeInternal _db_activity_drawcompliance_MRewardEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR db_activity_drawcompliance::db_activity_drawcompliance(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_reward_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.m_count_)*/0} {}
struct db_activity_drawcomplianceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_activity_drawcomplianceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_activity_drawcomplianceDefaultTypeInternal() {}
  union {
    db_activity_drawcompliance _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_activity_drawcomplianceDefaultTypeInternal _db_activity_drawcompliance_default_instance_;
PROTOBUF_CONSTEXPR db_activity_MDrawcomplianceEntry_DoNotUse::db_activity_MDrawcomplianceEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct db_activity_MDrawcomplianceEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_activity_MDrawcomplianceEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_activity_MDrawcomplianceEntry_DoNotUseDefaultTypeInternal() {}
  union {
    db_activity_MDrawcomplianceEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_activity_MDrawcomplianceEntry_DoNotUseDefaultTypeInternal _db_activity_MDrawcomplianceEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR db_activity::db_activity(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_drawcompliance_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.m_id_)*/int64_t{0}
  , /*decltype(_impl_.m_beg_)*/0
  , /*decltype(_impl_.m_end_)*/0
  , /*decltype(_impl_.m_start_)*/false
  , /*decltype(_impl_.m_finish_)*/false
  , /*decltype(_impl_.m_calendarid_)*/0} {}
struct db_activityDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_activityDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_activityDefaultTypeInternal() {}
  union {
    db_activity _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_activityDefaultTypeInternal _db_activity_default_instance_;
PROTOBUF_CONSTEXPR db_task_data_schedule::db_task_data_schedule(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_type_)*/0
  , /*decltype(_impl_.m_value_)*/0
  , /*decltype(_impl_.m_sumint_)*/0} {}
struct db_task_data_scheduleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_task_data_scheduleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_task_data_scheduleDefaultTypeInternal() {}
  union {
    db_task_data_schedule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_task_data_scheduleDefaultTypeInternal _db_task_data_schedule_default_instance_;
PROTOBUF_CONSTEXPR db_task_data::db_task_data(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_schedules_)*/{}
  , /*decltype(_impl_.m_taskid_)*/0
  , /*decltype(_impl_.m_receiveutc_)*/0
  , /*decltype(_impl_.m_finshutc_)*/0
  , /*decltype(_impl_.m_receive_)*/false} {}
struct db_task_dataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_task_dataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_task_dataDefaultTypeInternal() {}
  union {
    db_task_data _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_task_dataDefaultTypeInternal _db_task_data_default_instance_;
PROTOBUF_CONSTEXPR db_task_MRundatasEntry_DoNotUse::db_task_MRundatasEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct db_task_MRundatasEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_task_MRundatasEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_task_MRundatasEntry_DoNotUseDefaultTypeInternal() {}
  union {
    db_task_MRundatasEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_task_MRundatasEntry_DoNotUseDefaultTypeInternal _db_task_MRundatasEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR db_task_MCompleteddatasEntry_DoNotUse::db_task_MCompleteddatasEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct db_task_MCompleteddatasEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_task_MCompleteddatasEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_task_MCompleteddatasEntry_DoNotUseDefaultTypeInternal() {}
  union {
    db_task_MCompleteddatasEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_task_MCompleteddatasEntry_DoNotUseDefaultTypeInternal _db_task_MCompleteddatasEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR db_task::db_task(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_rundatas_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.m_completeddatas_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_.m_id_)*/int64_t{0}} {}
struct db_taskDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_taskDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_taskDefaultTypeInternal() {}
  union {
    db_task _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_taskDefaultTypeInternal _db_task_default_instance_;
PROTOBUF_CONSTEXPR db_calendar::db_calendar(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_id_)*/int64_t{0}
  , /*decltype(_impl_.m_time_)*/int64_t{0}
  , /*decltype(_impl_.m_start_)*/false
  , /*decltype(_impl_.m_finish_)*/false} {}
struct db_calendarDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_calendarDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_calendarDefaultTypeInternal() {}
  union {
    db_calendar _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_calendarDefaultTypeInternal _db_calendar_default_instance_;
PROTOBUF_CONSTEXPR db_familyer::db_familyer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_id_)*/int64_t{0}
  , /*decltype(_impl_.m_joinutc_)*/0
  , /*decltype(_impl_.m_lastsignutc_)*/0
  , /*decltype(_impl_.m_lastleaveutc_)*/0
  , /*decltype(_impl_.m_position_)*/0} {}
struct db_familyerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_familyerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_familyerDefaultTypeInternal() {}
  union {
    db_familyer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_familyerDefaultTypeInternal _db_familyer_default_instance_;
PROTOBUF_CONSTEXPR db_family::db_family(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_member_)*/{}
  , /*decltype(_impl_._m_member_cached_byte_size_)*/{0}
  , /*decltype(_impl_.m_applylist_)*/{}
  , /*decltype(_impl_._m_applylist_cached_byte_size_)*/{0}
  , /*decltype(_impl_.m_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.m_id_)*/int64_t{0}
  , /*decltype(_impl_.m_createutc_)*/0
  , /*decltype(_impl_.m_lv_)*/0
  , /*decltype(_impl_.m_leader_)*/int64_t{0}
  , /*decltype(_impl_.m_exp_)*/0} {}
struct db_familyDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_familyDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_familyDefaultTypeInternal() {}
  union {
    db_family _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_familyDefaultTypeInternal _db_family_default_instance_;
PROTOBUF_CONSTEXPR db_friends::db_friends(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.m_friends_)*/{}
  , /*decltype(_impl_._m_friends_cached_byte_size_)*/{0}
  , /*decltype(_impl_.m_applyfriends_)*/{}
  , /*decltype(_impl_._m_applyfriends_cached_byte_size_)*/{0}
  , /*decltype(_impl_.m_id_)*/int64_t{0}} {}
struct db_friendsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR db_friendsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~db_friendsDefaultTypeInternal() {}
  union {
    db_friends _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 db_friendsDefaultTypeInternal _db_friends_default_instance_;
}  // namespace pbdb
static ::_pb::Metadata file_level_metadata_db_2eproto[32];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_db_2eproto[4];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_db_2eproto = nullptr;

const uint32_t TableStruct_db_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::pbdb::db_account, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_account, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_account, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_account, _impl_.m_roleid_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_account, _impl_.m_account_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_account, _impl_.m_passworld_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_account, _impl_.m_area_),
  2,
  3,
  0,
  1,
  4,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _impl_.m_name_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _impl_.m_lv_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _impl_.m_moneygold_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _impl_.m_moneysilver_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _impl_.m_vip_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _impl_.m_notalkutc_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_brief, _impl_.m_createutc_),
  1,
  0,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_role_recharge, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_role_recharge, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_role_recharge, _impl_.m_rechargeid_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_role_recharge, _impl_.m_utc_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_role, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_role, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_role, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_role, _impl_.m_base_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_role, _impl_.m_recharge_),
  1,
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::pbdb::item, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::item, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::item, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::item, _impl_.m_tid_),
  PROTOBUF_FIELD_OFFSET(::pbdb::item, _impl_.m_count_),
  PROTOBUF_FIELD_OFFSET(::pbdb::item, _impl_.m_lv_),
  PROTOBUF_FIELD_OFFSET(::pbdb::item, _impl_.m_star_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_bag_MItemsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_bag_MItemsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_bag_MItemsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_bag_MItemsEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_bag, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_bag, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_bag, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_bag, _impl_.m_items_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_bag, _impl_.m_maxid_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_keyvalue, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_keyvalue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_keyvalue, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_keyvalue, _impl_.m_value_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_rolekeyvalue_MDataEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_rolekeyvalue_MDataEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_rolekeyvalue_MDataEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_rolekeyvalue_MDataEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_rolekeyvalue, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_rolekeyvalue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_rolekeyvalue, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_rolekeyvalue, _impl_.m_data_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::pbdb::mailitem, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::mailitem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::mailitem, _impl_.m_itemtid_),
  PROTOBUF_FIELD_OFFSET(::pbdb::mailitem, _impl_.m_count_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::mail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_.m_createutc_),
  PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_.m_tid_),
  PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_.m_prams_),
  PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_.m_content_),
  PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_.m_items_),
  PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_.m_read_),
  PROTOBUF_FIELD_OFFSET(::pbdb::mail, _impl_.m_draw_),
  2,
  3,
  4,
  0,
  1,
  ~0u,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_mail_MMailEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_mail_MMailEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_mail_MMailEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_mail_MMailEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_mail, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_mail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_mail, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_mail, _impl_.m_mail_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_guild, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_guild, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_guild, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_guild, _impl_.m_guild_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_guild, _impl_.m_leader_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_guild, _impl_.m_members_),
  1,
  0,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_notice, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_notice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_notice, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_notice, _impl_.m_notice_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_notice, _impl_.m_starttime_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_notice, _impl_.m_finishtime_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::pbdb::rankitem, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::rankitem, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::rankitem, _impl_.m_value_),
  PROTOBUF_FIELD_OFFSET(::pbdb::rankitem, _impl_.m_time_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_ranklist_MItemsEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_ranklist_MItemsEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_ranklist_MItemsEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_ranklist_MItemsEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_ranklist, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_ranklist, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_ranklist, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_ranklist, _impl_.m_items_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_drawcompliance_MRewardEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_drawcompliance_MRewardEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_drawcompliance_MRewardEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_drawcompliance_MRewardEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_drawcompliance, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_drawcompliance, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_drawcompliance, _impl_.m_count_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_drawcompliance, _impl_.m_reward_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_MDrawcomplianceEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_MDrawcomplianceEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_MDrawcomplianceEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity_MDrawcomplianceEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity, _impl_.m_beg_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity, _impl_.m_end_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity, _impl_.m_start_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity, _impl_.m_finish_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity, _impl_.m_calendarid_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_activity, _impl_.m_drawcompliance_),
  0,
  1,
  2,
  3,
  4,
  5,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data_schedule, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data_schedule, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data_schedule, _impl_.m_type_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data_schedule, _impl_.m_value_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data_schedule, _impl_.m_sumint_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data, _impl_.m_taskid_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data, _impl_.m_receiveutc_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data, _impl_.m_finshutc_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data, _impl_.m_schedules_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_data, _impl_.m_receive_),
  0,
  1,
  2,
  ~0u,
  3,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_MRundatasEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_MRundatasEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_MRundatasEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_MRundatasEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_MCompleteddatasEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_MCompleteddatasEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_MCompleteddatasEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task_MCompleteddatasEntry_DoNotUse, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task, _impl_.m_rundatas_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_task, _impl_.m_completeddatas_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_calendar, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_calendar, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_calendar, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_calendar, _impl_.m_time_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_calendar, _impl_.m_start_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_calendar, _impl_.m_finish_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_familyer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_familyer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_familyer, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_familyer, _impl_.m_joinutc_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_familyer, _impl_.m_lastsignutc_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_familyer, _impl_.m_lastleaveutc_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_familyer, _impl_.m_position_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_family, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_family, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_family, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_family, _impl_.m_createutc_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_family, _impl_.m_name_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_family, _impl_.m_leader_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_family, _impl_.m_lv_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_family, _impl_.m_exp_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_family, _impl_.m_member_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_family, _impl_.m_applylist_),
  1,
  2,
  0,
  4,
  3,
  5,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::pbdb::db_friends, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_friends, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::pbdb::db_friends, _impl_.m_id_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_friends, _impl_.m_friends_),
  PROTOBUF_FIELD_OFFSET(::pbdb::db_friends, _impl_.m_applyfriends_),
  0,
  ~0u,
  ~0u,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, -1, sizeof(::pbdb::db_account)},
  { 16, 30, -1, sizeof(::pbdb::db_brief)},
  { 38, 46, -1, sizeof(::pbdb::db_role_recharge)},
  { 48, 57, -1, sizeof(::pbdb::db_role)},
  { 60, 71, -1, sizeof(::pbdb::item)},
  { 76, 84, -1, sizeof(::pbdb::db_bag_MItemsEntry_DoNotUse)},
  { 86, 95, -1, sizeof(::pbdb::db_bag)},
  { 98, 106, -1, sizeof(::pbdb::db_keyvalue)},
  { 108, 116, -1, sizeof(::pbdb::db_rolekeyvalue_MDataEntry_DoNotUse)},
  { 118, 126, -1, sizeof(::pbdb::db_rolekeyvalue)},
  { 128, 136, -1, sizeof(::pbdb::mailitem)},
  { 138, 152, -1, sizeof(::pbdb::mail)},
  { 160, 168, -1, sizeof(::pbdb::db_mail_MMailEntry_DoNotUse)},
  { 170, 178, -1, sizeof(::pbdb::db_mail)},
  { 180, 190, -1, sizeof(::pbdb::db_guild)},
  { 194, 204, -1, sizeof(::pbdb::db_notice)},
  { 208, 216, -1, sizeof(::pbdb::rankitem)},
  { 218, 226, -1, sizeof(::pbdb::db_ranklist_MItemsEntry_DoNotUse)},
  { 228, 236, -1, sizeof(::pbdb::db_ranklist)},
  { 238, 246, -1, sizeof(::pbdb::db_activity_drawcompliance_MRewardEntry_DoNotUse)},
  { 248, 256, -1, sizeof(::pbdb::db_activity_drawcompliance)},
  { 258, 266, -1, sizeof(::pbdb::db_activity_MDrawcomplianceEntry_DoNotUse)},
  { 268, 281, -1, sizeof(::pbdb::db_activity)},
  { 288, 297, -1, sizeof(::pbdb::db_task_data_schedule)},
  { 300, 311, -1, sizeof(::pbdb::db_task_data)},
  { 316, 324, -1, sizeof(::pbdb::db_task_MRundatasEntry_DoNotUse)},
  { 326, 334, -1, sizeof(::pbdb::db_task_MCompleteddatasEntry_DoNotUse)},
  { 336, 345, -1, sizeof(::pbdb::db_task)},
  { 348, 358, -1, sizeof(::pbdb::db_calendar)},
  { 362, 373, -1, sizeof(::pbdb::db_familyer)},
  { 378, 392, -1, sizeof(::pbdb::db_family)},
  { 400, 409, -1, sizeof(::pbdb::db_friends)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::pbdb::_db_account_default_instance_._instance,
  &::pbdb::_db_brief_default_instance_._instance,
  &::pbdb::_db_role_recharge_default_instance_._instance,
  &::pbdb::_db_role_default_instance_._instance,
  &::pbdb::_item_default_instance_._instance,
  &::pbdb::_db_bag_MItemsEntry_DoNotUse_default_instance_._instance,
  &::pbdb::_db_bag_default_instance_._instance,
  &::pbdb::_db_keyvalue_default_instance_._instance,
  &::pbdb::_db_rolekeyvalue_MDataEntry_DoNotUse_default_instance_._instance,
  &::pbdb::_db_rolekeyvalue_default_instance_._instance,
  &::pbdb::_mailitem_default_instance_._instance,
  &::pbdb::_mail_default_instance_._instance,
  &::pbdb::_db_mail_MMailEntry_DoNotUse_default_instance_._instance,
  &::pbdb::_db_mail_default_instance_._instance,
  &::pbdb::_db_guild_default_instance_._instance,
  &::pbdb::_db_notice_default_instance_._instance,
  &::pbdb::_rankitem_default_instance_._instance,
  &::pbdb::_db_ranklist_MItemsEntry_DoNotUse_default_instance_._instance,
  &::pbdb::_db_ranklist_default_instance_._instance,
  &::pbdb::_db_activity_drawcompliance_MRewardEntry_DoNotUse_default_instance_._instance,
  &::pbdb::_db_activity_drawcompliance_default_instance_._instance,
  &::pbdb::_db_activity_MDrawcomplianceEntry_DoNotUse_default_instance_._instance,
  &::pbdb::_db_activity_default_instance_._instance,
  &::pbdb::_db_task_data_schedule_default_instance_._instance,
  &::pbdb::_db_task_data_default_instance_._instance,
  &::pbdb::_db_task_MRundatasEntry_DoNotUse_default_instance_._instance,
  &::pbdb::_db_task_MCompleteddatasEntry_DoNotUse_default_instance_._instance,
  &::pbdb::_db_task_default_instance_._instance,
  &::pbdb::_db_calendar_default_instance_._instance,
  &::pbdb::_db_familyer_default_instance_._instance,
  &::pbdb::_db_family_default_instance_._instance,
  &::pbdb::_db_friends_default_instance_._instance,
};

const char descriptor_table_protodef_db_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\010db.proto\022\004pbdb\"\274\001\n\ndb_account\022\021\n\004m_id\030"
  "\001 \001(\003H\000\210\001\001\022\025\n\010m_roleid\030\002 \001(\003H\001\210\001\001\022\026\n\tm_a"
  "ccount\030\003 \001(\tH\002\210\001\001\022\030\n\013m_passworld\030\004 \001(\tH\003"
  "\210\001\001\022\023\n\006m_area\030\005 \001(\005H\004\210\001\001B\007\n\005_m_idB\013\n\t_m_"
  "roleidB\014\n\n_m_accountB\016\n\014_m_passworldB\t\n\007"
  "_m_area\"\254\002\n\010db_brief\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022"
  "\023\n\006m_name\030\002 \001(\tH\001\210\001\001\022\021\n\004m_lv\030\003 \001(\005H\002\210\001\001\022"
  "\030\n\013m_moneygold\030\004 \001(\005H\003\210\001\001\022\032\n\rm_moneysilv"
  "er\030\005 \001(\005H\004\210\001\001\022\022\n\005m_vip\030\006 \001(\005H\005\210\001\001\022\030\n\013m_n"
  "otalkutc\030\007 \001(\005H\006\210\001\001\022\030\n\013m_createutc\030\010 \001(\005"
  "H\007\210\001\001B\007\n\005_m_idB\t\n\007_m_nameB\007\n\005_m_lvB\016\n\014_m"
  "_moneygoldB\020\n\016_m_moneysilverB\010\n\006_m_vipB\016"
  "\n\014_m_notalkutcB\016\n\014_m_createutc\"\327\001\n\007db_ro"
  "le\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022#\n\006m_base\030\002 \001(\0132\016."
  "pbdb.db_briefH\001\210\001\001\022*\n\nm_recharge\030\003 \003(\0132\026"
  ".pbdb.db_role.recharge\032T\n\010recharge\022\031\n\014m_"
  "rechargeid\030\001 \001(\005H\000\210\001\001\022\022\n\005m_utc\030\002 \001(\005H\001\210\001"
  "\001B\017\n\r_m_rechargeidB\010\n\006_m_utcB\007\n\005_m_idB\t\n"
  "\007_m_base\"\236\001\n\004item\022\021\n\004m_id\030\001 \001(\005H\000\210\001\001\022\022\n\005"
  "m_tid\030\002 \001(\005H\001\210\001\001\022\024\n\007m_count\030\003 \001(\005H\002\210\001\001\022\021"
  "\n\004m_lv\030\004 \001(\005H\003\210\001\001\022\023\n\006m_star\030\005 \001(\005H\004\210\001\001B\007"
  "\n\005_m_idB\010\n\006_m_tidB\n\n\010_m_countB\007\n\005_m_lvB\t"
  "\n\007_m_star\"\254\001\n\006db_bag\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022"
  ")\n\007m_items\030\002 \003(\0132\030.pbdb.db_bag.MItemsEnt"
  "ry\022\024\n\007m_maxid\030\003 \001(\005H\001\210\001\001\0329\n\013MItemsEntry\022"
  "\013\n\003key\030\001 \001(\005\022\031\n\005value\030\002 \001(\0132\n.pbdb.item:"
  "\0028\001B\007\n\005_m_idB\n\n\010_m_maxid\"m\n\013db_keyvalue\022"
  "\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022\024\n\007m_value\030\002 \001(\tH\001\210\001\001"
  "\" \n\003ekv\022\010\n\004none\020\000\022\017\n\013account_ban\020\001B\007\n\005_m"
  "_idB\n\n\010_m_value\"\215\001\n\017db_rolekeyvalue\022\021\n\004m"
  "_id\030\001 \001(\003H\000\210\001\001\0220\n\006m_data\030\002 \003(\0132 .pbdb.db"
  "_rolekeyvalue.MDataEntry\032,\n\nMDataEntry\022\013"
  "\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\t:\0028\001B\007\n\005_m_id\""
  "R\n\010mailitem\022\026\n\tm_itemtid\030\001 \001(\005H\000\210\001\001\022\024\n\007m"
  "_count\030\002 \001(\005H\001\210\001\001B\014\n\n_m_itemtidB\n\n\010_m_co"
  "unt\"\223\002\n\004mail\022\021\n\004m_id\030\001 \001(\005H\000\210\001\001\022\030\n\013m_cre"
  "ateutc\030\002 \001(\005H\001\210\001\001\022\022\n\005m_tid\030\003 \001(\005H\002\210\001\001\022\024\n"
  "\007m_prams\030\004 \001(\tH\003\210\001\001\022\026\n\tm_content\030\005 \001(\tH\004"
  "\210\001\001\022\037\n\007m_items\030\006 \003(\0132\016.pbdb.mailitem\022\023\n\006"
  "m_read\030\007 \001(\010H\005\210\001\001\022\023\n\006m_draw\030\010 \001(\010H\006\210\001\001B\007"
  "\n\005_m_idB\016\n\014_m_createutcB\010\n\006_m_tidB\n\n\010_m_"
  "pramsB\014\n\n_m_contentB\t\n\007_m_readB\t\n\007_m_dra"
  "w\"\211\001\n\007db_mail\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022(\n\006m_ma"
  "il\030\002 \003(\0132\030.pbdb.db_mail.MMailEntry\0328\n\nMM"
  "ailEntry\022\013\n\003key\030\001 \001(\005\022\031\n\005value\030\002 \001(\0132\n.p"
  "bdb.mail:\0028\001B\007\n\005_m_id\"\177\n\010db_guild\022\021\n\004m_i"
  "d\030\001 \001(\003H\000\210\001\001\022\024\n\007m_guild\030\002 \001(\tH\001\210\001\001\022\025\n\010m_"
  "leader\030\003 \001(\003H\002\210\001\001\022\021\n\tm_members\030\004 \003(\003B\007\n\005"
  "_m_idB\n\n\010_m_guildB\013\n\t_m_leader\"\241\001\n\tdb_no"
  "tice\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022\025\n\010m_notice\030\002 \001("
  "\tH\001\210\001\001\022\030\n\013m_starttime\030\003 \001(\005H\002\210\001\001\022\031\n\014m_fi"
  "nishtime\030\004 \001(\005H\003\210\001\001B\007\n\005_m_idB\013\n\t_m_notic"
  "eB\016\n\014_m_starttimeB\017\n\r_m_finishtime\"L\n\010ra"
  "nkitem\022\024\n\007m_value\030\001 \001(\003H\000\210\001\001\022\023\n\006m_time\030\002"
  " \001(\005H\001\210\001\001B\n\n\010_m_valueB\t\n\007_m_time\"\230\001\n\013db_"
  "ranklist\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022.\n\007m_items\030\002"
  " \003(\0132\035.pbdb.db_ranklist.MItemsEntry\032=\n\013M"
  "ItemsEntry\022\013\n\003key\030\001 \001(\005\022\035\n\005value\030\002 \001(\0132\016"
  ".pbdb.rankitem:\0028\001B\007\n\005_m_id\"\231\004\n\013db_activ"
  "ity\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022\022\n\005m_beg\030\002 \001(\005H\001\210"
  "\001\001\022\022\n\005m_end\030\003 \001(\005H\002\210\001\001\022\024\n\007m_start\030\004 \001(\010H"
  "\003\210\001\001\022\025\n\010m_finish\030\005 \001(\010H\004\210\001\001\022\031\n\014m_calenda"
  "rid\030\006 \001(\005H\005\210\001\001\022@\n\020m_drawcompliance\030\007 \003(\013"
  "2&.pbdb.db_activity.MDrawcomplianceEntry"
  "\032\243\001\n\016drawcompliance\022\024\n\007m_count\030\001 \001(\005H\000\210\001"
  "\001\022\?\n\010m_reward\030\002 \003(\0132-.pbdb.db_activity.d"
  "rawcompliance.MRewardEntry\032.\n\014MRewardEnt"
  "ry\022\013\n\003key\030\001 \001(\005\022\r\n\005value\030\002 \001(\010:\0028\001B\n\n\010_m"
  "_count\032X\n\024MDrawcomplianceEntry\022\013\n\003key\030\001 "
  "\001(\003\022/\n\005value\030\002 \001(\0132 .pbdb.db_activity.dr"
  "awcompliance:\0028\001B\007\n\005_m_idB\010\n\006_m_begB\010\n\006_"
  "m_endB\n\n\010_m_startB\013\n\t_m_finishB\017\n\r_m_cal"
  "endarid\"\367\004\n\007db_task\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\0220"
  "\n\nm_rundatas\030\002 \003(\0132\034.pbdb.db_task.MRunda"
  "tasEntry\022<\n\020m_completeddatas\030\003 \003(\0132\".pbd"
  "b.db_task.MCompleteddatasEntry\032u\n\rdata_s"
  "chedule\022\023\n\006m_type\030\001 \001(\005H\000\210\001\001\022\024\n\007m_value\030"
  "\002 \001(\005H\001\210\001\001\022\025\n\010m_sumint\030\003 \001(\005H\002\210\001\001B\t\n\007_m_"
  "typeB\n\n\010_m_valueB\013\n\t_m_sumint\032\326\001\n\004data\022\025"
  "\n\010m_taskid\030\001 \001(\005H\000\210\001\001\022\031\n\014m_receiveutc\030\002 "
  "\001(\005H\001\210\001\001\022\027\n\nm_finshutc\030\003 \001(\005H\002\210\001\001\0220\n\013m_s"
  "chedules\030\004 \003(\0132\033.pbdb.db_task.data_sched"
  "ule\022\026\n\tm_receive\030\005 \001(\010H\003\210\001\001B\013\n\t_m_taskid"
  "B\017\n\r_m_receiveutcB\r\n\013_m_finshutcB\014\n\n_m_r"
  "eceive\032D\n\016MRundatasEntry\022\013\n\003key\030\001 \001(\005\022!\n"
  "\005value\030\002 \001(\0132\022.pbdb.db_task.data:\0028\001\032J\n\024"
  "MCompleteddatasEntry\022\013\n\003key\030\001 \001(\005\022!\n\005val"
  "ue\030\002 \001(\0132\022.pbdb.db_task.data:\0028\001B\007\n\005_m_i"
  "d\"\217\001\n\013db_calendar\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022\023\n\006"
  "m_time\030\002 \001(\003H\001\210\001\001\022\024\n\007m_start\030\003 \001(\010H\002\210\001\001\022"
  "\025\n\010m_finish\030\004 \001(\010H\003\210\001\001B\007\n\005_m_idB\t\n\007_m_ti"
  "meB\n\n\010_m_startB\013\n\t_m_finish\"\263\002\n\013db_famil"
  "yer\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022\026\n\tm_joinutc\030\002 \001("
  "\005H\001\210\001\001\022\032\n\rm_lastsignutc\030\003 \001(\005H\002\210\001\001\022\033\n\016m_"
  "lastleaveutc\030\004 \001(\005H\003\210\001\001\0224\n\nm_position\030\005 "
  "\001(\0162\033.pbdb.db_familyer.epositionH\004\210\001\001\"\?\n"
  "\teposition\022\010\n\004none\020\000\022\n\n\006leader\020\001\022\016\n\ncoun"
  "sellor\020\002\022\014\n\010ordinary\020\003B\007\n\005_m_idB\014\n\n_m_jo"
  "inutcB\020\n\016_m_lastsignutcB\021\n\017_m_lastleaveu"
  "tcB\r\n\013_m_position\"\366\001\n\tdb_family\022\021\n\004m_id\030"
  "\001 \001(\003H\000\210\001\001\022\030\n\013m_createutc\030\002 \001(\005H\001\210\001\001\022\023\n\006"
  "m_name\030\003 \001(\tH\002\210\001\001\022\025\n\010m_leader\030\004 \001(\003H\003\210\001\001"
  "\022\021\n\004m_lv\030\005 \001(\005H\004\210\001\001\022\022\n\005m_exp\030\006 \001(\005H\005\210\001\001\022"
  "\020\n\010m_member\030\007 \003(\003\022\023\n\013m_applylist\030\010 \003(\003B\007"
  "\n\005_m_idB\016\n\014_m_createutcB\t\n\007_m_nameB\013\n\t_m"
  "_leaderB\007\n\005_m_lvB\010\n\006_m_exp\"S\n\ndb_friends"
  "\022\021\n\004m_id\030\001 \001(\003H\000\210\001\001\022\021\n\tm_friends\030\002 \003(\003\022\026"
  "\n\016m_applyfriends\030\003 \003(\003B\007\n\005_m_id*\343\002\n\007ENUM"
  "_DB\022\023\n\017ENUM_DB_ACCOUNT\020\000\022\020\n\014ENUM_DB_ROLE"
  "\020\001\022\021\n\rENUM_DB_BRIEF\020\002\022\017\n\013ENUM_DB_BAG\020\003\022\024"
  "\n\020ENUM_DB_KEYVALUE\020\004\022\020\n\014ENUM_DB_MAIL\020\005\022\021"
  "\n\rENUM_DB_GUILD\020\006\022\022\n\016ENUM_DB_NOTICE\020\007\022\024\n"
  "\020ENUM_DB_RANKLIST\020\010\022\024\n\020ENUM_DB_ACTIVITY\020"
  "\t\022\020\n\014ENUM_DB_TASK\020\n\022\024\n\020ENUM_DB_CALENDAR\020"
  "\013\022\030\n\024ENUM_DB_ROLEKEYVALUE\020\014\022\022\n\016ENUM_DB_F"
  "AMILY\020\r\022\024\n\020ENUM_DB_FAMILYER\020\016\022\023\n\017ENUM_DB"
  "_FRIENDS\020\017\022\021\n\rENUM_DB_COUNT\020\020*\036\n\terankli"
  "st\022\006\n\002lv\020\000\022\t\n\005count\020\001b\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_db_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_db_2eproto = {
    false, false, 4709, descriptor_table_protodef_db_2eproto,
    "db.proto",
    &descriptor_table_db_2eproto_once, nullptr, 0, 32,
    schemas, file_default_instances, TableStruct_db_2eproto::offsets,
    file_level_metadata_db_2eproto, file_level_enum_descriptors_db_2eproto,
    file_level_service_descriptors_db_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_db_2eproto_getter() {
  return &descriptor_table_db_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_db_2eproto(&descriptor_table_db_2eproto);
namespace pbdb {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* db_keyvalue_ekv_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_db_2eproto);
  return file_level_enum_descriptors_db_2eproto[0];
}
bool db_keyvalue_ekv_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr db_keyvalue_ekv db_keyvalue::none;
constexpr db_keyvalue_ekv db_keyvalue::account_ban;
constexpr db_keyvalue_ekv db_keyvalue::ekv_MIN;
constexpr db_keyvalue_ekv db_keyvalue::ekv_MAX;
constexpr int db_keyvalue::ekv_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* db_familyer_eposition_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_db_2eproto);
  return file_level_enum_descriptors_db_2eproto[1];
}
bool db_familyer_eposition_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr db_familyer_eposition db_familyer::none;
constexpr db_familyer_eposition db_familyer::leader;
constexpr db_familyer_eposition db_familyer::counsellor;
constexpr db_familyer_eposition db_familyer::ordinary;
constexpr db_familyer_eposition db_familyer::eposition_MIN;
constexpr db_familyer_eposition db_familyer::eposition_MAX;
constexpr int db_familyer::eposition_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ENUM_DB_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_db_2eproto);
  return file_level_enum_descriptors_db_2eproto[2];
}
bool ENUM_DB_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* eranklist_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_db_2eproto);
  return file_level_enum_descriptors_db_2eproto[3];
}
bool eranklist_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class db_account::_Internal {
 public:
  using HasBits = decltype(std::declval<db_account>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_roleid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_m_account(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_passworld(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_area(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

db_account::db_account(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_account)
}
db_account::db_account(const db_account& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_account* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_account_){}
    , decltype(_impl_.m_passworld_){}
    , decltype(_impl_.m_id_){}
    , decltype(_impl_.m_roleid_){}
    , decltype(_impl_.m_area_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.m_account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_account_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_m_account()) {
    _this->_impl_.m_account_.Set(from._internal_m_account(), 
      _this->GetArenaForAllocation());
  }
  _impl_.m_passworld_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_passworld_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_m_passworld()) {
    _this->_impl_.m_passworld_.Set(from._internal_m_passworld(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_area_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_area_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_account)
}

inline void db_account::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_account_){}
    , decltype(_impl_.m_passworld_){}
    , decltype(_impl_.m_id_){int64_t{0}}
    , decltype(_impl_.m_roleid_){int64_t{0}}
    , decltype(_impl_.m_area_){0}
  };
  _impl_.m_account_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_account_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.m_passworld_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_passworld_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

db_account::~db_account() {
  // @@protoc_insertion_point(destructor:pbdb.db_account)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_account::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_account_.Destroy();
  _impl_.m_passworld_.Destroy();
}

void db_account::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_account::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_account)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.m_account_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.m_passworld_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.m_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_area_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_area_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_account::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 m_roleid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_m_roleid(&has_bits);
          _impl_.m_roleid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string m_account = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_m_account();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.db_account.m_account"));
        } else
          goto handle_unusual;
        continue;
      // optional string m_passworld = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_m_passworld();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.db_account.m_passworld"));
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_area = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_m_area(&has_bits);
          _impl_.m_area_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_account::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_account)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_id(), target);
  }

  // optional int64 m_roleid = 2;
  if (_internal_has_m_roleid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_m_roleid(), target);
  }

  // optional string m_account = 3;
  if (_internal_has_m_account()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_m_account().data(), static_cast<int>(this->_internal_m_account().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pbdb.db_account.m_account");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_m_account(), target);
  }

  // optional string m_passworld = 4;
  if (_internal_has_m_passworld()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_m_passworld().data(), static_cast<int>(this->_internal_m_passworld().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pbdb.db_account.m_passworld");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_m_passworld(), target);
  }

  // optional int32 m_area = 5;
  if (_internal_has_m_area()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_m_area(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_account)
  return target;
}

size_t db_account::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_account)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string m_account = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_m_account());
    }

    // optional string m_passworld = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_m_passworld());
    }

    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_id());
    }

    // optional int64 m_roleid = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_roleid());
    }

    // optional int32 m_area = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_area());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_account::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_account::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_account::GetClassData() const { return &_class_data_; }


void db_account::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_account*>(&to_msg);
  auto& from = static_cast<const db_account&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_account)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_m_account(from._internal_m_account());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_m_passworld(from._internal_m_passworld());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_roleid_ = from._impl_.m_roleid_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.m_area_ = from._impl_.m_area_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_account::CopyFrom(const db_account& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_account)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_account::IsInitialized() const {
  return true;
}

void db_account::InternalSwap(db_account* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.m_account_, lhs_arena,
      &other->_impl_.m_account_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.m_passworld_, lhs_arena,
      &other->_impl_.m_passworld_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_account, _impl_.m_area_)
      + sizeof(db_account::_impl_.m_area_)
      - PROTOBUF_FIELD_OFFSET(db_account, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_account::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[0]);
}

// ===================================================================

class db_brief::_Internal {
 public:
  using HasBits = decltype(std::declval<db_brief>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_lv(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_moneygold(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_m_moneysilver(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_m_vip(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_m_notalkutc(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_m_createutc(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

db_brief::db_brief(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_brief)
}
db_brief::db_brief(const db_brief& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_brief* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_name_){}
    , decltype(_impl_.m_id_){}
    , decltype(_impl_.m_lv_){}
    , decltype(_impl_.m_moneygold_){}
    , decltype(_impl_.m_moneysilver_){}
    , decltype(_impl_.m_vip_){}
    , decltype(_impl_.m_notalkutc_){}
    , decltype(_impl_.m_createutc_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.m_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_m_name()) {
    _this->_impl_.m_name_.Set(from._internal_m_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_createutc_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_createutc_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_brief)
}

inline void db_brief::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_name_){}
    , decltype(_impl_.m_id_){int64_t{0}}
    , decltype(_impl_.m_lv_){0}
    , decltype(_impl_.m_moneygold_){0}
    , decltype(_impl_.m_moneysilver_){0}
    , decltype(_impl_.m_vip_){0}
    , decltype(_impl_.m_notalkutc_){0}
    , decltype(_impl_.m_createutc_){0}
  };
  _impl_.m_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

db_brief::~db_brief() {
  // @@protoc_insertion_point(destructor:pbdb.db_brief)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_brief::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_name_.Destroy();
}

void db_brief::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_brief::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_brief)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.m_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.m_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_createutc_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_createutc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_brief::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string m_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_m_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.db_brief.m_name"));
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_lv = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_m_lv(&has_bits);
          _impl_.m_lv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_moneygold = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_m_moneygold(&has_bits);
          _impl_.m_moneygold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_moneysilver = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_m_moneysilver(&has_bits);
          _impl_.m_moneysilver_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_vip = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_m_vip(&has_bits);
          _impl_.m_vip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_notalkutc = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_m_notalkutc(&has_bits);
          _impl_.m_notalkutc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_createutc = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_m_createutc(&has_bits);
          _impl_.m_createutc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_brief::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_brief)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_id(), target);
  }

  // optional string m_name = 2;
  if (_internal_has_m_name()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_m_name().data(), static_cast<int>(this->_internal_m_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pbdb.db_brief.m_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_m_name(), target);
  }

  // optional int32 m_lv = 3;
  if (_internal_has_m_lv()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_m_lv(), target);
  }

  // optional int32 m_moneygold = 4;
  if (_internal_has_m_moneygold()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_m_moneygold(), target);
  }

  // optional int32 m_moneysilver = 5;
  if (_internal_has_m_moneysilver()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_m_moneysilver(), target);
  }

  // optional int32 m_vip = 6;
  if (_internal_has_m_vip()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_m_vip(), target);
  }

  // optional int32 m_notalkutc = 7;
  if (_internal_has_m_notalkutc()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_m_notalkutc(), target);
  }

  // optional int32 m_createutc = 8;
  if (_internal_has_m_createutc()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_m_createutc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_brief)
  return target;
}

size_t db_brief::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_brief)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string m_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_m_name());
    }

    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_id());
    }

    // optional int32 m_lv = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_lv());
    }

    // optional int32 m_moneygold = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_moneygold());
    }

    // optional int32 m_moneysilver = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_moneysilver());
    }

    // optional int32 m_vip = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_vip());
    }

    // optional int32 m_notalkutc = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_notalkutc());
    }

    // optional int32 m_createutc = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_createutc());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_brief::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_brief::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_brief::GetClassData() const { return &_class_data_; }


void db_brief::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_brief*>(&to_msg);
  auto& from = static_cast<const db_brief&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_brief)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_m_name(from._internal_m_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_lv_ = from._impl_.m_lv_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_moneygold_ = from._impl_.m_moneygold_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.m_moneysilver_ = from._impl_.m_moneysilver_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.m_vip_ = from._impl_.m_vip_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.m_notalkutc_ = from._impl_.m_notalkutc_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.m_createutc_ = from._impl_.m_createutc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_brief::CopyFrom(const db_brief& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_brief)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_brief::IsInitialized() const {
  return true;
}

void db_brief::InternalSwap(db_brief* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.m_name_, lhs_arena,
      &other->_impl_.m_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_brief, _impl_.m_createutc_)
      + sizeof(db_brief::_impl_.m_createutc_)
      - PROTOBUF_FIELD_OFFSET(db_brief, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_brief::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[1]);
}

// ===================================================================

class db_role_recharge::_Internal {
 public:
  using HasBits = decltype(std::declval<db_role_recharge>()._impl_._has_bits_);
  static void set_has_m_rechargeid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_utc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

db_role_recharge::db_role_recharge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_role.recharge)
}
db_role_recharge::db_role_recharge(const db_role_recharge& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_role_recharge* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_rechargeid_){}
    , decltype(_impl_.m_utc_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.m_rechargeid_, &from._impl_.m_rechargeid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_utc_) -
    reinterpret_cast<char*>(&_impl_.m_rechargeid_)) + sizeof(_impl_.m_utc_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_role.recharge)
}

inline void db_role_recharge::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_rechargeid_){0}
    , decltype(_impl_.m_utc_){0}
  };
}

db_role_recharge::~db_role_recharge() {
  // @@protoc_insertion_point(destructor:pbdb.db_role.recharge)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_role_recharge::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void db_role_recharge::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_role_recharge::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_role.recharge)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.m_rechargeid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_utc_) -
        reinterpret_cast<char*>(&_impl_.m_rechargeid_)) + sizeof(_impl_.m_utc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_role_recharge::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 m_rechargeid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_rechargeid(&has_bits);
          _impl_.m_rechargeid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_utc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_m_utc(&has_bits);
          _impl_.m_utc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_role_recharge::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_role.recharge)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 m_rechargeid = 1;
  if (_internal_has_m_rechargeid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_m_rechargeid(), target);
  }

  // optional int32 m_utc = 2;
  if (_internal_has_m_utc()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_m_utc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_role.recharge)
  return target;
}

size_t db_role_recharge::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_role.recharge)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 m_rechargeid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_rechargeid());
    }

    // optional int32 m_utc = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_utc());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_role_recharge::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_role_recharge::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_role_recharge::GetClassData() const { return &_class_data_; }


void db_role_recharge::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_role_recharge*>(&to_msg);
  auto& from = static_cast<const db_role_recharge&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_role.recharge)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m_rechargeid_ = from._impl_.m_rechargeid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_utc_ = from._impl_.m_utc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_role_recharge::CopyFrom(const db_role_recharge& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_role.recharge)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_role_recharge::IsInitialized() const {
  return true;
}

void db_role_recharge::InternalSwap(db_role_recharge* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_role_recharge, _impl_.m_utc_)
      + sizeof(db_role_recharge::_impl_.m_utc_)
      - PROTOBUF_FIELD_OFFSET(db_role_recharge, _impl_.m_rechargeid_)>(
          reinterpret_cast<char*>(&_impl_.m_rechargeid_),
          reinterpret_cast<char*>(&other->_impl_.m_rechargeid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_role_recharge::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[2]);
}

// ===================================================================

class db_role::_Internal {
 public:
  using HasBits = decltype(std::declval<db_role>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::pbdb::db_brief& m_base(const db_role* msg);
  static void set_has_m_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::pbdb::db_brief&
db_role::_Internal::m_base(const db_role* msg) {
  return *msg->_impl_.m_base_;
}
db_role::db_role(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_role)
}
db_role::db_role(const db_role& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_role* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_recharge_){from._impl_.m_recharge_}
    , decltype(_impl_.m_base_){nullptr}
    , decltype(_impl_.m_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_m_base()) {
    _this->_impl_.m_base_ = new ::pbdb::db_brief(*from._impl_.m_base_);
  }
  _this->_impl_.m_id_ = from._impl_.m_id_;
  // @@protoc_insertion_point(copy_constructor:pbdb.db_role)
}

inline void db_role::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_recharge_){arena}
    , decltype(_impl_.m_base_){nullptr}
    , decltype(_impl_.m_id_){int64_t{0}}
  };
}

db_role::~db_role() {
  // @@protoc_insertion_point(destructor:pbdb.db_role)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_role::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_recharge_.~RepeatedPtrField();
  if (this != internal_default_instance()) delete _impl_.m_base_;
}

void db_role::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_role::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_role)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_recharge_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.m_base_ != nullptr);
    _impl_.m_base_->Clear();
  }
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_role::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .pbdb.db_brief m_base = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_m_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .pbdb.db_role.recharge m_recharge = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_m_recharge(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_role::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_role)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_id(), target);
  }

  // optional .pbdb.db_brief m_base = 2;
  if (_internal_has_m_base()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::m_base(this),
        _Internal::m_base(this).GetCachedSize(), target, stream);
  }

  // repeated .pbdb.db_role.recharge m_recharge = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_m_recharge_size()); i < n; i++) {
    const auto& repfield = this->_internal_m_recharge(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_role)
  return target;
}

size_t db_role::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_role)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pbdb.db_role.recharge m_recharge = 3;
  total_size += 1UL * this->_internal_m_recharge_size();
  for (const auto& msg : this->_impl_.m_recharge_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .pbdb.db_brief m_base = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.m_base_);
    }

    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_role::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_role::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_role::GetClassData() const { return &_class_data_; }


void db_role::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_role*>(&to_msg);
  auto& from = static_cast<const db_role&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_role)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_recharge_.MergeFrom(from._impl_.m_recharge_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_m_base()->::pbdb::db_brief::MergeFrom(
          from._internal_m_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_role::CopyFrom(const db_role& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_role)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_role::IsInitialized() const {
  return true;
}

void db_role::InternalSwap(db_role* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_recharge_.InternalSwap(&other->_impl_.m_recharge_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_role, _impl_.m_id_)
      + sizeof(db_role::_impl_.m_id_)
      - PROTOBUF_FIELD_OFFSET(db_role, _impl_.m_base_)>(
          reinterpret_cast<char*>(&_impl_.m_base_),
          reinterpret_cast<char*>(&other->_impl_.m_base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_role::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[3]);
}

// ===================================================================

class item::_Internal {
 public:
  using HasBits = decltype(std::declval<item>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_tid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_lv(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_m_star(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

item::item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.item)
}
item::item(const item& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  item* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_id_){}
    , decltype(_impl_.m_tid_){}
    , decltype(_impl_.m_count_){}
    , decltype(_impl_.m_lv_){}
    , decltype(_impl_.m_star_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_star_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_star_));
  // @@protoc_insertion_point(copy_constructor:pbdb.item)
}

inline void item::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_id_){0}
    , decltype(_impl_.m_tid_){0}
    , decltype(_impl_.m_count_){0}
    , decltype(_impl_.m_lv_){0}
    , decltype(_impl_.m_star_){0}
  };
}

item::~item() {
  // @@protoc_insertion_point(destructor:pbdb.item)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void item::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void item::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void item::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.item)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.m_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_star_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_star_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* item::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_tid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_m_tid(&has_bits);
          _impl_.m_tid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_m_count(&has_bits);
          _impl_.m_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_lv = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_m_lv(&has_bits);
          _impl_.m_lv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_star = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_m_star(&has_bits);
          _impl_.m_star_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* item::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.item)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_m_id(), target);
  }

  // optional int32 m_tid = 2;
  if (_internal_has_m_tid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_m_tid(), target);
  }

  // optional int32 m_count = 3;
  if (_internal_has_m_count()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_m_count(), target);
  }

  // optional int32 m_lv = 4;
  if (_internal_has_m_lv()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_m_lv(), target);
  }

  // optional int32 m_star = 5;
  if (_internal_has_m_star()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_m_star(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.item)
  return target;
}

size_t item::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.item)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 m_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_id());
    }

    // optional int32 m_tid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_tid());
    }

    // optional int32 m_count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_count());
    }

    // optional int32 m_lv = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_lv());
    }

    // optional int32 m_star = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_star());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData item::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    item::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*item::GetClassData() const { return &_class_data_; }


void item::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<item*>(&to_msg);
  auto& from = static_cast<const item&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.item)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_tid_ = from._impl_.m_tid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_count_ = from._impl_.m_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_lv_ = from._impl_.m_lv_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.m_star_ = from._impl_.m_star_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void item::CopyFrom(const item& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.item)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool item::IsInitialized() const {
  return true;
}

void item::InternalSwap(item* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(item, _impl_.m_star_)
      + sizeof(item::_impl_.m_star_)
      - PROTOBUF_FIELD_OFFSET(item, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata item::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[4]);
}

// ===================================================================

db_bag_MItemsEntry_DoNotUse::db_bag_MItemsEntry_DoNotUse() {}
db_bag_MItemsEntry_DoNotUse::db_bag_MItemsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void db_bag_MItemsEntry_DoNotUse::MergeFrom(const db_bag_MItemsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata db_bag_MItemsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[5]);
}

// ===================================================================

class db_bag::_Internal {
 public:
  using HasBits = decltype(std::declval<db_bag>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_maxid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

db_bag::db_bag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &db_bag::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:pbdb.db_bag)
}
db_bag::db_bag(const db_bag& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_bag* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_items_)*/{}
    , decltype(_impl_.m_id_){}
    , decltype(_impl_.m_maxid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.m_items_.MergeFrom(from._impl_.m_items_);
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_maxid_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_maxid_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_bag)
}

inline void db_bag::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_items_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.m_id_){int64_t{0}}
    , decltype(_impl_.m_maxid_){0}
  };
}

db_bag::~db_bag() {
  // @@protoc_insertion_point(destructor:pbdb.db_bag)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void db_bag::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_items_.Destruct();
  _impl_.m_items_.~MapField();
}

void db_bag::ArenaDtor(void* object) {
  db_bag* _this = reinterpret_cast< db_bag* >(object);
  _this->_impl_.m_items_.Destruct();
}
void db_bag::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_bag::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_bag)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.m_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_maxid_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_maxid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_bag::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<int32, .pbdb.item> m_items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.m_items_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_maxid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_m_maxid(&has_bits);
          _impl_.m_maxid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_bag::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_bag)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_id(), target);
  }

  // map<int32, .pbdb.item> m_items = 2;
  if (!this->_internal_m_items().empty()) {
    using MapType = ::_pb::Map<int32_t, ::pbdb::item>;
    using WireHelper = db_bag_MItemsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_m_items();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    }
  }

  // optional int32 m_maxid = 3;
  if (_internal_has_m_maxid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_m_maxid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_bag)
  return target;
}

size_t db_bag::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_bag)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int32, .pbdb.item> m_items = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_m_items_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >::const_iterator
      it = this->_internal_m_items().begin();
      it != this->_internal_m_items().end(); ++it) {
    total_size += db_bag_MItemsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_id());
    }

    // optional int32 m_maxid = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_maxid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_bag::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_bag::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_bag::GetClassData() const { return &_class_data_; }


void db_bag::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_bag*>(&to_msg);
  auto& from = static_cast<const db_bag&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_bag)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_items_.MergeFrom(from._impl_.m_items_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_maxid_ = from._impl_.m_maxid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_bag::CopyFrom(const db_bag& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_bag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_bag::IsInitialized() const {
  return true;
}

void db_bag::InternalSwap(db_bag* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_items_.InternalSwap(&other->_impl_.m_items_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_bag, _impl_.m_maxid_)
      + sizeof(db_bag::_impl_.m_maxid_)
      - PROTOBUF_FIELD_OFFSET(db_bag, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_bag::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[6]);
}

// ===================================================================

class db_keyvalue::_Internal {
 public:
  using HasBits = decltype(std::declval<db_keyvalue>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

db_keyvalue::db_keyvalue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_keyvalue)
}
db_keyvalue::db_keyvalue(const db_keyvalue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_keyvalue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_value_){}
    , decltype(_impl_.m_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.m_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_m_value()) {
    _this->_impl_.m_value_.Set(from._internal_m_value(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.m_id_ = from._impl_.m_id_;
  // @@protoc_insertion_point(copy_constructor:pbdb.db_keyvalue)
}

inline void db_keyvalue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_value_){}
    , decltype(_impl_.m_id_){int64_t{0}}
  };
  _impl_.m_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

db_keyvalue::~db_keyvalue() {
  // @@protoc_insertion_point(destructor:pbdb.db_keyvalue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_keyvalue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_value_.Destroy();
}

void db_keyvalue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_keyvalue::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_keyvalue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.m_value_.ClearNonDefaultToEmpty();
  }
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_keyvalue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string m_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_m_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.db_keyvalue.m_value"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_keyvalue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_keyvalue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_id(), target);
  }

  // optional string m_value = 2;
  if (_internal_has_m_value()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_m_value().data(), static_cast<int>(this->_internal_m_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pbdb.db_keyvalue.m_value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_m_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_keyvalue)
  return target;
}

size_t db_keyvalue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_keyvalue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string m_value = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_m_value());
    }

    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_keyvalue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_keyvalue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_keyvalue::GetClassData() const { return &_class_data_; }


void db_keyvalue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_keyvalue*>(&to_msg);
  auto& from = static_cast<const db_keyvalue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_keyvalue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_m_value(from._internal_m_value());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_keyvalue::CopyFrom(const db_keyvalue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_keyvalue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_keyvalue::IsInitialized() const {
  return true;
}

void db_keyvalue::InternalSwap(db_keyvalue* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.m_value_, lhs_arena,
      &other->_impl_.m_value_, rhs_arena
  );
  swap(_impl_.m_id_, other->_impl_.m_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata db_keyvalue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[7]);
}

// ===================================================================

db_rolekeyvalue_MDataEntry_DoNotUse::db_rolekeyvalue_MDataEntry_DoNotUse() {}
db_rolekeyvalue_MDataEntry_DoNotUse::db_rolekeyvalue_MDataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void db_rolekeyvalue_MDataEntry_DoNotUse::MergeFrom(const db_rolekeyvalue_MDataEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata db_rolekeyvalue_MDataEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[8]);
}

// ===================================================================

class db_rolekeyvalue::_Internal {
 public:
  using HasBits = decltype(std::declval<db_rolekeyvalue>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

db_rolekeyvalue::db_rolekeyvalue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &db_rolekeyvalue::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:pbdb.db_rolekeyvalue)
}
db_rolekeyvalue::db_rolekeyvalue(const db_rolekeyvalue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_rolekeyvalue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_data_)*/{}
    , decltype(_impl_.m_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.m_data_.MergeFrom(from._impl_.m_data_);
  _this->_impl_.m_id_ = from._impl_.m_id_;
  // @@protoc_insertion_point(copy_constructor:pbdb.db_rolekeyvalue)
}

inline void db_rolekeyvalue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_data_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.m_id_){int64_t{0}}
  };
}

db_rolekeyvalue::~db_rolekeyvalue() {
  // @@protoc_insertion_point(destructor:pbdb.db_rolekeyvalue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void db_rolekeyvalue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_data_.Destruct();
  _impl_.m_data_.~MapField();
}

void db_rolekeyvalue::ArenaDtor(void* object) {
  db_rolekeyvalue* _this = reinterpret_cast< db_rolekeyvalue* >(object);
  _this->_impl_.m_data_.Destruct();
}
void db_rolekeyvalue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_rolekeyvalue::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_rolekeyvalue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_data_.Clear();
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_rolekeyvalue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<string, string> m_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.m_data_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_rolekeyvalue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_rolekeyvalue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_id(), target);
  }

  // map<string, string> m_data = 2;
  if (!this->_internal_m_data().empty()) {
    using MapType = ::_pb::Map<std::string, std::string>;
    using WireHelper = db_rolekeyvalue_MDataEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_m_data();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "pbdb.db_rolekeyvalue.MDataEntry.key");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.second.data(), static_cast<int>(entry.second.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "pbdb.db_rolekeyvalue.MDataEntry.value");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_rolekeyvalue)
  return target;
}

size_t db_rolekeyvalue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_rolekeyvalue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, string> m_data = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_m_data_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >::const_iterator
      it = this->_internal_m_data().begin();
      it != this->_internal_m_data().end(); ++it) {
    total_size += db_rolekeyvalue_MDataEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // optional int64 m_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_rolekeyvalue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_rolekeyvalue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_rolekeyvalue::GetClassData() const { return &_class_data_; }


void db_rolekeyvalue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_rolekeyvalue*>(&to_msg);
  auto& from = static_cast<const db_rolekeyvalue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_rolekeyvalue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_data_.MergeFrom(from._impl_.m_data_);
  if (from._internal_has_m_id()) {
    _this->_internal_set_m_id(from._internal_m_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_rolekeyvalue::CopyFrom(const db_rolekeyvalue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_rolekeyvalue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_rolekeyvalue::IsInitialized() const {
  return true;
}

void db_rolekeyvalue::InternalSwap(db_rolekeyvalue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_data_.InternalSwap(&other->_impl_.m_data_);
  swap(_impl_.m_id_, other->_impl_.m_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata db_rolekeyvalue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[9]);
}

// ===================================================================

class mailitem::_Internal {
 public:
  using HasBits = decltype(std::declval<mailitem>()._impl_._has_bits_);
  static void set_has_m_itemtid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

mailitem::mailitem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.mailitem)
}
mailitem::mailitem(const mailitem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  mailitem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_itemtid_){}
    , decltype(_impl_.m_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.m_itemtid_, &from._impl_.m_itemtid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_count_) -
    reinterpret_cast<char*>(&_impl_.m_itemtid_)) + sizeof(_impl_.m_count_));
  // @@protoc_insertion_point(copy_constructor:pbdb.mailitem)
}

inline void mailitem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_itemtid_){0}
    , decltype(_impl_.m_count_){0}
  };
}

mailitem::~mailitem() {
  // @@protoc_insertion_point(destructor:pbdb.mailitem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void mailitem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void mailitem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void mailitem::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.mailitem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.m_itemtid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_count_) -
        reinterpret_cast<char*>(&_impl_.m_itemtid_)) + sizeof(_impl_.m_count_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* mailitem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 m_itemtid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_itemtid(&has_bits);
          _impl_.m_itemtid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_m_count(&has_bits);
          _impl_.m_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* mailitem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.mailitem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 m_itemtid = 1;
  if (_internal_has_m_itemtid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_m_itemtid(), target);
  }

  // optional int32 m_count = 2;
  if (_internal_has_m_count()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_m_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.mailitem)
  return target;
}

size_t mailitem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.mailitem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 m_itemtid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_itemtid());
    }

    // optional int32 m_count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData mailitem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    mailitem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*mailitem::GetClassData() const { return &_class_data_; }


void mailitem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<mailitem*>(&to_msg);
  auto& from = static_cast<const mailitem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.mailitem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m_itemtid_ = from._impl_.m_itemtid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_count_ = from._impl_.m_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void mailitem::CopyFrom(const mailitem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.mailitem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool mailitem::IsInitialized() const {
  return true;
}

void mailitem::InternalSwap(mailitem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(mailitem, _impl_.m_count_)
      + sizeof(mailitem::_impl_.m_count_)
      - PROTOBUF_FIELD_OFFSET(mailitem, _impl_.m_itemtid_)>(
          reinterpret_cast<char*>(&_impl_.m_itemtid_),
          reinterpret_cast<char*>(&other->_impl_.m_itemtid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata mailitem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[10]);
}

// ===================================================================

class mail::_Internal {
 public:
  using HasBits = decltype(std::declval<mail>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_createutc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_m_tid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_m_prams(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_content(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_read(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_m_draw(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

mail::mail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.mail)
}
mail::mail(const mail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  mail* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_items_){from._impl_.m_items_}
    , decltype(_impl_.m_prams_){}
    , decltype(_impl_.m_content_){}
    , decltype(_impl_.m_id_){}
    , decltype(_impl_.m_createutc_){}
    , decltype(_impl_.m_tid_){}
    , decltype(_impl_.m_read_){}
    , decltype(_impl_.m_draw_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.m_prams_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_prams_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_m_prams()) {
    _this->_impl_.m_prams_.Set(from._internal_m_prams(), 
      _this->GetArenaForAllocation());
  }
  _impl_.m_content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_m_content()) {
    _this->_impl_.m_content_.Set(from._internal_m_content(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_draw_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_draw_));
  // @@protoc_insertion_point(copy_constructor:pbdb.mail)
}

inline void mail::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_items_){arena}
    , decltype(_impl_.m_prams_){}
    , decltype(_impl_.m_content_){}
    , decltype(_impl_.m_id_){0}
    , decltype(_impl_.m_createutc_){0}
    , decltype(_impl_.m_tid_){0}
    , decltype(_impl_.m_read_){false}
    , decltype(_impl_.m_draw_){false}
  };
  _impl_.m_prams_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_prams_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.m_content_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_content_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

mail::~mail() {
  // @@protoc_insertion_point(destructor:pbdb.mail)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void mail::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_items_.~RepeatedPtrField();
  _impl_.m_prams_.Destroy();
  _impl_.m_content_.Destroy();
}

void mail::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void mail::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.mail)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_items_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.m_prams_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.m_content_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&_impl_.m_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_draw_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_draw_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* mail::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_createutc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_m_createutc(&has_bits);
          _impl_.m_createutc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_tid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_m_tid(&has_bits);
          _impl_.m_tid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string m_prams = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_m_prams();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.mail.m_prams"));
        } else
          goto handle_unusual;
        continue;
      // optional string m_content = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_m_content();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.mail.m_content"));
        } else
          goto handle_unusual;
        continue;
      // repeated .pbdb.mailitem m_items = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_m_items(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool m_read = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_m_read(&has_bits);
          _impl_.m_read_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool m_draw = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_m_draw(&has_bits);
          _impl_.m_draw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* mail::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.mail)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_m_id(), target);
  }

  // optional int32 m_createutc = 2;
  if (_internal_has_m_createutc()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_m_createutc(), target);
  }

  // optional int32 m_tid = 3;
  if (_internal_has_m_tid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_m_tid(), target);
  }

  // optional string m_prams = 4;
  if (_internal_has_m_prams()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_m_prams().data(), static_cast<int>(this->_internal_m_prams().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pbdb.mail.m_prams");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_m_prams(), target);
  }

  // optional string m_content = 5;
  if (_internal_has_m_content()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_m_content().data(), static_cast<int>(this->_internal_m_content().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pbdb.mail.m_content");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_m_content(), target);
  }

  // repeated .pbdb.mailitem m_items = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_m_items_size()); i < n; i++) {
    const auto& repfield = this->_internal_m_items(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool m_read = 7;
  if (_internal_has_m_read()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(7, this->_internal_m_read(), target);
  }

  // optional bool m_draw = 8;
  if (_internal_has_m_draw()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_m_draw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.mail)
  return target;
}

size_t mail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.mail)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pbdb.mailitem m_items = 6;
  total_size += 1UL * this->_internal_m_items_size();
  for (const auto& msg : this->_impl_.m_items_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string m_prams = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_m_prams());
    }

    // optional string m_content = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_m_content());
    }

    // optional int32 m_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_id());
    }

    // optional int32 m_createutc = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_createutc());
    }

    // optional int32 m_tid = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_tid());
    }

    // optional bool m_read = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool m_draw = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData mail::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    mail::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*mail::GetClassData() const { return &_class_data_; }


void mail::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<mail*>(&to_msg);
  auto& from = static_cast<const mail&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.mail)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_items_.MergeFrom(from._impl_.m_items_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_m_prams(from._internal_m_prams());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_m_content(from._internal_m_content());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_createutc_ = from._impl_.m_createutc_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.m_tid_ = from._impl_.m_tid_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.m_read_ = from._impl_.m_read_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.m_draw_ = from._impl_.m_draw_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void mail::CopyFrom(const mail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.mail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool mail::IsInitialized() const {
  return true;
}

void mail::InternalSwap(mail* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_items_.InternalSwap(&other->_impl_.m_items_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.m_prams_, lhs_arena,
      &other->_impl_.m_prams_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.m_content_, lhs_arena,
      &other->_impl_.m_content_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(mail, _impl_.m_draw_)
      + sizeof(mail::_impl_.m_draw_)
      - PROTOBUF_FIELD_OFFSET(mail, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata mail::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[11]);
}

// ===================================================================

db_mail_MMailEntry_DoNotUse::db_mail_MMailEntry_DoNotUse() {}
db_mail_MMailEntry_DoNotUse::db_mail_MMailEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void db_mail_MMailEntry_DoNotUse::MergeFrom(const db_mail_MMailEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata db_mail_MMailEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[12]);
}

// ===================================================================

class db_mail::_Internal {
 public:
  using HasBits = decltype(std::declval<db_mail>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

db_mail::db_mail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &db_mail::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:pbdb.db_mail)
}
db_mail::db_mail(const db_mail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_mail* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_mail_)*/{}
    , decltype(_impl_.m_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.m_mail_.MergeFrom(from._impl_.m_mail_);
  _this->_impl_.m_id_ = from._impl_.m_id_;
  // @@protoc_insertion_point(copy_constructor:pbdb.db_mail)
}

inline void db_mail::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_mail_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.m_id_){int64_t{0}}
  };
}

db_mail::~db_mail() {
  // @@protoc_insertion_point(destructor:pbdb.db_mail)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void db_mail::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_mail_.Destruct();
  _impl_.m_mail_.~MapField();
}

void db_mail::ArenaDtor(void* object) {
  db_mail* _this = reinterpret_cast< db_mail* >(object);
  _this->_impl_.m_mail_.Destruct();
}
void db_mail::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_mail::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_mail)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_mail_.Clear();
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_mail::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<int32, .pbdb.mail> m_mail = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.m_mail_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_mail::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_mail)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_id(), target);
  }

  // map<int32, .pbdb.mail> m_mail = 2;
  if (!this->_internal_m_mail().empty()) {
    using MapType = ::_pb::Map<int32_t, ::pbdb::mail>;
    using WireHelper = db_mail_MMailEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_m_mail();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_mail)
  return target;
}

size_t db_mail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_mail)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int32, .pbdb.mail> m_mail = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_m_mail_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >::const_iterator
      it = this->_internal_m_mail().begin();
      it != this->_internal_m_mail().end(); ++it) {
    total_size += db_mail_MMailEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // optional int64 m_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_mail::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_mail::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_mail::GetClassData() const { return &_class_data_; }


void db_mail::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_mail*>(&to_msg);
  auto& from = static_cast<const db_mail&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_mail)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_mail_.MergeFrom(from._impl_.m_mail_);
  if (from._internal_has_m_id()) {
    _this->_internal_set_m_id(from._internal_m_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_mail::CopyFrom(const db_mail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_mail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_mail::IsInitialized() const {
  return true;
}

void db_mail::InternalSwap(db_mail* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_mail_.InternalSwap(&other->_impl_.m_mail_);
  swap(_impl_.m_id_, other->_impl_.m_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata db_mail::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[13]);
}

// ===================================================================

class db_guild::_Internal {
 public:
  using HasBits = decltype(std::declval<db_guild>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_guild(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_leader(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

db_guild::db_guild(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_guild)
}
db_guild::db_guild(const db_guild& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_guild* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_members_){from._impl_.m_members_}
    , /*decltype(_impl_._m_members_cached_byte_size_)*/{0}
    , decltype(_impl_.m_guild_){}
    , decltype(_impl_.m_id_){}
    , decltype(_impl_.m_leader_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.m_guild_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_guild_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_m_guild()) {
    _this->_impl_.m_guild_.Set(from._internal_m_guild(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_leader_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_leader_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_guild)
}

inline void db_guild::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_members_){arena}
    , /*decltype(_impl_._m_members_cached_byte_size_)*/{0}
    , decltype(_impl_.m_guild_){}
    , decltype(_impl_.m_id_){int64_t{0}}
    , decltype(_impl_.m_leader_){int64_t{0}}
  };
  _impl_.m_guild_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_guild_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

db_guild::~db_guild() {
  // @@protoc_insertion_point(destructor:pbdb.db_guild)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_guild::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_members_.~RepeatedField();
  _impl_.m_guild_.Destroy();
}

void db_guild::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_guild::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_guild)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_members_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.m_guild_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.m_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_leader_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_leader_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_guild::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string m_guild = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_m_guild();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.db_guild.m_guild"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 m_leader = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_m_leader(&has_bits);
          _impl_.m_leader_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 m_members = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_m_members(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 32) {
          _internal_add_m_members(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_guild::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_guild)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_id(), target);
  }

  // optional string m_guild = 2;
  if (_internal_has_m_guild()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_m_guild().data(), static_cast<int>(this->_internal_m_guild().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pbdb.db_guild.m_guild");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_m_guild(), target);
  }

  // optional int64 m_leader = 3;
  if (_internal_has_m_leader()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_m_leader(), target);
  }

  // repeated int64 m_members = 4;
  {
    int byte_size = _impl_._m_members_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          4, _internal_m_members(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_guild)
  return target;
}

size_t db_guild::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_guild)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 m_members = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.m_members_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._m_members_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string m_guild = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_m_guild());
    }

    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_id());
    }

    // optional int64 m_leader = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_leader());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_guild::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_guild::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_guild::GetClassData() const { return &_class_data_; }


void db_guild::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_guild*>(&to_msg);
  auto& from = static_cast<const db_guild&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_guild)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_members_.MergeFrom(from._impl_.m_members_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_m_guild(from._internal_m_guild());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_leader_ = from._impl_.m_leader_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_guild::CopyFrom(const db_guild& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_guild)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_guild::IsInitialized() const {
  return true;
}

void db_guild::InternalSwap(db_guild* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_members_.InternalSwap(&other->_impl_.m_members_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.m_guild_, lhs_arena,
      &other->_impl_.m_guild_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_guild, _impl_.m_leader_)
      + sizeof(db_guild::_impl_.m_leader_)
      - PROTOBUF_FIELD_OFFSET(db_guild, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_guild::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[14]);
}

// ===================================================================

class db_notice::_Internal {
 public:
  using HasBits = decltype(std::declval<db_notice>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_notice(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_starttime(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_finishtime(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

db_notice::db_notice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_notice)
}
db_notice::db_notice(const db_notice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_notice* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_notice_){}
    , decltype(_impl_.m_id_){}
    , decltype(_impl_.m_starttime_){}
    , decltype(_impl_.m_finishtime_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.m_notice_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_notice_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_m_notice()) {
    _this->_impl_.m_notice_.Set(from._internal_m_notice(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_finishtime_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_finishtime_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_notice)
}

inline void db_notice::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_notice_){}
    , decltype(_impl_.m_id_){int64_t{0}}
    , decltype(_impl_.m_starttime_){0}
    , decltype(_impl_.m_finishtime_){0}
  };
  _impl_.m_notice_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_notice_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

db_notice::~db_notice() {
  // @@protoc_insertion_point(destructor:pbdb.db_notice)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_notice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_notice_.Destroy();
}

void db_notice::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_notice::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_notice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.m_notice_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.m_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_finishtime_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_finishtime_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_notice::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string m_notice = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_m_notice();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.db_notice.m_notice"));
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_starttime = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_m_starttime(&has_bits);
          _impl_.m_starttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_finishtime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_m_finishtime(&has_bits);
          _impl_.m_finishtime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_notice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_notice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_id(), target);
  }

  // optional string m_notice = 2;
  if (_internal_has_m_notice()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_m_notice().data(), static_cast<int>(this->_internal_m_notice().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pbdb.db_notice.m_notice");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_m_notice(), target);
  }

  // optional int32 m_starttime = 3;
  if (_internal_has_m_starttime()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_m_starttime(), target);
  }

  // optional int32 m_finishtime = 4;
  if (_internal_has_m_finishtime()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_m_finishtime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_notice)
  return target;
}

size_t db_notice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_notice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string m_notice = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_m_notice());
    }

    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_id());
    }

    // optional int32 m_starttime = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_starttime());
    }

    // optional int32 m_finishtime = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_finishtime());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_notice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_notice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_notice::GetClassData() const { return &_class_data_; }


void db_notice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_notice*>(&to_msg);
  auto& from = static_cast<const db_notice&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_notice)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_m_notice(from._internal_m_notice());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_starttime_ = from._impl_.m_starttime_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_finishtime_ = from._impl_.m_finishtime_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_notice::CopyFrom(const db_notice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_notice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_notice::IsInitialized() const {
  return true;
}

void db_notice::InternalSwap(db_notice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.m_notice_, lhs_arena,
      &other->_impl_.m_notice_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_notice, _impl_.m_finishtime_)
      + sizeof(db_notice::_impl_.m_finishtime_)
      - PROTOBUF_FIELD_OFFSET(db_notice, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_notice::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[15]);
}

// ===================================================================

class rankitem::_Internal {
 public:
  using HasBits = decltype(std::declval<rankitem>()._impl_._has_bits_);
  static void set_has_m_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

rankitem::rankitem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.rankitem)
}
rankitem::rankitem(const rankitem& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  rankitem* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_value_){}
    , decltype(_impl_.m_time_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.m_value_, &from._impl_.m_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_time_) -
    reinterpret_cast<char*>(&_impl_.m_value_)) + sizeof(_impl_.m_time_));
  // @@protoc_insertion_point(copy_constructor:pbdb.rankitem)
}

inline void rankitem::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_value_){int64_t{0}}
    , decltype(_impl_.m_time_){0}
  };
}

rankitem::~rankitem() {
  // @@protoc_insertion_point(destructor:pbdb.rankitem)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void rankitem::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void rankitem::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void rankitem::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.rankitem)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.m_value_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_time_) -
        reinterpret_cast<char*>(&_impl_.m_value_)) + sizeof(_impl_.m_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* rankitem::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_value(&has_bits);
          _impl_.m_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_m_time(&has_bits);
          _impl_.m_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* rankitem::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.rankitem)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_value = 1;
  if (_internal_has_m_value()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_value(), target);
  }

  // optional int32 m_time = 2;
  if (_internal_has_m_time()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_m_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.rankitem)
  return target;
}

size_t rankitem::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.rankitem)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int64 m_value = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_value());
    }

    // optional int32 m_time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData rankitem::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    rankitem::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*rankitem::GetClassData() const { return &_class_data_; }


void rankitem::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<rankitem*>(&to_msg);
  auto& from = static_cast<const rankitem&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.rankitem)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m_value_ = from._impl_.m_value_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_time_ = from._impl_.m_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void rankitem::CopyFrom(const rankitem& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.rankitem)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool rankitem::IsInitialized() const {
  return true;
}

void rankitem::InternalSwap(rankitem* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(rankitem, _impl_.m_time_)
      + sizeof(rankitem::_impl_.m_time_)
      - PROTOBUF_FIELD_OFFSET(rankitem, _impl_.m_value_)>(
          reinterpret_cast<char*>(&_impl_.m_value_),
          reinterpret_cast<char*>(&other->_impl_.m_value_));
}

::PROTOBUF_NAMESPACE_ID::Metadata rankitem::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[16]);
}

// ===================================================================

db_ranklist_MItemsEntry_DoNotUse::db_ranklist_MItemsEntry_DoNotUse() {}
db_ranklist_MItemsEntry_DoNotUse::db_ranklist_MItemsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void db_ranklist_MItemsEntry_DoNotUse::MergeFrom(const db_ranklist_MItemsEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata db_ranklist_MItemsEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[17]);
}

// ===================================================================

class db_ranklist::_Internal {
 public:
  using HasBits = decltype(std::declval<db_ranklist>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

db_ranklist::db_ranklist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &db_ranklist::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:pbdb.db_ranklist)
}
db_ranklist::db_ranklist(const db_ranklist& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_ranklist* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_items_)*/{}
    , decltype(_impl_.m_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.m_items_.MergeFrom(from._impl_.m_items_);
  _this->_impl_.m_id_ = from._impl_.m_id_;
  // @@protoc_insertion_point(copy_constructor:pbdb.db_ranklist)
}

inline void db_ranklist::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_items_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.m_id_){int64_t{0}}
  };
}

db_ranklist::~db_ranklist() {
  // @@protoc_insertion_point(destructor:pbdb.db_ranklist)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void db_ranklist::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_items_.Destruct();
  _impl_.m_items_.~MapField();
}

void db_ranklist::ArenaDtor(void* object) {
  db_ranklist* _this = reinterpret_cast< db_ranklist* >(object);
  _this->_impl_.m_items_.Destruct();
}
void db_ranklist::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_ranklist::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_ranklist)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_items_.Clear();
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_ranklist::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<int32, .pbdb.rankitem> m_items = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.m_items_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_ranklist::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_ranklist)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_id(), target);
  }

  // map<int32, .pbdb.rankitem> m_items = 2;
  if (!this->_internal_m_items().empty()) {
    using MapType = ::_pb::Map<int32_t, ::pbdb::rankitem>;
    using WireHelper = db_ranklist_MItemsEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_m_items();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_ranklist)
  return target;
}

size_t db_ranklist::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_ranklist)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int32, .pbdb.rankitem> m_items = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_m_items_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >::const_iterator
      it = this->_internal_m_items().begin();
      it != this->_internal_m_items().end(); ++it) {
    total_size += db_ranklist_MItemsEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // optional int64 m_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_ranklist::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_ranklist::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_ranklist::GetClassData() const { return &_class_data_; }


void db_ranklist::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_ranklist*>(&to_msg);
  auto& from = static_cast<const db_ranklist&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_ranklist)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_items_.MergeFrom(from._impl_.m_items_);
  if (from._internal_has_m_id()) {
    _this->_internal_set_m_id(from._internal_m_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_ranklist::CopyFrom(const db_ranklist& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_ranklist)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_ranklist::IsInitialized() const {
  return true;
}

void db_ranklist::InternalSwap(db_ranklist* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_items_.InternalSwap(&other->_impl_.m_items_);
  swap(_impl_.m_id_, other->_impl_.m_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata db_ranklist::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[18]);
}

// ===================================================================

db_activity_drawcompliance_MRewardEntry_DoNotUse::db_activity_drawcompliance_MRewardEntry_DoNotUse() {}
db_activity_drawcompliance_MRewardEntry_DoNotUse::db_activity_drawcompliance_MRewardEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void db_activity_drawcompliance_MRewardEntry_DoNotUse::MergeFrom(const db_activity_drawcompliance_MRewardEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata db_activity_drawcompliance_MRewardEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[19]);
}

// ===================================================================

class db_activity_drawcompliance::_Internal {
 public:
  using HasBits = decltype(std::declval<db_activity_drawcompliance>()._impl_._has_bits_);
  static void set_has_m_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

db_activity_drawcompliance::db_activity_drawcompliance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &db_activity_drawcompliance::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:pbdb.db_activity.drawcompliance)
}
db_activity_drawcompliance::db_activity_drawcompliance(const db_activity_drawcompliance& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_activity_drawcompliance* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_reward_)*/{}
    , decltype(_impl_.m_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.m_reward_.MergeFrom(from._impl_.m_reward_);
  _this->_impl_.m_count_ = from._impl_.m_count_;
  // @@protoc_insertion_point(copy_constructor:pbdb.db_activity.drawcompliance)
}

inline void db_activity_drawcompliance::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_reward_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.m_count_){0}
  };
}

db_activity_drawcompliance::~db_activity_drawcompliance() {
  // @@protoc_insertion_point(destructor:pbdb.db_activity.drawcompliance)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void db_activity_drawcompliance::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_reward_.Destruct();
  _impl_.m_reward_.~MapField();
}

void db_activity_drawcompliance::ArenaDtor(void* object) {
  db_activity_drawcompliance* _this = reinterpret_cast< db_activity_drawcompliance* >(object);
  _this->_impl_.m_reward_.Destruct();
}
void db_activity_drawcompliance::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_activity_drawcompliance::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_activity.drawcompliance)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_reward_.Clear();
  _impl_.m_count_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_activity_drawcompliance::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 m_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_count(&has_bits);
          _impl_.m_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<int32, bool> m_reward = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.m_reward_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_activity_drawcompliance::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_activity.drawcompliance)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 m_count = 1;
  if (_internal_has_m_count()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_m_count(), target);
  }

  // map<int32, bool> m_reward = 2;
  if (!this->_internal_m_reward().empty()) {
    using MapType = ::_pb::Map<int32_t, bool>;
    using WireHelper = db_activity_drawcompliance_MRewardEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_m_reward();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_activity.drawcompliance)
  return target;
}

size_t db_activity_drawcompliance::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_activity.drawcompliance)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int32, bool> m_reward = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_m_reward_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >::const_iterator
      it = this->_internal_m_reward().begin();
      it != this->_internal_m_reward().end(); ++it) {
    total_size += db_activity_drawcompliance_MRewardEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // optional int32 m_count = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_activity_drawcompliance::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_activity_drawcompliance::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_activity_drawcompliance::GetClassData() const { return &_class_data_; }


void db_activity_drawcompliance::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_activity_drawcompliance*>(&to_msg);
  auto& from = static_cast<const db_activity_drawcompliance&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_activity.drawcompliance)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_reward_.MergeFrom(from._impl_.m_reward_);
  if (from._internal_has_m_count()) {
    _this->_internal_set_m_count(from._internal_m_count());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_activity_drawcompliance::CopyFrom(const db_activity_drawcompliance& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_activity.drawcompliance)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_activity_drawcompliance::IsInitialized() const {
  return true;
}

void db_activity_drawcompliance::InternalSwap(db_activity_drawcompliance* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_reward_.InternalSwap(&other->_impl_.m_reward_);
  swap(_impl_.m_count_, other->_impl_.m_count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata db_activity_drawcompliance::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[20]);
}

// ===================================================================

db_activity_MDrawcomplianceEntry_DoNotUse::db_activity_MDrawcomplianceEntry_DoNotUse() {}
db_activity_MDrawcomplianceEntry_DoNotUse::db_activity_MDrawcomplianceEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void db_activity_MDrawcomplianceEntry_DoNotUse::MergeFrom(const db_activity_MDrawcomplianceEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata db_activity_MDrawcomplianceEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[21]);
}

// ===================================================================

class db_activity::_Internal {
 public:
  using HasBits = decltype(std::declval<db_activity>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_beg(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_end(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_start(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_m_finish(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_m_calendarid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

db_activity::db_activity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &db_activity::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:pbdb.db_activity)
}
db_activity::db_activity(const db_activity& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_activity* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_drawcompliance_)*/{}
    , decltype(_impl_.m_id_){}
    , decltype(_impl_.m_beg_){}
    , decltype(_impl_.m_end_){}
    , decltype(_impl_.m_start_){}
    , decltype(_impl_.m_finish_){}
    , decltype(_impl_.m_calendarid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.m_drawcompliance_.MergeFrom(from._impl_.m_drawcompliance_);
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_calendarid_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_calendarid_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_activity)
}

inline void db_activity::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_drawcompliance_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.m_id_){int64_t{0}}
    , decltype(_impl_.m_beg_){0}
    , decltype(_impl_.m_end_){0}
    , decltype(_impl_.m_start_){false}
    , decltype(_impl_.m_finish_){false}
    , decltype(_impl_.m_calendarid_){0}
  };
}

db_activity::~db_activity() {
  // @@protoc_insertion_point(destructor:pbdb.db_activity)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void db_activity::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_drawcompliance_.Destruct();
  _impl_.m_drawcompliance_.~MapField();
}

void db_activity::ArenaDtor(void* object) {
  db_activity* _this = reinterpret_cast< db_activity* >(object);
  _this->_impl_.m_drawcompliance_.Destruct();
}
void db_activity::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_activity::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_activity)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_drawcompliance_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&_impl_.m_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_calendarid_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_calendarid_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_activity::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_beg = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_m_beg(&has_bits);
          _impl_.m_beg_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_end = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_m_end(&has_bits);
          _impl_.m_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool m_start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_m_start(&has_bits);
          _impl_.m_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool m_finish = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_m_finish(&has_bits);
          _impl_.m_finish_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_calendarid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_m_calendarid(&has_bits);
          _impl_.m_calendarid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<int64, .pbdb.db_activity.drawcompliance> m_drawcompliance = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.m_drawcompliance_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_activity::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_activity)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_id(), target);
  }

  // optional int32 m_beg = 2;
  if (_internal_has_m_beg()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_m_beg(), target);
  }

  // optional int32 m_end = 3;
  if (_internal_has_m_end()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_m_end(), target);
  }

  // optional bool m_start = 4;
  if (_internal_has_m_start()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_m_start(), target);
  }

  // optional bool m_finish = 5;
  if (_internal_has_m_finish()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_m_finish(), target);
  }

  // optional int32 m_calendarid = 6;
  if (_internal_has_m_calendarid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_m_calendarid(), target);
  }

  // map<int64, .pbdb.db_activity.drawcompliance> m_drawcompliance = 7;
  if (!this->_internal_m_drawcompliance().empty()) {
    using MapType = ::_pb::Map<int64_t, ::pbdb::db_activity_drawcompliance>;
    using WireHelper = db_activity_MDrawcomplianceEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_m_drawcompliance();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(7, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_activity)
  return target;
}

size_t db_activity::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_activity)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int64, .pbdb.db_activity.drawcompliance> m_drawcompliance = 7;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_m_drawcompliance_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::db_activity_drawcompliance >::const_iterator
      it = this->_internal_m_drawcompliance().begin();
      it != this->_internal_m_drawcompliance().end(); ++it) {
    total_size += db_activity_MDrawcomplianceEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_id());
    }

    // optional int32 m_beg = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_beg());
    }

    // optional int32 m_end = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_end());
    }

    // optional bool m_start = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool m_finish = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional int32 m_calendarid = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_calendarid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_activity::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_activity::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_activity::GetClassData() const { return &_class_data_; }


void db_activity::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_activity*>(&to_msg);
  auto& from = static_cast<const db_activity&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_activity)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_drawcompliance_.MergeFrom(from._impl_.m_drawcompliance_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_beg_ = from._impl_.m_beg_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_end_ = from._impl_.m_end_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_start_ = from._impl_.m_start_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.m_finish_ = from._impl_.m_finish_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.m_calendarid_ = from._impl_.m_calendarid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_activity::CopyFrom(const db_activity& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_activity)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_activity::IsInitialized() const {
  return true;
}

void db_activity::InternalSwap(db_activity* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_drawcompliance_.InternalSwap(&other->_impl_.m_drawcompliance_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_activity, _impl_.m_calendarid_)
      + sizeof(db_activity::_impl_.m_calendarid_)
      - PROTOBUF_FIELD_OFFSET(db_activity, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_activity::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[22]);
}

// ===================================================================

class db_task_data_schedule::_Internal {
 public:
  using HasBits = decltype(std::declval<db_task_data_schedule>()._impl_._has_bits_);
  static void set_has_m_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_sumint(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

db_task_data_schedule::db_task_data_schedule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_task.data_schedule)
}
db_task_data_schedule::db_task_data_schedule(const db_task_data_schedule& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_task_data_schedule* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_type_){}
    , decltype(_impl_.m_value_){}
    , decltype(_impl_.m_sumint_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.m_type_, &from._impl_.m_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_sumint_) -
    reinterpret_cast<char*>(&_impl_.m_type_)) + sizeof(_impl_.m_sumint_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_task.data_schedule)
}

inline void db_task_data_schedule::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_type_){0}
    , decltype(_impl_.m_value_){0}
    , decltype(_impl_.m_sumint_){0}
  };
}

db_task_data_schedule::~db_task_data_schedule() {
  // @@protoc_insertion_point(destructor:pbdb.db_task.data_schedule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_task_data_schedule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void db_task_data_schedule::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_task_data_schedule::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_task.data_schedule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.m_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_sumint_) -
        reinterpret_cast<char*>(&_impl_.m_type_)) + sizeof(_impl_.m_sumint_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_task_data_schedule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 m_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_type(&has_bits);
          _impl_.m_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_m_value(&has_bits);
          _impl_.m_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_sumint = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_m_sumint(&has_bits);
          _impl_.m_sumint_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_task_data_schedule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_task.data_schedule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 m_type = 1;
  if (_internal_has_m_type()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_m_type(), target);
  }

  // optional int32 m_value = 2;
  if (_internal_has_m_value()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_m_value(), target);
  }

  // optional int32 m_sumint = 3;
  if (_internal_has_m_sumint()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_m_sumint(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_task.data_schedule)
  return target;
}

size_t db_task_data_schedule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_task.data_schedule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 m_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_type());
    }

    // optional int32 m_value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_value());
    }

    // optional int32 m_sumint = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_sumint());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_task_data_schedule::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_task_data_schedule::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_task_data_schedule::GetClassData() const { return &_class_data_; }


void db_task_data_schedule::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_task_data_schedule*>(&to_msg);
  auto& from = static_cast<const db_task_data_schedule&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_task.data_schedule)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m_type_ = from._impl_.m_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_value_ = from._impl_.m_value_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_sumint_ = from._impl_.m_sumint_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_task_data_schedule::CopyFrom(const db_task_data_schedule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_task.data_schedule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_task_data_schedule::IsInitialized() const {
  return true;
}

void db_task_data_schedule::InternalSwap(db_task_data_schedule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_task_data_schedule, _impl_.m_sumint_)
      + sizeof(db_task_data_schedule::_impl_.m_sumint_)
      - PROTOBUF_FIELD_OFFSET(db_task_data_schedule, _impl_.m_type_)>(
          reinterpret_cast<char*>(&_impl_.m_type_),
          reinterpret_cast<char*>(&other->_impl_.m_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_task_data_schedule::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[23]);
}

// ===================================================================

class db_task_data::_Internal {
 public:
  using HasBits = decltype(std::declval<db_task_data>()._impl_._has_bits_);
  static void set_has_m_taskid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_receiveutc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_finshutc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_receive(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

db_task_data::db_task_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_task.data)
}
db_task_data::db_task_data(const db_task_data& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_task_data* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_schedules_){from._impl_.m_schedules_}
    , decltype(_impl_.m_taskid_){}
    , decltype(_impl_.m_receiveutc_){}
    , decltype(_impl_.m_finshutc_){}
    , decltype(_impl_.m_receive_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.m_taskid_, &from._impl_.m_taskid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_receive_) -
    reinterpret_cast<char*>(&_impl_.m_taskid_)) + sizeof(_impl_.m_receive_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_task.data)
}

inline void db_task_data::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_schedules_){arena}
    , decltype(_impl_.m_taskid_){0}
    , decltype(_impl_.m_receiveutc_){0}
    , decltype(_impl_.m_finshutc_){0}
    , decltype(_impl_.m_receive_){false}
  };
}

db_task_data::~db_task_data() {
  // @@protoc_insertion_point(destructor:pbdb.db_task.data)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_task_data::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_schedules_.~RepeatedPtrField();
}

void db_task_data::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_task_data::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_task.data)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_schedules_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.m_taskid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_receive_) -
        reinterpret_cast<char*>(&_impl_.m_taskid_)) + sizeof(_impl_.m_receive_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_task_data::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 m_taskid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_taskid(&has_bits);
          _impl_.m_taskid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_receiveutc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_m_receiveutc(&has_bits);
          _impl_.m_receiveutc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_finshutc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_m_finshutc(&has_bits);
          _impl_.m_finshutc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .pbdb.db_task.data_schedule m_schedules = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_m_schedules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool m_receive = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_m_receive(&has_bits);
          _impl_.m_receive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_task_data::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_task.data)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int32 m_taskid = 1;
  if (_internal_has_m_taskid()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_m_taskid(), target);
  }

  // optional int32 m_receiveutc = 2;
  if (_internal_has_m_receiveutc()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_m_receiveutc(), target);
  }

  // optional int32 m_finshutc = 3;
  if (_internal_has_m_finshutc()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_m_finshutc(), target);
  }

  // repeated .pbdb.db_task.data_schedule m_schedules = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_m_schedules_size()); i < n; i++) {
    const auto& repfield = this->_internal_m_schedules(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional bool m_receive = 5;
  if (_internal_has_m_receive()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_m_receive(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_task.data)
  return target;
}

size_t db_task_data::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_task.data)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .pbdb.db_task.data_schedule m_schedules = 4;
  total_size += 1UL * this->_internal_m_schedules_size();
  for (const auto& msg : this->_impl_.m_schedules_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 m_taskid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_taskid());
    }

    // optional int32 m_receiveutc = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_receiveutc());
    }

    // optional int32 m_finshutc = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_finshutc());
    }

    // optional bool m_receive = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_task_data::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_task_data::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_task_data::GetClassData() const { return &_class_data_; }


void db_task_data::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_task_data*>(&to_msg);
  auto& from = static_cast<const db_task_data&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_task.data)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_schedules_.MergeFrom(from._impl_.m_schedules_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m_taskid_ = from._impl_.m_taskid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_receiveutc_ = from._impl_.m_receiveutc_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_finshutc_ = from._impl_.m_finshutc_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_receive_ = from._impl_.m_receive_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_task_data::CopyFrom(const db_task_data& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_task.data)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_task_data::IsInitialized() const {
  return true;
}

void db_task_data::InternalSwap(db_task_data* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_schedules_.InternalSwap(&other->_impl_.m_schedules_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_task_data, _impl_.m_receive_)
      + sizeof(db_task_data::_impl_.m_receive_)
      - PROTOBUF_FIELD_OFFSET(db_task_data, _impl_.m_taskid_)>(
          reinterpret_cast<char*>(&_impl_.m_taskid_),
          reinterpret_cast<char*>(&other->_impl_.m_taskid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_task_data::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[24]);
}

// ===================================================================

db_task_MRundatasEntry_DoNotUse::db_task_MRundatasEntry_DoNotUse() {}
db_task_MRundatasEntry_DoNotUse::db_task_MRundatasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void db_task_MRundatasEntry_DoNotUse::MergeFrom(const db_task_MRundatasEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata db_task_MRundatasEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[25]);
}

// ===================================================================

db_task_MCompleteddatasEntry_DoNotUse::db_task_MCompleteddatasEntry_DoNotUse() {}
db_task_MCompleteddatasEntry_DoNotUse::db_task_MCompleteddatasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void db_task_MCompleteddatasEntry_DoNotUse::MergeFrom(const db_task_MCompleteddatasEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata db_task_MCompleteddatasEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[26]);
}

// ===================================================================

class db_task::_Internal {
 public:
  using HasBits = decltype(std::declval<db_task>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

db_task::db_task(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &db_task::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:pbdb.db_task)
}
db_task::db_task(const db_task& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_task* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_rundatas_)*/{}
    , /*decltype(_impl_.m_completeddatas_)*/{}
    , decltype(_impl_.m_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.m_rundatas_.MergeFrom(from._impl_.m_rundatas_);
  _this->_impl_.m_completeddatas_.MergeFrom(from._impl_.m_completeddatas_);
  _this->_impl_.m_id_ = from._impl_.m_id_;
  // @@protoc_insertion_point(copy_constructor:pbdb.db_task)
}

inline void db_task::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_.m_rundatas_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_.m_completeddatas_)*/{::_pbi::ArenaInitialized(), arena}
    , decltype(_impl_.m_id_){int64_t{0}}
  };
}

db_task::~db_task() {
  // @@protoc_insertion_point(destructor:pbdb.db_task)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void db_task::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_rundatas_.Destruct();
  _impl_.m_rundatas_.~MapField();
  _impl_.m_completeddatas_.Destruct();
  _impl_.m_completeddatas_.~MapField();
}

void db_task::ArenaDtor(void* object) {
  db_task* _this = reinterpret_cast< db_task* >(object);
  _this->_impl_.m_rundatas_.Destruct();
  _this->_impl_.m_completeddatas_.Destruct();
}
void db_task::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_task::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_task)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_rundatas_.Clear();
  _impl_.m_completeddatas_.Clear();
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_task::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // map<int32, .pbdb.db_task.data> m_rundatas = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.m_rundatas_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // map<int32, .pbdb.db_task.data> m_completeddatas = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.m_completeddatas_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_task::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_task)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_id(), target);
  }

  // map<int32, .pbdb.db_task.data> m_rundatas = 2;
  if (!this->_internal_m_rundatas().empty()) {
    using MapType = ::_pb::Map<int32_t, ::pbdb::db_task_data>;
    using WireHelper = db_task_MRundatasEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_m_rundatas();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(2, entry.first, entry.second, target, stream);
      }
    }
  }

  // map<int32, .pbdb.db_task.data> m_completeddatas = 3;
  if (!this->_internal_m_completeddatas().empty()) {
    using MapType = ::_pb::Map<int32_t, ::pbdb::db_task_data>;
    using WireHelper = db_task_MCompleteddatasEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_m_completeddatas();

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterFlat<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(3, entry.first, entry.second, target, stream);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_task)
  return target;
}

size_t db_task::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_task)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<int32, .pbdb.db_task.data> m_rundatas = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_m_rundatas_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >::const_iterator
      it = this->_internal_m_rundatas().begin();
      it != this->_internal_m_rundatas().end(); ++it) {
    total_size += db_task_MRundatasEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // map<int32, .pbdb.db_task.data> m_completeddatas = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_m_completeddatas_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >::const_iterator
      it = this->_internal_m_completeddatas().begin();
      it != this->_internal_m_completeddatas().end(); ++it) {
    total_size += db_task_MCompleteddatasEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  // optional int64 m_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_task::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_task::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_task::GetClassData() const { return &_class_data_; }


void db_task::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_task*>(&to_msg);
  auto& from = static_cast<const db_task&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_task)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_rundatas_.MergeFrom(from._impl_.m_rundatas_);
  _this->_impl_.m_completeddatas_.MergeFrom(from._impl_.m_completeddatas_);
  if (from._internal_has_m_id()) {
    _this->_internal_set_m_id(from._internal_m_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_task::CopyFrom(const db_task& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_task)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_task::IsInitialized() const {
  return true;
}

void db_task::InternalSwap(db_task* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_rundatas_.InternalSwap(&other->_impl_.m_rundatas_);
  _impl_.m_completeddatas_.InternalSwap(&other->_impl_.m_completeddatas_);
  swap(_impl_.m_id_, other->_impl_.m_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata db_task::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[27]);
}

// ===================================================================

class db_calendar::_Internal {
 public:
  using HasBits = decltype(std::declval<db_calendar>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_start(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_finish(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

db_calendar::db_calendar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_calendar)
}
db_calendar::db_calendar(const db_calendar& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_calendar* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_id_){}
    , decltype(_impl_.m_time_){}
    , decltype(_impl_.m_start_){}
    , decltype(_impl_.m_finish_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_finish_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_finish_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_calendar)
}

inline void db_calendar::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_id_){int64_t{0}}
    , decltype(_impl_.m_time_){int64_t{0}}
    , decltype(_impl_.m_start_){false}
    , decltype(_impl_.m_finish_){false}
  };
}

db_calendar::~db_calendar() {
  // @@protoc_insertion_point(destructor:pbdb.db_calendar)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_calendar::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void db_calendar::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_calendar::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_calendar)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.m_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_finish_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_finish_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_calendar::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 m_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_m_time(&has_bits);
          _impl_.m_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool m_start = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_m_start(&has_bits);
          _impl_.m_start_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool m_finish = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_m_finish(&has_bits);
          _impl_.m_finish_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_calendar::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_calendar)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_id(), target);
  }

  // optional int64 m_time = 2;
  if (_internal_has_m_time()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(2, this->_internal_m_time(), target);
  }

  // optional bool m_start = 3;
  if (_internal_has_m_start()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_m_start(), target);
  }

  // optional bool m_finish = 4;
  if (_internal_has_m_finish()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_m_finish(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_calendar)
  return target;
}

size_t db_calendar::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_calendar)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_id());
    }

    // optional int64 m_time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_time());
    }

    // optional bool m_start = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool m_finish = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_calendar::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_calendar::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_calendar::GetClassData() const { return &_class_data_; }


void db_calendar::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_calendar*>(&to_msg);
  auto& from = static_cast<const db_calendar&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_calendar)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_time_ = from._impl_.m_time_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_start_ = from._impl_.m_start_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_finish_ = from._impl_.m_finish_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_calendar::CopyFrom(const db_calendar& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_calendar)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_calendar::IsInitialized() const {
  return true;
}

void db_calendar::InternalSwap(db_calendar* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_calendar, _impl_.m_finish_)
      + sizeof(db_calendar::_impl_.m_finish_)
      - PROTOBUF_FIELD_OFFSET(db_calendar, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_calendar::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[28]);
}

// ===================================================================

class db_familyer::_Internal {
 public:
  using HasBits = decltype(std::declval<db_familyer>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_joinutc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_lastsignutc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_lastleaveutc(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_m_position(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

db_familyer::db_familyer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_familyer)
}
db_familyer::db_familyer(const db_familyer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_familyer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_id_){}
    , decltype(_impl_.m_joinutc_){}
    , decltype(_impl_.m_lastsignutc_){}
    , decltype(_impl_.m_lastleaveutc_){}
    , decltype(_impl_.m_position_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_position_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_position_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_familyer)
}

inline void db_familyer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_id_){int64_t{0}}
    , decltype(_impl_.m_joinutc_){0}
    , decltype(_impl_.m_lastsignutc_){0}
    , decltype(_impl_.m_lastleaveutc_){0}
    , decltype(_impl_.m_position_){0}
  };
}

db_familyer::~db_familyer() {
  // @@protoc_insertion_point(destructor:pbdb.db_familyer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_familyer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void db_familyer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_familyer::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_familyer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.m_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_position_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_position_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_familyer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_joinutc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_m_joinutc(&has_bits);
          _impl_.m_joinutc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_lastsignutc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_m_lastsignutc(&has_bits);
          _impl_.m_lastsignutc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_lastleaveutc = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_m_lastleaveutc(&has_bits);
          _impl_.m_lastleaveutc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .pbdb.db_familyer.eposition m_position = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_m_position(static_cast<::pbdb::db_familyer_eposition>(val));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_familyer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_familyer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_id(), target);
  }

  // optional int32 m_joinutc = 2;
  if (_internal_has_m_joinutc()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_m_joinutc(), target);
  }

  // optional int32 m_lastsignutc = 3;
  if (_internal_has_m_lastsignutc()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_m_lastsignutc(), target);
  }

  // optional int32 m_lastleaveutc = 4;
  if (_internal_has_m_lastleaveutc()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_m_lastleaveutc(), target);
  }

  // optional .pbdb.db_familyer.eposition m_position = 5;
  if (_internal_has_m_position()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      5, this->_internal_m_position(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_familyer)
  return target;
}

size_t db_familyer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_familyer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_id());
    }

    // optional int32 m_joinutc = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_joinutc());
    }

    // optional int32 m_lastsignutc = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_lastsignutc());
    }

    // optional int32 m_lastleaveutc = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_lastleaveutc());
    }

    // optional .pbdb.db_familyer.eposition m_position = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_m_position());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_familyer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_familyer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_familyer::GetClassData() const { return &_class_data_; }


void db_familyer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_familyer*>(&to_msg);
  auto& from = static_cast<const db_familyer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_familyer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_joinutc_ = from._impl_.m_joinutc_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_lastsignutc_ = from._impl_.m_lastsignutc_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_lastleaveutc_ = from._impl_.m_lastleaveutc_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.m_position_ = from._impl_.m_position_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_familyer::CopyFrom(const db_familyer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_familyer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_familyer::IsInitialized() const {
  return true;
}

void db_familyer::InternalSwap(db_familyer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_familyer, _impl_.m_position_)
      + sizeof(db_familyer::_impl_.m_position_)
      - PROTOBUF_FIELD_OFFSET(db_familyer, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_familyer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[29]);
}

// ===================================================================

class db_family::_Internal {
 public:
  using HasBits = decltype(std::declval<db_family>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_m_createutc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_m_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_m_leader(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_m_lv(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_m_exp(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

db_family::db_family(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_family)
}
db_family::db_family(const db_family& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_family* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_member_){from._impl_.m_member_}
    , /*decltype(_impl_._m_member_cached_byte_size_)*/{0}
    , decltype(_impl_.m_applylist_){from._impl_.m_applylist_}
    , /*decltype(_impl_._m_applylist_cached_byte_size_)*/{0}
    , decltype(_impl_.m_name_){}
    , decltype(_impl_.m_id_){}
    , decltype(_impl_.m_createutc_){}
    , decltype(_impl_.m_lv_){}
    , decltype(_impl_.m_leader_){}
    , decltype(_impl_.m_exp_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.m_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_m_name()) {
    _this->_impl_.m_name_.Set(from._internal_m_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.m_id_, &from._impl_.m_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.m_exp_) -
    reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_exp_));
  // @@protoc_insertion_point(copy_constructor:pbdb.db_family)
}

inline void db_family::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_member_){arena}
    , /*decltype(_impl_._m_member_cached_byte_size_)*/{0}
    , decltype(_impl_.m_applylist_){arena}
    , /*decltype(_impl_._m_applylist_cached_byte_size_)*/{0}
    , decltype(_impl_.m_name_){}
    , decltype(_impl_.m_id_){int64_t{0}}
    , decltype(_impl_.m_createutc_){0}
    , decltype(_impl_.m_lv_){0}
    , decltype(_impl_.m_leader_){int64_t{0}}
    , decltype(_impl_.m_exp_){0}
  };
  _impl_.m_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.m_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

db_family::~db_family() {
  // @@protoc_insertion_point(destructor:pbdb.db_family)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_family::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_member_.~RepeatedField();
  _impl_.m_applylist_.~RepeatedField();
  _impl_.m_name_.Destroy();
}

void db_family::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_family::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_family)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_member_.Clear();
  _impl_.m_applylist_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.m_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.m_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.m_exp_) -
        reinterpret_cast<char*>(&_impl_.m_id_)) + sizeof(_impl_.m_exp_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_family::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_createutc = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_m_createutc(&has_bits);
          _impl_.m_createutc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string m_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_m_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "pbdb.db_family.m_name"));
        } else
          goto handle_unusual;
        continue;
      // optional int64 m_leader = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_m_leader(&has_bits);
          _impl_.m_leader_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_lv = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_m_lv(&has_bits);
          _impl_.m_lv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 m_exp = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_m_exp(&has_bits);
          _impl_.m_exp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 m_member = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_m_member(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 56) {
          _internal_add_m_member(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 m_applylist = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_m_applylist(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 64) {
          _internal_add_m_applylist(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_family::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_family)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_id(), target);
  }

  // optional int32 m_createutc = 2;
  if (_internal_has_m_createutc()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_m_createutc(), target);
  }

  // optional string m_name = 3;
  if (_internal_has_m_name()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_m_name().data(), static_cast<int>(this->_internal_m_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "pbdb.db_family.m_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_m_name(), target);
  }

  // optional int64 m_leader = 4;
  if (_internal_has_m_leader()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_m_leader(), target);
  }

  // optional int32 m_lv = 5;
  if (_internal_has_m_lv()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_m_lv(), target);
  }

  // optional int32 m_exp = 6;
  if (_internal_has_m_exp()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_m_exp(), target);
  }

  // repeated int64 m_member = 7;
  {
    int byte_size = _impl_._m_member_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          7, _internal_m_member(), byte_size, target);
    }
  }

  // repeated int64 m_applylist = 8;
  {
    int byte_size = _impl_._m_applylist_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          8, _internal_m_applylist(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_family)
  return target;
}

size_t db_family::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_family)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 m_member = 7;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.m_member_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._m_member_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 m_applylist = 8;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.m_applylist_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._m_applylist_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string m_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_m_name());
    }

    // optional int64 m_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_id());
    }

    // optional int32 m_createutc = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_createutc());
    }

    // optional int32 m_lv = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_lv());
    }

    // optional int64 m_leader = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_leader());
    }

    // optional int32 m_exp = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_m_exp());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_family::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_family::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_family::GetClassData() const { return &_class_data_; }


void db_family::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_family*>(&to_msg);
  auto& from = static_cast<const db_family&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_family)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_member_.MergeFrom(from._impl_.m_member_);
  _this->_impl_.m_applylist_.MergeFrom(from._impl_.m_applylist_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_m_name(from._internal_m_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.m_id_ = from._impl_.m_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.m_createutc_ = from._impl_.m_createutc_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.m_lv_ = from._impl_.m_lv_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.m_leader_ = from._impl_.m_leader_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.m_exp_ = from._impl_.m_exp_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_family::CopyFrom(const db_family& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_family)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_family::IsInitialized() const {
  return true;
}

void db_family::InternalSwap(db_family* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_member_.InternalSwap(&other->_impl_.m_member_);
  _impl_.m_applylist_.InternalSwap(&other->_impl_.m_applylist_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.m_name_, lhs_arena,
      &other->_impl_.m_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(db_family, _impl_.m_exp_)
      + sizeof(db_family::_impl_.m_exp_)
      - PROTOBUF_FIELD_OFFSET(db_family, _impl_.m_id_)>(
          reinterpret_cast<char*>(&_impl_.m_id_),
          reinterpret_cast<char*>(&other->_impl_.m_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata db_family::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[30]);
}

// ===================================================================

class db_friends::_Internal {
 public:
  using HasBits = decltype(std::declval<db_friends>()._impl_._has_bits_);
  static void set_has_m_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

db_friends::db_friends(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:pbdb.db_friends)
}
db_friends::db_friends(const db_friends& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  db_friends* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_friends_){from._impl_.m_friends_}
    , /*decltype(_impl_._m_friends_cached_byte_size_)*/{0}
    , decltype(_impl_.m_applyfriends_){from._impl_.m_applyfriends_}
    , /*decltype(_impl_._m_applyfriends_cached_byte_size_)*/{0}
    , decltype(_impl_.m_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.m_id_ = from._impl_.m_id_;
  // @@protoc_insertion_point(copy_constructor:pbdb.db_friends)
}

inline void db_friends::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.m_friends_){arena}
    , /*decltype(_impl_._m_friends_cached_byte_size_)*/{0}
    , decltype(_impl_.m_applyfriends_){arena}
    , /*decltype(_impl_._m_applyfriends_cached_byte_size_)*/{0}
    , decltype(_impl_.m_id_){int64_t{0}}
  };
}

db_friends::~db_friends() {
  // @@protoc_insertion_point(destructor:pbdb.db_friends)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void db_friends::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.m_friends_.~RepeatedField();
  _impl_.m_applyfriends_.~RepeatedField();
}

void db_friends::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void db_friends::Clear() {
// @@protoc_insertion_point(message_clear_start:pbdb.db_friends)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.m_friends_.Clear();
  _impl_.m_applyfriends_.Clear();
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* db_friends::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int64 m_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_m_id(&has_bits);
          _impl_.m_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 m_friends = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_m_friends(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 16) {
          _internal_add_m_friends(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 m_applyfriends = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_m_applyfriends(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 24) {
          _internal_add_m_applyfriends(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* db_friends::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:pbdb.db_friends)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // optional int64 m_id = 1;
  if (_internal_has_m_id()) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(1, this->_internal_m_id(), target);
  }

  // repeated int64 m_friends = 2;
  {
    int byte_size = _impl_._m_friends_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          2, _internal_m_friends(), byte_size, target);
    }
  }

  // repeated int64 m_applyfriends = 3;
  {
    int byte_size = _impl_._m_applyfriends_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt64Packed(
          3, _internal_m_applyfriends(), byte_size, target);
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:pbdb.db_friends)
  return target;
}

size_t db_friends::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:pbdb.db_friends)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int64 m_friends = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.m_friends_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._m_friends_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // repeated int64 m_applyfriends = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.m_applyfriends_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._m_applyfriends_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  // optional int64 m_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_m_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData db_friends::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    db_friends::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*db_friends::GetClassData() const { return &_class_data_; }


void db_friends::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<db_friends*>(&to_msg);
  auto& from = static_cast<const db_friends&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:pbdb.db_friends)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.m_friends_.MergeFrom(from._impl_.m_friends_);
  _this->_impl_.m_applyfriends_.MergeFrom(from._impl_.m_applyfriends_);
  if (from._internal_has_m_id()) {
    _this->_internal_set_m_id(from._internal_m_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void db_friends::CopyFrom(const db_friends& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:pbdb.db_friends)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool db_friends::IsInitialized() const {
  return true;
}

void db_friends::InternalSwap(db_friends* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.m_friends_.InternalSwap(&other->_impl_.m_friends_);
  _impl_.m_applyfriends_.InternalSwap(&other->_impl_.m_applyfriends_);
  swap(_impl_.m_id_, other->_impl_.m_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata db_friends::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_db_2eproto_getter, &descriptor_table_db_2eproto_once,
      file_level_metadata_db_2eproto[31]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace pbdb
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::pbdb::db_account*
Arena::CreateMaybeMessage< ::pbdb::db_account >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_account >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_brief*
Arena::CreateMaybeMessage< ::pbdb::db_brief >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_brief >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_role_recharge*
Arena::CreateMaybeMessage< ::pbdb::db_role_recharge >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_role_recharge >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_role*
Arena::CreateMaybeMessage< ::pbdb::db_role >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_role >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::item*
Arena::CreateMaybeMessage< ::pbdb::item >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::item >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_bag_MItemsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::pbdb::db_bag_MItemsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_bag_MItemsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_bag*
Arena::CreateMaybeMessage< ::pbdb::db_bag >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_bag >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_keyvalue*
Arena::CreateMaybeMessage< ::pbdb::db_keyvalue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_keyvalue >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_rolekeyvalue_MDataEntry_DoNotUse*
Arena::CreateMaybeMessage< ::pbdb::db_rolekeyvalue_MDataEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_rolekeyvalue_MDataEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_rolekeyvalue*
Arena::CreateMaybeMessage< ::pbdb::db_rolekeyvalue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_rolekeyvalue >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::mailitem*
Arena::CreateMaybeMessage< ::pbdb::mailitem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::mailitem >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::mail*
Arena::CreateMaybeMessage< ::pbdb::mail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::mail >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_mail_MMailEntry_DoNotUse*
Arena::CreateMaybeMessage< ::pbdb::db_mail_MMailEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_mail_MMailEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_mail*
Arena::CreateMaybeMessage< ::pbdb::db_mail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_mail >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_guild*
Arena::CreateMaybeMessage< ::pbdb::db_guild >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_guild >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_notice*
Arena::CreateMaybeMessage< ::pbdb::db_notice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_notice >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::rankitem*
Arena::CreateMaybeMessage< ::pbdb::rankitem >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::rankitem >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_ranklist_MItemsEntry_DoNotUse*
Arena::CreateMaybeMessage< ::pbdb::db_ranklist_MItemsEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_ranklist_MItemsEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_ranklist*
Arena::CreateMaybeMessage< ::pbdb::db_ranklist >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_ranklist >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_activity_drawcompliance_MRewardEntry_DoNotUse*
Arena::CreateMaybeMessage< ::pbdb::db_activity_drawcompliance_MRewardEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_activity_drawcompliance_MRewardEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_activity_drawcompliance*
Arena::CreateMaybeMessage< ::pbdb::db_activity_drawcompliance >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_activity_drawcompliance >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_activity_MDrawcomplianceEntry_DoNotUse*
Arena::CreateMaybeMessage< ::pbdb::db_activity_MDrawcomplianceEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_activity_MDrawcomplianceEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_activity*
Arena::CreateMaybeMessage< ::pbdb::db_activity >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_activity >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_task_data_schedule*
Arena::CreateMaybeMessage< ::pbdb::db_task_data_schedule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_task_data_schedule >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_task_data*
Arena::CreateMaybeMessage< ::pbdb::db_task_data >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_task_data >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_task_MRundatasEntry_DoNotUse*
Arena::CreateMaybeMessage< ::pbdb::db_task_MRundatasEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_task_MRundatasEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_task_MCompleteddatasEntry_DoNotUse*
Arena::CreateMaybeMessage< ::pbdb::db_task_MCompleteddatasEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_task_MCompleteddatasEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_task*
Arena::CreateMaybeMessage< ::pbdb::db_task >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_task >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_calendar*
Arena::CreateMaybeMessage< ::pbdb::db_calendar >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_calendar >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_familyer*
Arena::CreateMaybeMessage< ::pbdb::db_familyer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_familyer >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_family*
Arena::CreateMaybeMessage< ::pbdb::db_family >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_family >(arena);
}
template<> PROTOBUF_NOINLINE ::pbdb::db_friends*
Arena::CreateMaybeMessage< ::pbdb::db_friends >(Arena* arena) {
  return Arena::CreateMessageInternal< ::pbdb::db_friends >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
