// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: db.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_db_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_db_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_db_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_db_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_db_2eproto;
namespace pbdb {
class db_account;
struct db_accountDefaultTypeInternal;
extern db_accountDefaultTypeInternal _db_account_default_instance_;
class db_activity;
struct db_activityDefaultTypeInternal;
extern db_activityDefaultTypeInternal _db_activity_default_instance_;
class db_activity_MDrawcomplianceEntry_DoNotUse;
struct db_activity_MDrawcomplianceEntry_DoNotUseDefaultTypeInternal;
extern db_activity_MDrawcomplianceEntry_DoNotUseDefaultTypeInternal _db_activity_MDrawcomplianceEntry_DoNotUse_default_instance_;
class db_activity_drawcompliance;
struct db_activity_drawcomplianceDefaultTypeInternal;
extern db_activity_drawcomplianceDefaultTypeInternal _db_activity_drawcompliance_default_instance_;
class db_activity_drawcompliance_MRewardEntry_DoNotUse;
struct db_activity_drawcompliance_MRewardEntry_DoNotUseDefaultTypeInternal;
extern db_activity_drawcompliance_MRewardEntry_DoNotUseDefaultTypeInternal _db_activity_drawcompliance_MRewardEntry_DoNotUse_default_instance_;
class db_bag;
struct db_bagDefaultTypeInternal;
extern db_bagDefaultTypeInternal _db_bag_default_instance_;
class db_bag_MItemsEntry_DoNotUse;
struct db_bag_MItemsEntry_DoNotUseDefaultTypeInternal;
extern db_bag_MItemsEntry_DoNotUseDefaultTypeInternal _db_bag_MItemsEntry_DoNotUse_default_instance_;
class db_brief;
struct db_briefDefaultTypeInternal;
extern db_briefDefaultTypeInternal _db_brief_default_instance_;
class db_calendar;
struct db_calendarDefaultTypeInternal;
extern db_calendarDefaultTypeInternal _db_calendar_default_instance_;
class db_family;
struct db_familyDefaultTypeInternal;
extern db_familyDefaultTypeInternal _db_family_default_instance_;
class db_familyer;
struct db_familyerDefaultTypeInternal;
extern db_familyerDefaultTypeInternal _db_familyer_default_instance_;
class db_friends;
struct db_friendsDefaultTypeInternal;
extern db_friendsDefaultTypeInternal _db_friends_default_instance_;
class db_guild;
struct db_guildDefaultTypeInternal;
extern db_guildDefaultTypeInternal _db_guild_default_instance_;
class db_keyvalue;
struct db_keyvalueDefaultTypeInternal;
extern db_keyvalueDefaultTypeInternal _db_keyvalue_default_instance_;
class db_mail;
struct db_mailDefaultTypeInternal;
extern db_mailDefaultTypeInternal _db_mail_default_instance_;
class db_mail_MMailEntry_DoNotUse;
struct db_mail_MMailEntry_DoNotUseDefaultTypeInternal;
extern db_mail_MMailEntry_DoNotUseDefaultTypeInternal _db_mail_MMailEntry_DoNotUse_default_instance_;
class db_notice;
struct db_noticeDefaultTypeInternal;
extern db_noticeDefaultTypeInternal _db_notice_default_instance_;
class db_ranklist;
struct db_ranklistDefaultTypeInternal;
extern db_ranklistDefaultTypeInternal _db_ranklist_default_instance_;
class db_ranklist_MItemsEntry_DoNotUse;
struct db_ranklist_MItemsEntry_DoNotUseDefaultTypeInternal;
extern db_ranklist_MItemsEntry_DoNotUseDefaultTypeInternal _db_ranklist_MItemsEntry_DoNotUse_default_instance_;
class db_role;
struct db_roleDefaultTypeInternal;
extern db_roleDefaultTypeInternal _db_role_default_instance_;
class db_role_recharge;
struct db_role_rechargeDefaultTypeInternal;
extern db_role_rechargeDefaultTypeInternal _db_role_recharge_default_instance_;
class db_rolekeyvalue;
struct db_rolekeyvalueDefaultTypeInternal;
extern db_rolekeyvalueDefaultTypeInternal _db_rolekeyvalue_default_instance_;
class db_rolekeyvalue_MDataEntry_DoNotUse;
struct db_rolekeyvalue_MDataEntry_DoNotUseDefaultTypeInternal;
extern db_rolekeyvalue_MDataEntry_DoNotUseDefaultTypeInternal _db_rolekeyvalue_MDataEntry_DoNotUse_default_instance_;
class db_task;
struct db_taskDefaultTypeInternal;
extern db_taskDefaultTypeInternal _db_task_default_instance_;
class db_task_MCompleteddatasEntry_DoNotUse;
struct db_task_MCompleteddatasEntry_DoNotUseDefaultTypeInternal;
extern db_task_MCompleteddatasEntry_DoNotUseDefaultTypeInternal _db_task_MCompleteddatasEntry_DoNotUse_default_instance_;
class db_task_MRundatasEntry_DoNotUse;
struct db_task_MRundatasEntry_DoNotUseDefaultTypeInternal;
extern db_task_MRundatasEntry_DoNotUseDefaultTypeInternal _db_task_MRundatasEntry_DoNotUse_default_instance_;
class db_task_data;
struct db_task_dataDefaultTypeInternal;
extern db_task_dataDefaultTypeInternal _db_task_data_default_instance_;
class db_task_data_schedule;
struct db_task_data_scheduleDefaultTypeInternal;
extern db_task_data_scheduleDefaultTypeInternal _db_task_data_schedule_default_instance_;
class item;
struct itemDefaultTypeInternal;
extern itemDefaultTypeInternal _item_default_instance_;
class mail;
struct mailDefaultTypeInternal;
extern mailDefaultTypeInternal _mail_default_instance_;
class mailitem;
struct mailitemDefaultTypeInternal;
extern mailitemDefaultTypeInternal _mailitem_default_instance_;
class rankitem;
struct rankitemDefaultTypeInternal;
extern rankitemDefaultTypeInternal _rankitem_default_instance_;
}  // namespace pbdb
PROTOBUF_NAMESPACE_OPEN
template<> ::pbdb::db_account* Arena::CreateMaybeMessage<::pbdb::db_account>(Arena*);
template<> ::pbdb::db_activity* Arena::CreateMaybeMessage<::pbdb::db_activity>(Arena*);
template<> ::pbdb::db_activity_MDrawcomplianceEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_activity_MDrawcomplianceEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_activity_drawcompliance* Arena::CreateMaybeMessage<::pbdb::db_activity_drawcompliance>(Arena*);
template<> ::pbdb::db_activity_drawcompliance_MRewardEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_activity_drawcompliance_MRewardEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_bag* Arena::CreateMaybeMessage<::pbdb::db_bag>(Arena*);
template<> ::pbdb::db_bag_MItemsEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_bag_MItemsEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_brief* Arena::CreateMaybeMessage<::pbdb::db_brief>(Arena*);
template<> ::pbdb::db_calendar* Arena::CreateMaybeMessage<::pbdb::db_calendar>(Arena*);
template<> ::pbdb::db_family* Arena::CreateMaybeMessage<::pbdb::db_family>(Arena*);
template<> ::pbdb::db_familyer* Arena::CreateMaybeMessage<::pbdb::db_familyer>(Arena*);
template<> ::pbdb::db_friends* Arena::CreateMaybeMessage<::pbdb::db_friends>(Arena*);
template<> ::pbdb::db_guild* Arena::CreateMaybeMessage<::pbdb::db_guild>(Arena*);
template<> ::pbdb::db_keyvalue* Arena::CreateMaybeMessage<::pbdb::db_keyvalue>(Arena*);
template<> ::pbdb::db_mail* Arena::CreateMaybeMessage<::pbdb::db_mail>(Arena*);
template<> ::pbdb::db_mail_MMailEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_mail_MMailEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_notice* Arena::CreateMaybeMessage<::pbdb::db_notice>(Arena*);
template<> ::pbdb::db_ranklist* Arena::CreateMaybeMessage<::pbdb::db_ranklist>(Arena*);
template<> ::pbdb::db_ranklist_MItemsEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_ranklist_MItemsEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_role* Arena::CreateMaybeMessage<::pbdb::db_role>(Arena*);
template<> ::pbdb::db_role_recharge* Arena::CreateMaybeMessage<::pbdb::db_role_recharge>(Arena*);
template<> ::pbdb::db_rolekeyvalue* Arena::CreateMaybeMessage<::pbdb::db_rolekeyvalue>(Arena*);
template<> ::pbdb::db_rolekeyvalue_MDataEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_rolekeyvalue_MDataEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_task* Arena::CreateMaybeMessage<::pbdb::db_task>(Arena*);
template<> ::pbdb::db_task_MCompleteddatasEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_task_MCompleteddatasEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_task_MRundatasEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_task_MRundatasEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_task_data* Arena::CreateMaybeMessage<::pbdb::db_task_data>(Arena*);
template<> ::pbdb::db_task_data_schedule* Arena::CreateMaybeMessage<::pbdb::db_task_data_schedule>(Arena*);
template<> ::pbdb::item* Arena::CreateMaybeMessage<::pbdb::item>(Arena*);
template<> ::pbdb::mail* Arena::CreateMaybeMessage<::pbdb::mail>(Arena*);
template<> ::pbdb::mailitem* Arena::CreateMaybeMessage<::pbdb::mailitem>(Arena*);
template<> ::pbdb::rankitem* Arena::CreateMaybeMessage<::pbdb::rankitem>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pbdb {

enum db_keyvalue_ekv : int {
  db_keyvalue_ekv_none = 0,
  db_keyvalue_ekv_account_ban = 1,
  db_keyvalue_ekv_db_keyvalue_ekv_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  db_keyvalue_ekv_db_keyvalue_ekv_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool db_keyvalue_ekv_IsValid(int value);
constexpr db_keyvalue_ekv db_keyvalue_ekv_ekv_MIN = db_keyvalue_ekv_none;
constexpr db_keyvalue_ekv db_keyvalue_ekv_ekv_MAX = db_keyvalue_ekv_account_ban;
constexpr int db_keyvalue_ekv_ekv_ARRAYSIZE = db_keyvalue_ekv_ekv_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* db_keyvalue_ekv_descriptor();
template<typename T>
inline const std::string& db_keyvalue_ekv_Name(T enum_t_value) {
  static_assert(::std::is_same<T, db_keyvalue_ekv>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function db_keyvalue_ekv_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    db_keyvalue_ekv_descriptor(), enum_t_value);
}
inline bool db_keyvalue_ekv_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, db_keyvalue_ekv* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<db_keyvalue_ekv>(
    db_keyvalue_ekv_descriptor(), name, value);
}
enum db_familyer_eposition : int {
  db_familyer_eposition_none = 0,
  db_familyer_eposition_leader = 1,
  db_familyer_eposition_counsellor = 2,
  db_familyer_eposition_ordinary = 3,
  db_familyer_eposition_db_familyer_eposition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  db_familyer_eposition_db_familyer_eposition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool db_familyer_eposition_IsValid(int value);
constexpr db_familyer_eposition db_familyer_eposition_eposition_MIN = db_familyer_eposition_none;
constexpr db_familyer_eposition db_familyer_eposition_eposition_MAX = db_familyer_eposition_ordinary;
constexpr int db_familyer_eposition_eposition_ARRAYSIZE = db_familyer_eposition_eposition_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* db_familyer_eposition_descriptor();
template<typename T>
inline const std::string& db_familyer_eposition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, db_familyer_eposition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function db_familyer_eposition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    db_familyer_eposition_descriptor(), enum_t_value);
}
inline bool db_familyer_eposition_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, db_familyer_eposition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<db_familyer_eposition>(
    db_familyer_eposition_descriptor(), name, value);
}
enum ENUM_DB : int {
  ENUM_DB_ACCOUNT = 0,
  ENUM_DB_ROLE = 1,
  ENUM_DB_BRIEF = 2,
  ENUM_DB_BAG = 3,
  ENUM_DB_KEYVALUE = 4,
  ENUM_DB_MAIL = 5,
  ENUM_DB_GUILD = 6,
  ENUM_DB_NOTICE = 7,
  ENUM_DB_RANKLIST = 8,
  ENUM_DB_ACTIVITY = 9,
  ENUM_DB_TASK = 10,
  ENUM_DB_CALENDAR = 11,
  ENUM_DB_ROLEKEYVALUE = 12,
  ENUM_DB_FAMILY = 13,
  ENUM_DB_FAMILYER = 14,
  ENUM_DB_FRIENDS = 15,
  ENUM_DB_COUNT = 16,
  ENUM_DB_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ENUM_DB_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ENUM_DB_IsValid(int value);
constexpr ENUM_DB ENUM_DB_MIN = ENUM_DB_ACCOUNT;
constexpr ENUM_DB ENUM_DB_MAX = ENUM_DB_COUNT;
constexpr int ENUM_DB_ARRAYSIZE = ENUM_DB_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ENUM_DB_descriptor();
template<typename T>
inline const std::string& ENUM_DB_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ENUM_DB>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ENUM_DB_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ENUM_DB_descriptor(), enum_t_value);
}
inline bool ENUM_DB_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ENUM_DB* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ENUM_DB>(
    ENUM_DB_descriptor(), name, value);
}
enum eranklist : int {
  lv = 0,
  count = 1,
  eranklist_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  eranklist_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool eranklist_IsValid(int value);
constexpr eranklist eranklist_MIN = lv;
constexpr eranklist eranklist_MAX = count;
constexpr int eranklist_ARRAYSIZE = eranklist_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* eranklist_descriptor();
template<typename T>
inline const std::string& eranklist_Name(T enum_t_value) {
  static_assert(::std::is_same<T, eranklist>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function eranklist_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    eranklist_descriptor(), enum_t_value);
}
inline bool eranklist_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, eranklist* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<eranklist>(
    eranklist_descriptor(), name, value);
}
// ===================================================================

class db_account final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_account) */ {
 public:
  inline db_account() : db_account(nullptr) {}
  ~db_account() override;
  explicit PROTOBUF_CONSTEXPR db_account(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_account(const db_account& from);
  db_account(db_account&& from) noexcept
    : db_account() {
    *this = ::std::move(from);
  }

  inline db_account& operator=(const db_account& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_account& operator=(db_account&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_account& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_account* internal_default_instance() {
    return reinterpret_cast<const db_account*>(
               &_db_account_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(db_account& a, db_account& b) {
    a.Swap(&b);
  }
  inline void Swap(db_account* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_account* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_account* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_account>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_account& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_account& from) {
    db_account::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_account* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_account";
  }
  protected:
  explicit db_account(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMAccountFieldNumber = 3,
    kMPassworldFieldNumber = 4,
    kMIdFieldNumber = 1,
    kMRoleidFieldNumber = 2,
    kMAreaFieldNumber = 5,
  };
  // optional string m_account = 3;
  bool has_m_account() const;
  private:
  bool _internal_has_m_account() const;
  public:
  void clear_m_account();
  const std::string& m_account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_account();
  PROTOBUF_NODISCARD std::string* release_m_account();
  void set_allocated_m_account(std::string* m_account);
  private:
  const std::string& _internal_m_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_account(const std::string& value);
  std::string* _internal_mutable_m_account();
  public:

  // optional string m_passworld = 4;
  bool has_m_passworld() const;
  private:
  bool _internal_has_m_passworld() const;
  public:
  void clear_m_passworld();
  const std::string& m_passworld() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_passworld(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_passworld();
  PROTOBUF_NODISCARD std::string* release_m_passworld();
  void set_allocated_m_passworld(std::string* m_passworld);
  private:
  const std::string& _internal_m_passworld() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_passworld(const std::string& value);
  std::string* _internal_mutable_m_passworld();
  public:

  // optional int64 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int64_t m_id() const;
  void set_m_id(int64_t value);
  private:
  int64_t _internal_m_id() const;
  void _internal_set_m_id(int64_t value);
  public:

  // optional int64 m_roleid = 2;
  bool has_m_roleid() const;
  private:
  bool _internal_has_m_roleid() const;
  public:
  void clear_m_roleid();
  int64_t m_roleid() const;
  void set_m_roleid(int64_t value);
  private:
  int64_t _internal_m_roleid() const;
  void _internal_set_m_roleid(int64_t value);
  public:

  // optional int32 m_area = 5;
  bool has_m_area() const;
  private:
  bool _internal_has_m_area() const;
  public:
  void clear_m_area();
  int32_t m_area() const;
  void set_m_area(int32_t value);
  private:
  int32_t _internal_m_area() const;
  void _internal_set_m_area(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_account)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_account_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_passworld_;
    int64_t m_id_;
    int64_t m_roleid_;
    int32_t m_area_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_brief final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_brief) */ {
 public:
  inline db_brief() : db_brief(nullptr) {}
  ~db_brief() override;
  explicit PROTOBUF_CONSTEXPR db_brief(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_brief(const db_brief& from);
  db_brief(db_brief&& from) noexcept
    : db_brief() {
    *this = ::std::move(from);
  }

  inline db_brief& operator=(const db_brief& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_brief& operator=(db_brief&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_brief& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_brief* internal_default_instance() {
    return reinterpret_cast<const db_brief*>(
               &_db_brief_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(db_brief& a, db_brief& b) {
    a.Swap(&b);
  }
  inline void Swap(db_brief* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_brief* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_brief* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_brief>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_brief& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_brief& from) {
    db_brief::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_brief* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_brief";
  }
  protected:
  explicit db_brief(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMNameFieldNumber = 2,
    kMIdFieldNumber = 1,
    kMLvFieldNumber = 3,
    kMMoneygoldFieldNumber = 4,
    kMMoneysilverFieldNumber = 5,
    kMVipFieldNumber = 6,
    kMNotalkutcFieldNumber = 7,
    kMCreateutcFieldNumber = 8,
  };
  // optional string m_name = 2;
  bool has_m_name() const;
  private:
  bool _internal_has_m_name() const;
  public:
  void clear_m_name();
  const std::string& m_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_name();
  PROTOBUF_NODISCARD std::string* release_m_name();
  void set_allocated_m_name(std::string* m_name);
  private:
  const std::string& _internal_m_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_name(const std::string& value);
  std::string* _internal_mutable_m_name();
  public:

  // optional int64 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int64_t m_id() const;
  void set_m_id(int64_t value);
  private:
  int64_t _internal_m_id() const;
  void _internal_set_m_id(int64_t value);
  public:

  // optional int32 m_lv = 3;
  bool has_m_lv() const;
  private:
  bool _internal_has_m_lv() const;
  public:
  void clear_m_lv();
  int32_t m_lv() const;
  void set_m_lv(int32_t value);
  private:
  int32_t _internal_m_lv() const;
  void _internal_set_m_lv(int32_t value);
  public:

  // optional int32 m_moneygold = 4;
  bool has_m_moneygold() const;
  private:
  bool _internal_has_m_moneygold() const;
  public:
  void clear_m_moneygold();
  int32_t m_moneygold() const;
  void set_m_moneygold(int32_t value);
  private:
  int32_t _internal_m_moneygold() const;
  void _internal_set_m_moneygold(int32_t value);
  public:

  // optional int32 m_moneysilver = 5;
  bool has_m_moneysilver() const;
  private:
  bool _internal_has_m_moneysilver() const;
  public:
  void clear_m_moneysilver();
  int32_t m_moneysilver() const;
  void set_m_moneysilver(int32_t value);
  private:
  int32_t _internal_m_moneysilver() const;
  void _internal_set_m_moneysilver(int32_t value);
  public:

  // optional int32 m_vip = 6;
  bool has_m_vip() const;
  private:
  bool _internal_has_m_vip() const;
  public:
  void clear_m_vip();
  int32_t m_vip() const;
  void set_m_vip(int32_t value);
  private:
  int32_t _internal_m_vip() const;
  void _internal_set_m_vip(int32_t value);
  public:

  // optional int32 m_notalkutc = 7;
  bool has_m_notalkutc() const;
  private:
  bool _internal_has_m_notalkutc() const;
  public:
  void clear_m_notalkutc();
  int32_t m_notalkutc() const;
  void set_m_notalkutc(int32_t value);
  private:
  int32_t _internal_m_notalkutc() const;
  void _internal_set_m_notalkutc(int32_t value);
  public:

  // optional int32 m_createutc = 8;
  bool has_m_createutc() const;
  private:
  bool _internal_has_m_createutc() const;
  public:
  void clear_m_createutc();
  int32_t m_createutc() const;
  void set_m_createutc(int32_t value);
  private:
  int32_t _internal_m_createutc() const;
  void _internal_set_m_createutc(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_brief)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_name_;
    int64_t m_id_;
    int32_t m_lv_;
    int32_t m_moneygold_;
    int32_t m_moneysilver_;
    int32_t m_vip_;
    int32_t m_notalkutc_;
    int32_t m_createutc_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_role_recharge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_role.recharge) */ {
 public:
  inline db_role_recharge() : db_role_recharge(nullptr) {}
  ~db_role_recharge() override;
  explicit PROTOBUF_CONSTEXPR db_role_recharge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_role_recharge(const db_role_recharge& from);
  db_role_recharge(db_role_recharge&& from) noexcept
    : db_role_recharge() {
    *this = ::std::move(from);
  }

  inline db_role_recharge& operator=(const db_role_recharge& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_role_recharge& operator=(db_role_recharge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_role_recharge& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_role_recharge* internal_default_instance() {
    return reinterpret_cast<const db_role_recharge*>(
               &_db_role_recharge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(db_role_recharge& a, db_role_recharge& b) {
    a.Swap(&b);
  }
  inline void Swap(db_role_recharge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_role_recharge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_role_recharge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_role_recharge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_role_recharge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_role_recharge& from) {
    db_role_recharge::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_role_recharge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_role.recharge";
  }
  protected:
  explicit db_role_recharge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMRechargeidFieldNumber = 1,
    kMUtcFieldNumber = 2,
  };
  // optional int32 m_rechargeid = 1;
  bool has_m_rechargeid() const;
  private:
  bool _internal_has_m_rechargeid() const;
  public:
  void clear_m_rechargeid();
  int32_t m_rechargeid() const;
  void set_m_rechargeid(int32_t value);
  private:
  int32_t _internal_m_rechargeid() const;
  void _internal_set_m_rechargeid(int32_t value);
  public:

  // optional int32 m_utc = 2;
  bool has_m_utc() const;
  private:
  bool _internal_has_m_utc() const;
  public:
  void clear_m_utc();
  int32_t m_utc() const;
  void set_m_utc(int32_t value);
  private:
  int32_t _internal_m_utc() const;
  void _internal_set_m_utc(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_role.recharge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t m_rechargeid_;
    int32_t m_utc_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_role final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_role) */ {
 public:
  inline db_role() : db_role(nullptr) {}
  ~db_role() override;
  explicit PROTOBUF_CONSTEXPR db_role(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_role(const db_role& from);
  db_role(db_role&& from) noexcept
    : db_role() {
    *this = ::std::move(from);
  }

  inline db_role& operator=(const db_role& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_role& operator=(db_role&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_role& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_role* internal_default_instance() {
    return reinterpret_cast<const db_role*>(
               &_db_role_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(db_role& a, db_role& b) {
    a.Swap(&b);
  }
  inline void Swap(db_role* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_role* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_role* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_role>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_role& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_role& from) {
    db_role::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_role* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_role";
  }
  protected:
  explicit db_role(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef db_role_recharge recharge;

  // accessors -------------------------------------------------------

  enum : int {
    kMRechargeFieldNumber = 3,
    kMBaseFieldNumber = 2,
    kMIdFieldNumber = 1,
  };
  // repeated .pbdb.db_role.recharge m_recharge = 3;
  int m_recharge_size() const;
  private:
  int _internal_m_recharge_size() const;
  public:
  void clear_m_recharge();
  ::pbdb::db_role_recharge* mutable_m_recharge(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_role_recharge >*
      mutable_m_recharge();
  private:
  const ::pbdb::db_role_recharge& _internal_m_recharge(int index) const;
  ::pbdb::db_role_recharge* _internal_add_m_recharge();
  public:
  const ::pbdb::db_role_recharge& m_recharge(int index) const;
  ::pbdb::db_role_recharge* add_m_recharge();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_role_recharge >&
      m_recharge() const;

  // optional .pbdb.db_brief m_base = 2;
  bool has_m_base() const;
  private:
  bool _internal_has_m_base() const;
  public:
  void clear_m_base();
  const ::pbdb::db_brief& m_base() const;
  PROTOBUF_NODISCARD ::pbdb::db_brief* release_m_base();
  ::pbdb::db_brief* mutable_m_base();
  void set_allocated_m_base(::pbdb::db_brief* m_base);
  private:
  const ::pbdb::db_brief& _internal_m_base() const;
  ::pbdb::db_brief* _internal_mutable_m_base();
  public:
  void unsafe_arena_set_allocated_m_base(
      ::pbdb::db_brief* m_base);
  ::pbdb::db_brief* unsafe_arena_release_m_base();

  // optional int64 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int64_t m_id() const;
  void set_m_id(int64_t value);
  private:
  int64_t _internal_m_id() const;
  void _internal_set_m_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_role)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_role_recharge > m_recharge_;
    ::pbdb::db_brief* m_base_;
    int64_t m_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.item) */ {
 public:
  inline item() : item(nullptr) {}
  ~item() override;
  explicit PROTOBUF_CONSTEXPR item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  item(const item& from);
  item(item&& from) noexcept
    : item() {
    *this = ::std::move(from);
  }

  inline item& operator=(const item& from) {
    CopyFrom(from);
    return *this;
  }
  inline item& operator=(item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const item& default_instance() {
    return *internal_default_instance();
  }
  static inline const item* internal_default_instance() {
    return reinterpret_cast<const item*>(
               &_item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(item& a, item& b) {
    a.Swap(&b);
  }
  inline void Swap(item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const item& from) {
    item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.item";
  }
  protected:
  explicit item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMIdFieldNumber = 1,
    kMTidFieldNumber = 2,
    kMCountFieldNumber = 3,
    kMLvFieldNumber = 4,
    kMStarFieldNumber = 5,
  };
  // optional int32 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int32_t m_id() const;
  void set_m_id(int32_t value);
  private:
  int32_t _internal_m_id() const;
  void _internal_set_m_id(int32_t value);
  public:

  // optional int32 m_tid = 2;
  bool has_m_tid() const;
  private:
  bool _internal_has_m_tid() const;
  public:
  void clear_m_tid();
  int32_t m_tid() const;
  void set_m_tid(int32_t value);
  private:
  int32_t _internal_m_tid() const;
  void _internal_set_m_tid(int32_t value);
  public:

  // optional int32 m_count = 3;
  bool has_m_count() const;
  private:
  bool _internal_has_m_count() const;
  public:
  void clear_m_count();
  int32_t m_count() const;
  void set_m_count(int32_t value);
  private:
  int32_t _internal_m_count() const;
  void _internal_set_m_count(int32_t value);
  public:

  // optional int32 m_lv = 4;
  bool has_m_lv() const;
  private:
  bool _internal_has_m_lv() const;
  public:
  void clear_m_lv();
  int32_t m_lv() const;
  void set_m_lv(int32_t value);
  private:
  int32_t _internal_m_lv() const;
  void _internal_set_m_lv(int32_t value);
  public:

  // optional int32 m_star = 5;
  bool has_m_star() const;
  private:
  bool _internal_has_m_star() const;
  public:
  void clear_m_star();
  int32_t m_star() const;
  void set_m_star(int32_t value);
  private:
  int32_t _internal_m_star() const;
  void _internal_set_m_star(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t m_id_;
    int32_t m_tid_;
    int32_t m_count_;
    int32_t m_lv_;
    int32_t m_star_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_bag_MItemsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_bag_MItemsEntry_DoNotUse, 
    int32_t, ::pbdb::item,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_bag_MItemsEntry_DoNotUse, 
    int32_t, ::pbdb::item,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  db_bag_MItemsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_bag_MItemsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_bag_MItemsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_bag_MItemsEntry_DoNotUse& other);
  static const db_bag_MItemsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_bag_MItemsEntry_DoNotUse*>(&_db_bag_MItemsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_bag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_bag) */ {
 public:
  inline db_bag() : db_bag(nullptr) {}
  ~db_bag() override;
  explicit PROTOBUF_CONSTEXPR db_bag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_bag(const db_bag& from);
  db_bag(db_bag&& from) noexcept
    : db_bag() {
    *this = ::std::move(from);
  }

  inline db_bag& operator=(const db_bag& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_bag& operator=(db_bag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_bag& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_bag* internal_default_instance() {
    return reinterpret_cast<const db_bag*>(
               &_db_bag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(db_bag& a, db_bag& b) {
    a.Swap(&b);
  }
  inline void Swap(db_bag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_bag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_bag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_bag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_bag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_bag& from) {
    db_bag::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_bag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_bag";
  }
  protected:
  explicit db_bag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMItemsFieldNumber = 2,
    kMIdFieldNumber = 1,
    kMMaxidFieldNumber = 3,
  };
  // map<int32, .pbdb.item> m_items = 2;
  int m_items_size() const;
  private:
  int _internal_m_items_size() const;
  public:
  void clear_m_items();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >&
      _internal_m_items() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >*
      _internal_mutable_m_items();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >&
      m_items() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >*
      mutable_m_items();

  // optional int64 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int64_t m_id() const;
  void set_m_id(int64_t value);
  private:
  int64_t _internal_m_id() const;
  void _internal_set_m_id(int64_t value);
  public:

  // optional int32 m_maxid = 3;
  bool has_m_maxid() const;
  private:
  bool _internal_has_m_maxid() const;
  public:
  void clear_m_maxid();
  int32_t m_maxid() const;
  void set_m_maxid(int32_t value);
  private:
  int32_t _internal_m_maxid() const;
  void _internal_set_m_maxid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_bag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_bag_MItemsEntry_DoNotUse,
        int32_t, ::pbdb::item,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> m_items_;
    int64_t m_id_;
    int32_t m_maxid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_keyvalue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_keyvalue) */ {
 public:
  inline db_keyvalue() : db_keyvalue(nullptr) {}
  ~db_keyvalue() override;
  explicit PROTOBUF_CONSTEXPR db_keyvalue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_keyvalue(const db_keyvalue& from);
  db_keyvalue(db_keyvalue&& from) noexcept
    : db_keyvalue() {
    *this = ::std::move(from);
  }

  inline db_keyvalue& operator=(const db_keyvalue& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_keyvalue& operator=(db_keyvalue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_keyvalue& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_keyvalue* internal_default_instance() {
    return reinterpret_cast<const db_keyvalue*>(
               &_db_keyvalue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(db_keyvalue& a, db_keyvalue& b) {
    a.Swap(&b);
  }
  inline void Swap(db_keyvalue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_keyvalue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_keyvalue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_keyvalue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_keyvalue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_keyvalue& from) {
    db_keyvalue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_keyvalue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_keyvalue";
  }
  protected:
  explicit db_keyvalue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef db_keyvalue_ekv ekv;
  static constexpr ekv none =
    db_keyvalue_ekv_none;
  static constexpr ekv account_ban =
    db_keyvalue_ekv_account_ban;
  static inline bool ekv_IsValid(int value) {
    return db_keyvalue_ekv_IsValid(value);
  }
  static constexpr ekv ekv_MIN =
    db_keyvalue_ekv_ekv_MIN;
  static constexpr ekv ekv_MAX =
    db_keyvalue_ekv_ekv_MAX;
  static constexpr int ekv_ARRAYSIZE =
    db_keyvalue_ekv_ekv_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ekv_descriptor() {
    return db_keyvalue_ekv_descriptor();
  }
  template<typename T>
  static inline const std::string& ekv_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ekv>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ekv_Name.");
    return db_keyvalue_ekv_Name(enum_t_value);
  }
  static inline bool ekv_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ekv* value) {
    return db_keyvalue_ekv_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMValueFieldNumber = 2,
    kMIdFieldNumber = 1,
  };
  // optional string m_value = 2;
  bool has_m_value() const;
  private:
  bool _internal_has_m_value() const;
  public:
  void clear_m_value();
  const std::string& m_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_value();
  PROTOBUF_NODISCARD std::string* release_m_value();
  void set_allocated_m_value(std::string* m_value);
  private:
  const std::string& _internal_m_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_value(const std::string& value);
  std::string* _internal_mutable_m_value();
  public:

  // optional int64 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int64_t m_id() const;
  void set_m_id(int64_t value);
  private:
  int64_t _internal_m_id() const;
  void _internal_set_m_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_keyvalue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_value_;
    int64_t m_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_rolekeyvalue_MDataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_rolekeyvalue_MDataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_rolekeyvalue_MDataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  db_rolekeyvalue_MDataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_rolekeyvalue_MDataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_rolekeyvalue_MDataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_rolekeyvalue_MDataEntry_DoNotUse& other);
  static const db_rolekeyvalue_MDataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_rolekeyvalue_MDataEntry_DoNotUse*>(&_db_rolekeyvalue_MDataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "pbdb.db_rolekeyvalue.MDataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "pbdb.db_rolekeyvalue.MDataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_rolekeyvalue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_rolekeyvalue) */ {
 public:
  inline db_rolekeyvalue() : db_rolekeyvalue(nullptr) {}
  ~db_rolekeyvalue() override;
  explicit PROTOBUF_CONSTEXPR db_rolekeyvalue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_rolekeyvalue(const db_rolekeyvalue& from);
  db_rolekeyvalue(db_rolekeyvalue&& from) noexcept
    : db_rolekeyvalue() {
    *this = ::std::move(from);
  }

  inline db_rolekeyvalue& operator=(const db_rolekeyvalue& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_rolekeyvalue& operator=(db_rolekeyvalue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_rolekeyvalue& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_rolekeyvalue* internal_default_instance() {
    return reinterpret_cast<const db_rolekeyvalue*>(
               &_db_rolekeyvalue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(db_rolekeyvalue& a, db_rolekeyvalue& b) {
    a.Swap(&b);
  }
  inline void Swap(db_rolekeyvalue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_rolekeyvalue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_rolekeyvalue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_rolekeyvalue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_rolekeyvalue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_rolekeyvalue& from) {
    db_rolekeyvalue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_rolekeyvalue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_rolekeyvalue";
  }
  protected:
  explicit db_rolekeyvalue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMDataFieldNumber = 2,
    kMIdFieldNumber = 1,
  };
  // map<string, string> m_data = 2;
  int m_data_size() const;
  private:
  int _internal_m_data_size() const;
  public:
  void clear_m_data();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_m_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_m_data();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      m_data() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_m_data();

  // optional int64 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int64_t m_id() const;
  void set_m_id(int64_t value);
  private:
  int64_t _internal_m_id() const;
  void _internal_set_m_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_rolekeyvalue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_rolekeyvalue_MDataEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> m_data_;
    int64_t m_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class mailitem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.mailitem) */ {
 public:
  inline mailitem() : mailitem(nullptr) {}
  ~mailitem() override;
  explicit PROTOBUF_CONSTEXPR mailitem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  mailitem(const mailitem& from);
  mailitem(mailitem&& from) noexcept
    : mailitem() {
    *this = ::std::move(from);
  }

  inline mailitem& operator=(const mailitem& from) {
    CopyFrom(from);
    return *this;
  }
  inline mailitem& operator=(mailitem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const mailitem& default_instance() {
    return *internal_default_instance();
  }
  static inline const mailitem* internal_default_instance() {
    return reinterpret_cast<const mailitem*>(
               &_mailitem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(mailitem& a, mailitem& b) {
    a.Swap(&b);
  }
  inline void Swap(mailitem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mailitem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  mailitem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<mailitem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const mailitem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const mailitem& from) {
    mailitem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mailitem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.mailitem";
  }
  protected:
  explicit mailitem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMItemtidFieldNumber = 1,
    kMCountFieldNumber = 2,
  };
  // optional int32 m_itemtid = 1;
  bool has_m_itemtid() const;
  private:
  bool _internal_has_m_itemtid() const;
  public:
  void clear_m_itemtid();
  int32_t m_itemtid() const;
  void set_m_itemtid(int32_t value);
  private:
  int32_t _internal_m_itemtid() const;
  void _internal_set_m_itemtid(int32_t value);
  public:

  // optional int32 m_count = 2;
  bool has_m_count() const;
  private:
  bool _internal_has_m_count() const;
  public:
  void clear_m_count();
  int32_t m_count() const;
  void set_m_count(int32_t value);
  private:
  int32_t _internal_m_count() const;
  void _internal_set_m_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.mailitem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t m_itemtid_;
    int32_t m_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class mail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.mail) */ {
 public:
  inline mail() : mail(nullptr) {}
  ~mail() override;
  explicit PROTOBUF_CONSTEXPR mail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  mail(const mail& from);
  mail(mail&& from) noexcept
    : mail() {
    *this = ::std::move(from);
  }

  inline mail& operator=(const mail& from) {
    CopyFrom(from);
    return *this;
  }
  inline mail& operator=(mail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const mail& default_instance() {
    return *internal_default_instance();
  }
  static inline const mail* internal_default_instance() {
    return reinterpret_cast<const mail*>(
               &_mail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(mail& a, mail& b) {
    a.Swap(&b);
  }
  inline void Swap(mail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  mail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<mail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const mail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const mail& from) {
    mail::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.mail";
  }
  protected:
  explicit mail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMItemsFieldNumber = 6,
    kMPramsFieldNumber = 4,
    kMContentFieldNumber = 5,
    kMIdFieldNumber = 1,
    kMCreateutcFieldNumber = 2,
    kMTidFieldNumber = 3,
    kMReadFieldNumber = 7,
    kMDrawFieldNumber = 8,
  };
  // repeated .pbdb.mailitem m_items = 6;
  int m_items_size() const;
  private:
  int _internal_m_items_size() const;
  public:
  void clear_m_items();
  ::pbdb::mailitem* mutable_m_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::mailitem >*
      mutable_m_items();
  private:
  const ::pbdb::mailitem& _internal_m_items(int index) const;
  ::pbdb::mailitem* _internal_add_m_items();
  public:
  const ::pbdb::mailitem& m_items(int index) const;
  ::pbdb::mailitem* add_m_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::mailitem >&
      m_items() const;

  // optional string m_prams = 4;
  bool has_m_prams() const;
  private:
  bool _internal_has_m_prams() const;
  public:
  void clear_m_prams();
  const std::string& m_prams() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_prams(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_prams();
  PROTOBUF_NODISCARD std::string* release_m_prams();
  void set_allocated_m_prams(std::string* m_prams);
  private:
  const std::string& _internal_m_prams() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_prams(const std::string& value);
  std::string* _internal_mutable_m_prams();
  public:

  // optional string m_content = 5;
  bool has_m_content() const;
  private:
  bool _internal_has_m_content() const;
  public:
  void clear_m_content();
  const std::string& m_content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_content();
  PROTOBUF_NODISCARD std::string* release_m_content();
  void set_allocated_m_content(std::string* m_content);
  private:
  const std::string& _internal_m_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_content(const std::string& value);
  std::string* _internal_mutable_m_content();
  public:

  // optional int32 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int32_t m_id() const;
  void set_m_id(int32_t value);
  private:
  int32_t _internal_m_id() const;
  void _internal_set_m_id(int32_t value);
  public:

  // optional int32 m_createutc = 2;
  bool has_m_createutc() const;
  private:
  bool _internal_has_m_createutc() const;
  public:
  void clear_m_createutc();
  int32_t m_createutc() const;
  void set_m_createutc(int32_t value);
  private:
  int32_t _internal_m_createutc() const;
  void _internal_set_m_createutc(int32_t value);
  public:

  // optional int32 m_tid = 3;
  bool has_m_tid() const;
  private:
  bool _internal_has_m_tid() const;
  public:
  void clear_m_tid();
  int32_t m_tid() const;
  void set_m_tid(int32_t value);
  private:
  int32_t _internal_m_tid() const;
  void _internal_set_m_tid(int32_t value);
  public:

  // optional bool m_read = 7;
  bool has_m_read() const;
  private:
  bool _internal_has_m_read() const;
  public:
  void clear_m_read();
  bool m_read() const;
  void set_m_read(bool value);
  private:
  bool _internal_m_read() const;
  void _internal_set_m_read(bool value);
  public:

  // optional bool m_draw = 8;
  bool has_m_draw() const;
  private:
  bool _internal_has_m_draw() const;
  public:
  void clear_m_draw();
  bool m_draw() const;
  void set_m_draw(bool value);
  private:
  bool _internal_m_draw() const;
  void _internal_set_m_draw(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.mail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::mailitem > m_items_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_prams_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_content_;
    int32_t m_id_;
    int32_t m_createutc_;
    int32_t m_tid_;
    bool m_read_;
    bool m_draw_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_mail_MMailEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_mail_MMailEntry_DoNotUse, 
    int32_t, ::pbdb::mail,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_mail_MMailEntry_DoNotUse, 
    int32_t, ::pbdb::mail,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  db_mail_MMailEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_mail_MMailEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_mail_MMailEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_mail_MMailEntry_DoNotUse& other);
  static const db_mail_MMailEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_mail_MMailEntry_DoNotUse*>(&_db_mail_MMailEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_mail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_mail) */ {
 public:
  inline db_mail() : db_mail(nullptr) {}
  ~db_mail() override;
  explicit PROTOBUF_CONSTEXPR db_mail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_mail(const db_mail& from);
  db_mail(db_mail&& from) noexcept
    : db_mail() {
    *this = ::std::move(from);
  }

  inline db_mail& operator=(const db_mail& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_mail& operator=(db_mail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_mail& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_mail* internal_default_instance() {
    return reinterpret_cast<const db_mail*>(
               &_db_mail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(db_mail& a, db_mail& b) {
    a.Swap(&b);
  }
  inline void Swap(db_mail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_mail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_mail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_mail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_mail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_mail& from) {
    db_mail::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_mail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_mail";
  }
  protected:
  explicit db_mail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMMailFieldNumber = 2,
    kMIdFieldNumber = 1,
  };
  // map<int32, .pbdb.mail> m_mail = 2;
  int m_mail_size() const;
  private:
  int _internal_m_mail_size() const;
  public:
  void clear_m_mail();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >&
      _internal_m_mail() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >*
      _internal_mutable_m_mail();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >&
      m_mail() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >*
      mutable_m_mail();

  // optional int64 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int64_t m_id() const;
  void set_m_id(int64_t value);
  private:
  int64_t _internal_m_id() const;
  void _internal_set_m_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_mail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_mail_MMailEntry_DoNotUse,
        int32_t, ::pbdb::mail,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> m_mail_;
    int64_t m_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_guild final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_guild) */ {
 public:
  inline db_guild() : db_guild(nullptr) {}
  ~db_guild() override;
  explicit PROTOBUF_CONSTEXPR db_guild(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_guild(const db_guild& from);
  db_guild(db_guild&& from) noexcept
    : db_guild() {
    *this = ::std::move(from);
  }

  inline db_guild& operator=(const db_guild& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_guild& operator=(db_guild&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_guild& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_guild* internal_default_instance() {
    return reinterpret_cast<const db_guild*>(
               &_db_guild_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(db_guild& a, db_guild& b) {
    a.Swap(&b);
  }
  inline void Swap(db_guild* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_guild* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_guild* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_guild>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_guild& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_guild& from) {
    db_guild::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_guild* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_guild";
  }
  protected:
  explicit db_guild(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMMembersFieldNumber = 4,
    kMGuildFieldNumber = 2,
    kMIdFieldNumber = 1,
    kMLeaderFieldNumber = 3,
  };
  // repeated int64 m_members = 4;
  int m_members_size() const;
  private:
  int _internal_m_members_size() const;
  public:
  void clear_m_members();
  private:
  int64_t _internal_m_members(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_m_members() const;
  void _internal_add_m_members(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_m_members();
  public:
  int64_t m_members(int index) const;
  void set_m_members(int index, int64_t value);
  void add_m_members(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      m_members() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_m_members();

  // optional string m_guild = 2;
  bool has_m_guild() const;
  private:
  bool _internal_has_m_guild() const;
  public:
  void clear_m_guild();
  const std::string& m_guild() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_guild(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_guild();
  PROTOBUF_NODISCARD std::string* release_m_guild();
  void set_allocated_m_guild(std::string* m_guild);
  private:
  const std::string& _internal_m_guild() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_guild(const std::string& value);
  std::string* _internal_mutable_m_guild();
  public:

  // optional int64 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int64_t m_id() const;
  void set_m_id(int64_t value);
  private:
  int64_t _internal_m_id() const;
  void _internal_set_m_id(int64_t value);
  public:

  // optional int64 m_leader = 3;
  bool has_m_leader() const;
  private:
  bool _internal_has_m_leader() const;
  public:
  void clear_m_leader();
  int64_t m_leader() const;
  void set_m_leader(int64_t value);
  private:
  int64_t _internal_m_leader() const;
  void _internal_set_m_leader(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_guild)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > m_members_;
    mutable std::atomic<int> _m_members_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_guild_;
    int64_t m_id_;
    int64_t m_leader_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_notice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_notice) */ {
 public:
  inline db_notice() : db_notice(nullptr) {}
  ~db_notice() override;
  explicit PROTOBUF_CONSTEXPR db_notice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_notice(const db_notice& from);
  db_notice(db_notice&& from) noexcept
    : db_notice() {
    *this = ::std::move(from);
  }

  inline db_notice& operator=(const db_notice& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_notice& operator=(db_notice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_notice& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_notice* internal_default_instance() {
    return reinterpret_cast<const db_notice*>(
               &_db_notice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(db_notice& a, db_notice& b) {
    a.Swap(&b);
  }
  inline void Swap(db_notice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_notice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_notice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_notice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_notice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_notice& from) {
    db_notice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_notice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_notice";
  }
  protected:
  explicit db_notice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMNoticeFieldNumber = 2,
    kMIdFieldNumber = 1,
    kMStarttimeFieldNumber = 3,
    kMFinishtimeFieldNumber = 4,
  };
  // optional string m_notice = 2;
  bool has_m_notice() const;
  private:
  bool _internal_has_m_notice() const;
  public:
  void clear_m_notice();
  const std::string& m_notice() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_notice(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_notice();
  PROTOBUF_NODISCARD std::string* release_m_notice();
  void set_allocated_m_notice(std::string* m_notice);
  private:
  const std::string& _internal_m_notice() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_notice(const std::string& value);
  std::string* _internal_mutable_m_notice();
  public:

  // optional int64 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int64_t m_id() const;
  void set_m_id(int64_t value);
  private:
  int64_t _internal_m_id() const;
  void _internal_set_m_id(int64_t value);
  public:

  // optional int32 m_starttime = 3;
  bool has_m_starttime() const;
  private:
  bool _internal_has_m_starttime() const;
  public:
  void clear_m_starttime();
  int32_t m_starttime() const;
  void set_m_starttime(int32_t value);
  private:
  int32_t _internal_m_starttime() const;
  void _internal_set_m_starttime(int32_t value);
  public:

  // optional int32 m_finishtime = 4;
  bool has_m_finishtime() const;
  private:
  bool _internal_has_m_finishtime() const;
  public:
  void clear_m_finishtime();
  int32_t m_finishtime() const;
  void set_m_finishtime(int32_t value);
  private:
  int32_t _internal_m_finishtime() const;
  void _internal_set_m_finishtime(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_notice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_notice_;
    int64_t m_id_;
    int32_t m_starttime_;
    int32_t m_finishtime_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class rankitem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.rankitem) */ {
 public:
  inline rankitem() : rankitem(nullptr) {}
  ~rankitem() override;
  explicit PROTOBUF_CONSTEXPR rankitem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  rankitem(const rankitem& from);
  rankitem(rankitem&& from) noexcept
    : rankitem() {
    *this = ::std::move(from);
  }

  inline rankitem& operator=(const rankitem& from) {
    CopyFrom(from);
    return *this;
  }
  inline rankitem& operator=(rankitem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const rankitem& default_instance() {
    return *internal_default_instance();
  }
  static inline const rankitem* internal_default_instance() {
    return reinterpret_cast<const rankitem*>(
               &_rankitem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(rankitem& a, rankitem& b) {
    a.Swap(&b);
  }
  inline void Swap(rankitem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(rankitem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  rankitem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<rankitem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const rankitem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const rankitem& from) {
    rankitem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rankitem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.rankitem";
  }
  protected:
  explicit rankitem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMValueFieldNumber = 1,
    kMTimeFieldNumber = 2,
  };
  // optional int64 m_value = 1;
  bool has_m_value() const;
  private:
  bool _internal_has_m_value() const;
  public:
  void clear_m_value();
  int64_t m_value() const;
  void set_m_value(int64_t value);
  private:
  int64_t _internal_m_value() const;
  void _internal_set_m_value(int64_t value);
  public:

  // optional int32 m_time = 2;
  bool has_m_time() const;
  private:
  bool _internal_has_m_time() const;
  public:
  void clear_m_time();
  int32_t m_time() const;
  void set_m_time(int32_t value);
  private:
  int32_t _internal_m_time() const;
  void _internal_set_m_time(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.rankitem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t m_value_;
    int32_t m_time_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_ranklist_MItemsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_ranklist_MItemsEntry_DoNotUse, 
    int32_t, ::pbdb::rankitem,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_ranklist_MItemsEntry_DoNotUse, 
    int32_t, ::pbdb::rankitem,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  db_ranklist_MItemsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_ranklist_MItemsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_ranklist_MItemsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_ranklist_MItemsEntry_DoNotUse& other);
  static const db_ranklist_MItemsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_ranklist_MItemsEntry_DoNotUse*>(&_db_ranklist_MItemsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_ranklist final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_ranklist) */ {
 public:
  inline db_ranklist() : db_ranklist(nullptr) {}
  ~db_ranklist() override;
  explicit PROTOBUF_CONSTEXPR db_ranklist(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_ranklist(const db_ranklist& from);
  db_ranklist(db_ranklist&& from) noexcept
    : db_ranklist() {
    *this = ::std::move(from);
  }

  inline db_ranklist& operator=(const db_ranklist& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_ranklist& operator=(db_ranklist&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_ranklist& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_ranklist* internal_default_instance() {
    return reinterpret_cast<const db_ranklist*>(
               &_db_ranklist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(db_ranklist& a, db_ranklist& b) {
    a.Swap(&b);
  }
  inline void Swap(db_ranklist* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_ranklist* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_ranklist* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_ranklist>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_ranklist& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_ranklist& from) {
    db_ranklist::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_ranklist* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_ranklist";
  }
  protected:
  explicit db_ranklist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMItemsFieldNumber = 2,
    kMIdFieldNumber = 1,
  };
  // map<int32, .pbdb.rankitem> m_items = 2;
  int m_items_size() const;
  private:
  int _internal_m_items_size() const;
  public:
  void clear_m_items();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >&
      _internal_m_items() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >*
      _internal_mutable_m_items();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >&
      m_items() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >*
      mutable_m_items();

  // optional int64 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int64_t m_id() const;
  void set_m_id(int64_t value);
  private:
  int64_t _internal_m_id() const;
  void _internal_set_m_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_ranklist)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_ranklist_MItemsEntry_DoNotUse,
        int32_t, ::pbdb::rankitem,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> m_items_;
    int64_t m_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_activity_drawcompliance_MRewardEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_activity_drawcompliance_MRewardEntry_DoNotUse, 
    int32_t, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_activity_drawcompliance_MRewardEntry_DoNotUse, 
    int32_t, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> SuperType;
  db_activity_drawcompliance_MRewardEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_activity_drawcompliance_MRewardEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_activity_drawcompliance_MRewardEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_activity_drawcompliance_MRewardEntry_DoNotUse& other);
  static const db_activity_drawcompliance_MRewardEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_activity_drawcompliance_MRewardEntry_DoNotUse*>(&_db_activity_drawcompliance_MRewardEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_activity_drawcompliance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_activity.drawcompliance) */ {
 public:
  inline db_activity_drawcompliance() : db_activity_drawcompliance(nullptr) {}
  ~db_activity_drawcompliance() override;
  explicit PROTOBUF_CONSTEXPR db_activity_drawcompliance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_activity_drawcompliance(const db_activity_drawcompliance& from);
  db_activity_drawcompliance(db_activity_drawcompliance&& from) noexcept
    : db_activity_drawcompliance() {
    *this = ::std::move(from);
  }

  inline db_activity_drawcompliance& operator=(const db_activity_drawcompliance& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_activity_drawcompliance& operator=(db_activity_drawcompliance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_activity_drawcompliance& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_activity_drawcompliance* internal_default_instance() {
    return reinterpret_cast<const db_activity_drawcompliance*>(
               &_db_activity_drawcompliance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(db_activity_drawcompliance& a, db_activity_drawcompliance& b) {
    a.Swap(&b);
  }
  inline void Swap(db_activity_drawcompliance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_activity_drawcompliance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_activity_drawcompliance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_activity_drawcompliance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_activity_drawcompliance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_activity_drawcompliance& from) {
    db_activity_drawcompliance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_activity_drawcompliance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_activity.drawcompliance";
  }
  protected:
  explicit db_activity_drawcompliance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMRewardFieldNumber = 2,
    kMCountFieldNumber = 1,
  };
  // map<int32, bool> m_reward = 2;
  int m_reward_size() const;
  private:
  int _internal_m_reward_size() const;
  public:
  void clear_m_reward();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >&
      _internal_m_reward() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >*
      _internal_mutable_m_reward();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >&
      m_reward() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >*
      mutable_m_reward();

  // optional int32 m_count = 1;
  bool has_m_count() const;
  private:
  bool _internal_has_m_count() const;
  public:
  void clear_m_count();
  int32_t m_count() const;
  void set_m_count(int32_t value);
  private:
  int32_t _internal_m_count() const;
  void _internal_set_m_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_activity.drawcompliance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_activity_drawcompliance_MRewardEntry_DoNotUse,
        int32_t, bool,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> m_reward_;
    int32_t m_count_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_activity_MDrawcomplianceEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_activity_MDrawcomplianceEntry_DoNotUse, 
    int64_t, ::pbdb::db_activity_drawcompliance,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_activity_MDrawcomplianceEntry_DoNotUse, 
    int64_t, ::pbdb::db_activity_drawcompliance,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  db_activity_MDrawcomplianceEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_activity_MDrawcomplianceEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_activity_MDrawcomplianceEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_activity_MDrawcomplianceEntry_DoNotUse& other);
  static const db_activity_MDrawcomplianceEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_activity_MDrawcomplianceEntry_DoNotUse*>(&_db_activity_MDrawcomplianceEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_activity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_activity) */ {
 public:
  inline db_activity() : db_activity(nullptr) {}
  ~db_activity() override;
  explicit PROTOBUF_CONSTEXPR db_activity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_activity(const db_activity& from);
  db_activity(db_activity&& from) noexcept
    : db_activity() {
    *this = ::std::move(from);
  }

  inline db_activity& operator=(const db_activity& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_activity& operator=(db_activity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_activity& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_activity* internal_default_instance() {
    return reinterpret_cast<const db_activity*>(
               &_db_activity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(db_activity& a, db_activity& b) {
    a.Swap(&b);
  }
  inline void Swap(db_activity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_activity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_activity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_activity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_activity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_activity& from) {
    db_activity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_activity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_activity";
  }
  protected:
  explicit db_activity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef db_activity_drawcompliance drawcompliance;

  // accessors -------------------------------------------------------

  enum : int {
    kMDrawcomplianceFieldNumber = 7,
    kMIdFieldNumber = 1,
    kMBegFieldNumber = 2,
    kMEndFieldNumber = 3,
    kMStartFieldNumber = 4,
    kMFinishFieldNumber = 5,
    kMCalendaridFieldNumber = 6,
  };
  // map<int64, .pbdb.db_activity.drawcompliance> m_drawcompliance = 7;
  int m_drawcompliance_size() const;
  private:
  int _internal_m_drawcompliance_size() const;
  public:
  void clear_m_drawcompliance();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::db_activity_drawcompliance >&
      _internal_m_drawcompliance() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::db_activity_drawcompliance >*
      _internal_mutable_m_drawcompliance();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::db_activity_drawcompliance >&
      m_drawcompliance() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::db_activity_drawcompliance >*
      mutable_m_drawcompliance();

  // optional int64 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int64_t m_id() const;
  void set_m_id(int64_t value);
  private:
  int64_t _internal_m_id() const;
  void _internal_set_m_id(int64_t value);
  public:

  // optional int32 m_beg = 2;
  bool has_m_beg() const;
  private:
  bool _internal_has_m_beg() const;
  public:
  void clear_m_beg();
  int32_t m_beg() const;
  void set_m_beg(int32_t value);
  private:
  int32_t _internal_m_beg() const;
  void _internal_set_m_beg(int32_t value);
  public:

  // optional int32 m_end = 3;
  bool has_m_end() const;
  private:
  bool _internal_has_m_end() const;
  public:
  void clear_m_end();
  int32_t m_end() const;
  void set_m_end(int32_t value);
  private:
  int32_t _internal_m_end() const;
  void _internal_set_m_end(int32_t value);
  public:

  // optional bool m_start = 4;
  bool has_m_start() const;
  private:
  bool _internal_has_m_start() const;
  public:
  void clear_m_start();
  bool m_start() const;
  void set_m_start(bool value);
  private:
  bool _internal_m_start() const;
  void _internal_set_m_start(bool value);
  public:

  // optional bool m_finish = 5;
  bool has_m_finish() const;
  private:
  bool _internal_has_m_finish() const;
  public:
  void clear_m_finish();
  bool m_finish() const;
  void set_m_finish(bool value);
  private:
  bool _internal_m_finish() const;
  void _internal_set_m_finish(bool value);
  public:

  // optional int32 m_calendarid = 6;
  bool has_m_calendarid() const;
  private:
  bool _internal_has_m_calendarid() const;
  public:
  void clear_m_calendarid();
  int32_t m_calendarid() const;
  void set_m_calendarid(int32_t value);
  private:
  int32_t _internal_m_calendarid() const;
  void _internal_set_m_calendarid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_activity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_activity_MDrawcomplianceEntry_DoNotUse,
        int64_t, ::pbdb::db_activity_drawcompliance,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> m_drawcompliance_;
    int64_t m_id_;
    int32_t m_beg_;
    int32_t m_end_;
    bool m_start_;
    bool m_finish_;
    int32_t m_calendarid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_task_data_schedule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_task.data_schedule) */ {
 public:
  inline db_task_data_schedule() : db_task_data_schedule(nullptr) {}
  ~db_task_data_schedule() override;
  explicit PROTOBUF_CONSTEXPR db_task_data_schedule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_task_data_schedule(const db_task_data_schedule& from);
  db_task_data_schedule(db_task_data_schedule&& from) noexcept
    : db_task_data_schedule() {
    *this = ::std::move(from);
  }

  inline db_task_data_schedule& operator=(const db_task_data_schedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_task_data_schedule& operator=(db_task_data_schedule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_task_data_schedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_task_data_schedule* internal_default_instance() {
    return reinterpret_cast<const db_task_data_schedule*>(
               &_db_task_data_schedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(db_task_data_schedule& a, db_task_data_schedule& b) {
    a.Swap(&b);
  }
  inline void Swap(db_task_data_schedule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_task_data_schedule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_task_data_schedule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_task_data_schedule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_task_data_schedule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_task_data_schedule& from) {
    db_task_data_schedule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_task_data_schedule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_task.data_schedule";
  }
  protected:
  explicit db_task_data_schedule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMTypeFieldNumber = 1,
    kMValueFieldNumber = 2,
    kMSumintFieldNumber = 3,
  };
  // optional int32 m_type = 1;
  bool has_m_type() const;
  private:
  bool _internal_has_m_type() const;
  public:
  void clear_m_type();
  int32_t m_type() const;
  void set_m_type(int32_t value);
  private:
  int32_t _internal_m_type() const;
  void _internal_set_m_type(int32_t value);
  public:

  // optional int32 m_value = 2;
  bool has_m_value() const;
  private:
  bool _internal_has_m_value() const;
  public:
  void clear_m_value();
  int32_t m_value() const;
  void set_m_value(int32_t value);
  private:
  int32_t _internal_m_value() const;
  void _internal_set_m_value(int32_t value);
  public:

  // optional int32 m_sumint = 3;
  bool has_m_sumint() const;
  private:
  bool _internal_has_m_sumint() const;
  public:
  void clear_m_sumint();
  int32_t m_sumint() const;
  void set_m_sumint(int32_t value);
  private:
  int32_t _internal_m_sumint() const;
  void _internal_set_m_sumint(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_task.data_schedule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t m_type_;
    int32_t m_value_;
    int32_t m_sumint_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_task_data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_task.data) */ {
 public:
  inline db_task_data() : db_task_data(nullptr) {}
  ~db_task_data() override;
  explicit PROTOBUF_CONSTEXPR db_task_data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_task_data(const db_task_data& from);
  db_task_data(db_task_data&& from) noexcept
    : db_task_data() {
    *this = ::std::move(from);
  }

  inline db_task_data& operator=(const db_task_data& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_task_data& operator=(db_task_data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_task_data& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_task_data* internal_default_instance() {
    return reinterpret_cast<const db_task_data*>(
               &_db_task_data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(db_task_data& a, db_task_data& b) {
    a.Swap(&b);
  }
  inline void Swap(db_task_data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_task_data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_task_data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_task_data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_task_data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_task_data& from) {
    db_task_data::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_task_data* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_task.data";
  }
  protected:
  explicit db_task_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMSchedulesFieldNumber = 4,
    kMTaskidFieldNumber = 1,
    kMReceiveutcFieldNumber = 2,
    kMFinshutcFieldNumber = 3,
    kMReceiveFieldNumber = 5,
  };
  // repeated .pbdb.db_task.data_schedule m_schedules = 4;
  int m_schedules_size() const;
  private:
  int _internal_m_schedules_size() const;
  public:
  void clear_m_schedules();
  ::pbdb::db_task_data_schedule* mutable_m_schedules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_task_data_schedule >*
      mutable_m_schedules();
  private:
  const ::pbdb::db_task_data_schedule& _internal_m_schedules(int index) const;
  ::pbdb::db_task_data_schedule* _internal_add_m_schedules();
  public:
  const ::pbdb::db_task_data_schedule& m_schedules(int index) const;
  ::pbdb::db_task_data_schedule* add_m_schedules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_task_data_schedule >&
      m_schedules() const;

  // optional int32 m_taskid = 1;
  bool has_m_taskid() const;
  private:
  bool _internal_has_m_taskid() const;
  public:
  void clear_m_taskid();
  int32_t m_taskid() const;
  void set_m_taskid(int32_t value);
  private:
  int32_t _internal_m_taskid() const;
  void _internal_set_m_taskid(int32_t value);
  public:

  // optional int32 m_receiveutc = 2;
  bool has_m_receiveutc() const;
  private:
  bool _internal_has_m_receiveutc() const;
  public:
  void clear_m_receiveutc();
  int32_t m_receiveutc() const;
  void set_m_receiveutc(int32_t value);
  private:
  int32_t _internal_m_receiveutc() const;
  void _internal_set_m_receiveutc(int32_t value);
  public:

  // optional int32 m_finshutc = 3;
  bool has_m_finshutc() const;
  private:
  bool _internal_has_m_finshutc() const;
  public:
  void clear_m_finshutc();
  int32_t m_finshutc() const;
  void set_m_finshutc(int32_t value);
  private:
  int32_t _internal_m_finshutc() const;
  void _internal_set_m_finshutc(int32_t value);
  public:

  // optional bool m_receive = 5;
  bool has_m_receive() const;
  private:
  bool _internal_has_m_receive() const;
  public:
  void clear_m_receive();
  bool m_receive() const;
  void set_m_receive(bool value);
  private:
  bool _internal_m_receive() const;
  void _internal_set_m_receive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_task.data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_task_data_schedule > m_schedules_;
    int32_t m_taskid_;
    int32_t m_receiveutc_;
    int32_t m_finshutc_;
    bool m_receive_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_task_MRundatasEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_task_MRundatasEntry_DoNotUse, 
    int32_t, ::pbdb::db_task_data,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_task_MRundatasEntry_DoNotUse, 
    int32_t, ::pbdb::db_task_data,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  db_task_MRundatasEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_task_MRundatasEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_task_MRundatasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_task_MRundatasEntry_DoNotUse& other);
  static const db_task_MRundatasEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_task_MRundatasEntry_DoNotUse*>(&_db_task_MRundatasEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_task_MCompleteddatasEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_task_MCompleteddatasEntry_DoNotUse, 
    int32_t, ::pbdb::db_task_data,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_task_MCompleteddatasEntry_DoNotUse, 
    int32_t, ::pbdb::db_task_data,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  db_task_MCompleteddatasEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_task_MCompleteddatasEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_task_MCompleteddatasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_task_MCompleteddatasEntry_DoNotUse& other);
  static const db_task_MCompleteddatasEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_task_MCompleteddatasEntry_DoNotUse*>(&_db_task_MCompleteddatasEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_task final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_task) */ {
 public:
  inline db_task() : db_task(nullptr) {}
  ~db_task() override;
  explicit PROTOBUF_CONSTEXPR db_task(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_task(const db_task& from);
  db_task(db_task&& from) noexcept
    : db_task() {
    *this = ::std::move(from);
  }

  inline db_task& operator=(const db_task& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_task& operator=(db_task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_task& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_task* internal_default_instance() {
    return reinterpret_cast<const db_task*>(
               &_db_task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(db_task& a, db_task& b) {
    a.Swap(&b);
  }
  inline void Swap(db_task* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_task* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_task* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_task>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_task& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_task& from) {
    db_task::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_task* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_task";
  }
  protected:
  explicit db_task(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef db_task_data_schedule data_schedule;
  typedef db_task_data data;

  // accessors -------------------------------------------------------

  enum : int {
    kMRundatasFieldNumber = 2,
    kMCompleteddatasFieldNumber = 3,
    kMIdFieldNumber = 1,
  };
  // map<int32, .pbdb.db_task.data> m_rundatas = 2;
  int m_rundatas_size() const;
  private:
  int _internal_m_rundatas_size() const;
  public:
  void clear_m_rundatas();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >&
      _internal_m_rundatas() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >*
      _internal_mutable_m_rundatas();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >&
      m_rundatas() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >*
      mutable_m_rundatas();

  // map<int32, .pbdb.db_task.data> m_completeddatas = 3;
  int m_completeddatas_size() const;
  private:
  int _internal_m_completeddatas_size() const;
  public:
  void clear_m_completeddatas();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >&
      _internal_m_completeddatas() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >*
      _internal_mutable_m_completeddatas();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >&
      m_completeddatas() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >*
      mutable_m_completeddatas();

  // optional int64 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int64_t m_id() const;
  void set_m_id(int64_t value);
  private:
  int64_t _internal_m_id() const;
  void _internal_set_m_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_task)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_task_MRundatasEntry_DoNotUse,
        int32_t, ::pbdb::db_task_data,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> m_rundatas_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_task_MCompleteddatasEntry_DoNotUse,
        int32_t, ::pbdb::db_task_data,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> m_completeddatas_;
    int64_t m_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_calendar final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_calendar) */ {
 public:
  inline db_calendar() : db_calendar(nullptr) {}
  ~db_calendar() override;
  explicit PROTOBUF_CONSTEXPR db_calendar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_calendar(const db_calendar& from);
  db_calendar(db_calendar&& from) noexcept
    : db_calendar() {
    *this = ::std::move(from);
  }

  inline db_calendar& operator=(const db_calendar& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_calendar& operator=(db_calendar&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_calendar& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_calendar* internal_default_instance() {
    return reinterpret_cast<const db_calendar*>(
               &_db_calendar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(db_calendar& a, db_calendar& b) {
    a.Swap(&b);
  }
  inline void Swap(db_calendar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_calendar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_calendar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_calendar>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_calendar& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_calendar& from) {
    db_calendar::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_calendar* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_calendar";
  }
  protected:
  explicit db_calendar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMIdFieldNumber = 1,
    kMTimeFieldNumber = 2,
    kMStartFieldNumber = 3,
    kMFinishFieldNumber = 4,
  };
  // optional int64 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int64_t m_id() const;
  void set_m_id(int64_t value);
  private:
  int64_t _internal_m_id() const;
  void _internal_set_m_id(int64_t value);
  public:

  // optional int64 m_time = 2;
  bool has_m_time() const;
  private:
  bool _internal_has_m_time() const;
  public:
  void clear_m_time();
  int64_t m_time() const;
  void set_m_time(int64_t value);
  private:
  int64_t _internal_m_time() const;
  void _internal_set_m_time(int64_t value);
  public:

  // optional bool m_start = 3;
  bool has_m_start() const;
  private:
  bool _internal_has_m_start() const;
  public:
  void clear_m_start();
  bool m_start() const;
  void set_m_start(bool value);
  private:
  bool _internal_m_start() const;
  void _internal_set_m_start(bool value);
  public:

  // optional bool m_finish = 4;
  bool has_m_finish() const;
  private:
  bool _internal_has_m_finish() const;
  public:
  void clear_m_finish();
  bool m_finish() const;
  void set_m_finish(bool value);
  private:
  bool _internal_m_finish() const;
  void _internal_set_m_finish(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_calendar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t m_id_;
    int64_t m_time_;
    bool m_start_;
    bool m_finish_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_familyer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_familyer) */ {
 public:
  inline db_familyer() : db_familyer(nullptr) {}
  ~db_familyer() override;
  explicit PROTOBUF_CONSTEXPR db_familyer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_familyer(const db_familyer& from);
  db_familyer(db_familyer&& from) noexcept
    : db_familyer() {
    *this = ::std::move(from);
  }

  inline db_familyer& operator=(const db_familyer& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_familyer& operator=(db_familyer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_familyer& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_familyer* internal_default_instance() {
    return reinterpret_cast<const db_familyer*>(
               &_db_familyer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(db_familyer& a, db_familyer& b) {
    a.Swap(&b);
  }
  inline void Swap(db_familyer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_familyer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_familyer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_familyer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_familyer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_familyer& from) {
    db_familyer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_familyer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_familyer";
  }
  protected:
  explicit db_familyer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef db_familyer_eposition eposition;
  static constexpr eposition none =
    db_familyer_eposition_none;
  static constexpr eposition leader =
    db_familyer_eposition_leader;
  static constexpr eposition counsellor =
    db_familyer_eposition_counsellor;
  static constexpr eposition ordinary =
    db_familyer_eposition_ordinary;
  static inline bool eposition_IsValid(int value) {
    return db_familyer_eposition_IsValid(value);
  }
  static constexpr eposition eposition_MIN =
    db_familyer_eposition_eposition_MIN;
  static constexpr eposition eposition_MAX =
    db_familyer_eposition_eposition_MAX;
  static constexpr int eposition_ARRAYSIZE =
    db_familyer_eposition_eposition_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  eposition_descriptor() {
    return db_familyer_eposition_descriptor();
  }
  template<typename T>
  static inline const std::string& eposition_Name(T enum_t_value) {
    static_assert(::std::is_same<T, eposition>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function eposition_Name.");
    return db_familyer_eposition_Name(enum_t_value);
  }
  static inline bool eposition_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      eposition* value) {
    return db_familyer_eposition_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMIdFieldNumber = 1,
    kMJoinutcFieldNumber = 2,
    kMLastsignutcFieldNumber = 3,
    kMLastleaveutcFieldNumber = 4,
    kMPositionFieldNumber = 5,
  };
  // optional int64 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int64_t m_id() const;
  void set_m_id(int64_t value);
  private:
  int64_t _internal_m_id() const;
  void _internal_set_m_id(int64_t value);
  public:

  // optional int32 m_joinutc = 2;
  bool has_m_joinutc() const;
  private:
  bool _internal_has_m_joinutc() const;
  public:
  void clear_m_joinutc();
  int32_t m_joinutc() const;
  void set_m_joinutc(int32_t value);
  private:
  int32_t _internal_m_joinutc() const;
  void _internal_set_m_joinutc(int32_t value);
  public:

  // optional int32 m_lastsignutc = 3;
  bool has_m_lastsignutc() const;
  private:
  bool _internal_has_m_lastsignutc() const;
  public:
  void clear_m_lastsignutc();
  int32_t m_lastsignutc() const;
  void set_m_lastsignutc(int32_t value);
  private:
  int32_t _internal_m_lastsignutc() const;
  void _internal_set_m_lastsignutc(int32_t value);
  public:

  // optional int32 m_lastleaveutc = 4;
  bool has_m_lastleaveutc() const;
  private:
  bool _internal_has_m_lastleaveutc() const;
  public:
  void clear_m_lastleaveutc();
  int32_t m_lastleaveutc() const;
  void set_m_lastleaveutc(int32_t value);
  private:
  int32_t _internal_m_lastleaveutc() const;
  void _internal_set_m_lastleaveutc(int32_t value);
  public:

  // optional .pbdb.db_familyer.eposition m_position = 5;
  bool has_m_position() const;
  private:
  bool _internal_has_m_position() const;
  public:
  void clear_m_position();
  ::pbdb::db_familyer_eposition m_position() const;
  void set_m_position(::pbdb::db_familyer_eposition value);
  private:
  ::pbdb::db_familyer_eposition _internal_m_position() const;
  void _internal_set_m_position(::pbdb::db_familyer_eposition value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_familyer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t m_id_;
    int32_t m_joinutc_;
    int32_t m_lastsignutc_;
    int32_t m_lastleaveutc_;
    int m_position_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_family final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_family) */ {
 public:
  inline db_family() : db_family(nullptr) {}
  ~db_family() override;
  explicit PROTOBUF_CONSTEXPR db_family(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_family(const db_family& from);
  db_family(db_family&& from) noexcept
    : db_family() {
    *this = ::std::move(from);
  }

  inline db_family& operator=(const db_family& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_family& operator=(db_family&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_family& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_family* internal_default_instance() {
    return reinterpret_cast<const db_family*>(
               &_db_family_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(db_family& a, db_family& b) {
    a.Swap(&b);
  }
  inline void Swap(db_family* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_family* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_family* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_family>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_family& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_family& from) {
    db_family::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_family* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_family";
  }
  protected:
  explicit db_family(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMMemberFieldNumber = 7,
    kMApplylistFieldNumber = 8,
    kMNameFieldNumber = 3,
    kMIdFieldNumber = 1,
    kMCreateutcFieldNumber = 2,
    kMLvFieldNumber = 5,
    kMLeaderFieldNumber = 4,
    kMExpFieldNumber = 6,
  };
  // repeated int64 m_member = 7;
  int m_member_size() const;
  private:
  int _internal_m_member_size() const;
  public:
  void clear_m_member();
  private:
  int64_t _internal_m_member(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_m_member() const;
  void _internal_add_m_member(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_m_member();
  public:
  int64_t m_member(int index) const;
  void set_m_member(int index, int64_t value);
  void add_m_member(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      m_member() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_m_member();

  // repeated int64 m_applylist = 8;
  int m_applylist_size() const;
  private:
  int _internal_m_applylist_size() const;
  public:
  void clear_m_applylist();
  private:
  int64_t _internal_m_applylist(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_m_applylist() const;
  void _internal_add_m_applylist(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_m_applylist();
  public:
  int64_t m_applylist(int index) const;
  void set_m_applylist(int index, int64_t value);
  void add_m_applylist(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      m_applylist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_m_applylist();

  // optional string m_name = 3;
  bool has_m_name() const;
  private:
  bool _internal_has_m_name() const;
  public:
  void clear_m_name();
  const std::string& m_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_m_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_m_name();
  PROTOBUF_NODISCARD std::string* release_m_name();
  void set_allocated_m_name(std::string* m_name);
  private:
  const std::string& _internal_m_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_m_name(const std::string& value);
  std::string* _internal_mutable_m_name();
  public:

  // optional int64 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int64_t m_id() const;
  void set_m_id(int64_t value);
  private:
  int64_t _internal_m_id() const;
  void _internal_set_m_id(int64_t value);
  public:

  // optional int32 m_createutc = 2;
  bool has_m_createutc() const;
  private:
  bool _internal_has_m_createutc() const;
  public:
  void clear_m_createutc();
  int32_t m_createutc() const;
  void set_m_createutc(int32_t value);
  private:
  int32_t _internal_m_createutc() const;
  void _internal_set_m_createutc(int32_t value);
  public:

  // optional int32 m_lv = 5;
  bool has_m_lv() const;
  private:
  bool _internal_has_m_lv() const;
  public:
  void clear_m_lv();
  int32_t m_lv() const;
  void set_m_lv(int32_t value);
  private:
  int32_t _internal_m_lv() const;
  void _internal_set_m_lv(int32_t value);
  public:

  // optional int64 m_leader = 4;
  bool has_m_leader() const;
  private:
  bool _internal_has_m_leader() const;
  public:
  void clear_m_leader();
  int64_t m_leader() const;
  void set_m_leader(int64_t value);
  private:
  int64_t _internal_m_leader() const;
  void _internal_set_m_leader(int64_t value);
  public:

  // optional int32 m_exp = 6;
  bool has_m_exp() const;
  private:
  bool _internal_has_m_exp() const;
  public:
  void clear_m_exp();
  int32_t m_exp() const;
  void set_m_exp(int32_t value);
  private:
  int32_t _internal_m_exp() const;
  void _internal_set_m_exp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_family)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > m_member_;
    mutable std::atomic<int> _m_member_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > m_applylist_;
    mutable std::atomic<int> _m_applylist_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr m_name_;
    int64_t m_id_;
    int32_t m_createutc_;
    int32_t m_lv_;
    int64_t m_leader_;
    int32_t m_exp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_friends final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_friends) */ {
 public:
  inline db_friends() : db_friends(nullptr) {}
  ~db_friends() override;
  explicit PROTOBUF_CONSTEXPR db_friends(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_friends(const db_friends& from);
  db_friends(db_friends&& from) noexcept
    : db_friends() {
    *this = ::std::move(from);
  }

  inline db_friends& operator=(const db_friends& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_friends& operator=(db_friends&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_friends& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_friends* internal_default_instance() {
    return reinterpret_cast<const db_friends*>(
               &_db_friends_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(db_friends& a, db_friends& b) {
    a.Swap(&b);
  }
  inline void Swap(db_friends* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_friends* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_friends* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_friends>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_friends& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_friends& from) {
    db_friends::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_friends* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_friends";
  }
  protected:
  explicit db_friends(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMFriendsFieldNumber = 2,
    kMApplyfriendsFieldNumber = 3,
    kMIdFieldNumber = 1,
  };
  // repeated int64 m_friends = 2;
  int m_friends_size() const;
  private:
  int _internal_m_friends_size() const;
  public:
  void clear_m_friends();
  private:
  int64_t _internal_m_friends(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_m_friends() const;
  void _internal_add_m_friends(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_m_friends();
  public:
  int64_t m_friends(int index) const;
  void set_m_friends(int index, int64_t value);
  void add_m_friends(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      m_friends() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_m_friends();

  // repeated int64 m_applyfriends = 3;
  int m_applyfriends_size() const;
  private:
  int _internal_m_applyfriends_size() const;
  public:
  void clear_m_applyfriends();
  private:
  int64_t _internal_m_applyfriends(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_m_applyfriends() const;
  void _internal_add_m_applyfriends(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_m_applyfriends();
  public:
  int64_t m_applyfriends(int index) const;
  void set_m_applyfriends(int index, int64_t value);
  void add_m_applyfriends(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      m_applyfriends() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_m_applyfriends();

  // optional int64 m_id = 1;
  bool has_m_id() const;
  private:
  bool _internal_has_m_id() const;
  public:
  void clear_m_id();
  int64_t m_id() const;
  void set_m_id(int64_t value);
  private:
  int64_t _internal_m_id() const;
  void _internal_set_m_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_friends)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > m_friends_;
    mutable std::atomic<int> _m_friends_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > m_applyfriends_;
    mutable std::atomic<int> _m_applyfriends_cached_byte_size_;
    int64_t m_id_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// db_account

// optional int64 m_id = 1;
inline bool db_account::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_account::has_m_id() const {
  return _internal_has_m_id();
}
inline void db_account::clear_m_id() {
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t db_account::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int64_t db_account::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.db_account.m_id)
  return _internal_m_id();
}
inline void db_account::_internal_set_m_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.m_id_ = value;
}
inline void db_account::set_m_id(int64_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.db_account.m_id)
}

// optional int64 m_roleid = 2;
inline bool db_account::_internal_has_m_roleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool db_account::has_m_roleid() const {
  return _internal_has_m_roleid();
}
inline void db_account::clear_m_roleid() {
  _impl_.m_roleid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t db_account::_internal_m_roleid() const {
  return _impl_.m_roleid_;
}
inline int64_t db_account::m_roleid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_account.m_roleid)
  return _internal_m_roleid();
}
inline void db_account::_internal_set_m_roleid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.m_roleid_ = value;
}
inline void db_account::set_m_roleid(int64_t value) {
  _internal_set_m_roleid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_account.m_roleid)
}

// optional string m_account = 3;
inline bool db_account::_internal_has_m_account() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_account::has_m_account() const {
  return _internal_has_m_account();
}
inline void db_account::clear_m_account() {
  _impl_.m_account_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& db_account::m_account() const {
  // @@protoc_insertion_point(field_get:pbdb.db_account.m_account)
  return _internal_m_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void db_account::set_m_account(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.m_account_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.db_account.m_account)
}
inline std::string* db_account::mutable_m_account() {
  std::string* _s = _internal_mutable_m_account();
  // @@protoc_insertion_point(field_mutable:pbdb.db_account.m_account)
  return _s;
}
inline const std::string& db_account::_internal_m_account() const {
  return _impl_.m_account_.Get();
}
inline void db_account::_internal_set_m_account(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_account_.Set(value, GetArenaForAllocation());
}
inline std::string* db_account::_internal_mutable_m_account() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.m_account_.Mutable(GetArenaForAllocation());
}
inline std::string* db_account::release_m_account() {
  // @@protoc_insertion_point(field_release:pbdb.db_account.m_account)
  if (!_internal_has_m_account()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.m_account_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_account_.IsDefault()) {
    _impl_.m_account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void db_account::set_allocated_m_account(std::string* m_account) {
  if (m_account != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.m_account_.SetAllocated(m_account, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_account_.IsDefault()) {
    _impl_.m_account_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_account.m_account)
}

// optional string m_passworld = 4;
inline bool db_account::_internal_has_m_passworld() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_account::has_m_passworld() const {
  return _internal_has_m_passworld();
}
inline void db_account::clear_m_passworld() {
  _impl_.m_passworld_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& db_account::m_passworld() const {
  // @@protoc_insertion_point(field_get:pbdb.db_account.m_passworld)
  return _internal_m_passworld();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void db_account::set_m_passworld(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.m_passworld_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.db_account.m_passworld)
}
inline std::string* db_account::mutable_m_passworld() {
  std::string* _s = _internal_mutable_m_passworld();
  // @@protoc_insertion_point(field_mutable:pbdb.db_account.m_passworld)
  return _s;
}
inline const std::string& db_account::_internal_m_passworld() const {
  return _impl_.m_passworld_.Get();
}
inline void db_account::_internal_set_m_passworld(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_passworld_.Set(value, GetArenaForAllocation());
}
inline std::string* db_account::_internal_mutable_m_passworld() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.m_passworld_.Mutable(GetArenaForAllocation());
}
inline std::string* db_account::release_m_passworld() {
  // @@protoc_insertion_point(field_release:pbdb.db_account.m_passworld)
  if (!_internal_has_m_passworld()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.m_passworld_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_passworld_.IsDefault()) {
    _impl_.m_passworld_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void db_account::set_allocated_m_passworld(std::string* m_passworld) {
  if (m_passworld != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.m_passworld_.SetAllocated(m_passworld, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_passworld_.IsDefault()) {
    _impl_.m_passworld_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_account.m_passworld)
}

// optional int32 m_area = 5;
inline bool db_account::_internal_has_m_area() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool db_account::has_m_area() const {
  return _internal_has_m_area();
}
inline void db_account::clear_m_area() {
  _impl_.m_area_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t db_account::_internal_m_area() const {
  return _impl_.m_area_;
}
inline int32_t db_account::m_area() const {
  // @@protoc_insertion_point(field_get:pbdb.db_account.m_area)
  return _internal_m_area();
}
inline void db_account::_internal_set_m_area(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.m_area_ = value;
}
inline void db_account::set_m_area(int32_t value) {
  _internal_set_m_area(value);
  // @@protoc_insertion_point(field_set:pbdb.db_account.m_area)
}

// -------------------------------------------------------------------

// db_brief

// optional int64 m_id = 1;
inline bool db_brief::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_brief::has_m_id() const {
  return _internal_has_m_id();
}
inline void db_brief::clear_m_id() {
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t db_brief::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int64_t db_brief::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.m_id)
  return _internal_m_id();
}
inline void db_brief::_internal_set_m_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_id_ = value;
}
inline void db_brief::set_m_id(int64_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.db_brief.m_id)
}

// optional string m_name = 2;
inline bool db_brief::_internal_has_m_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_brief::has_m_name() const {
  return _internal_has_m_name();
}
inline void db_brief::clear_m_name() {
  _impl_.m_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& db_brief::m_name() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.m_name)
  return _internal_m_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void db_brief::set_m_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.m_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.db_brief.m_name)
}
inline std::string* db_brief::mutable_m_name() {
  std::string* _s = _internal_mutable_m_name();
  // @@protoc_insertion_point(field_mutable:pbdb.db_brief.m_name)
  return _s;
}
inline const std::string& db_brief::_internal_m_name() const {
  return _impl_.m_name_.Get();
}
inline void db_brief::_internal_set_m_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_name_.Set(value, GetArenaForAllocation());
}
inline std::string* db_brief::_internal_mutable_m_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.m_name_.Mutable(GetArenaForAllocation());
}
inline std::string* db_brief::release_m_name() {
  // @@protoc_insertion_point(field_release:pbdb.db_brief.m_name)
  if (!_internal_has_m_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.m_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_name_.IsDefault()) {
    _impl_.m_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void db_brief::set_allocated_m_name(std::string* m_name) {
  if (m_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.m_name_.SetAllocated(m_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_name_.IsDefault()) {
    _impl_.m_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_brief.m_name)
}

// optional int32 m_lv = 3;
inline bool db_brief::_internal_has_m_lv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_brief::has_m_lv() const {
  return _internal_has_m_lv();
}
inline void db_brief::clear_m_lv() {
  _impl_.m_lv_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t db_brief::_internal_m_lv() const {
  return _impl_.m_lv_;
}
inline int32_t db_brief::m_lv() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.m_lv)
  return _internal_m_lv();
}
inline void db_brief::_internal_set_m_lv(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.m_lv_ = value;
}
inline void db_brief::set_m_lv(int32_t value) {
  _internal_set_m_lv(value);
  // @@protoc_insertion_point(field_set:pbdb.db_brief.m_lv)
}

// optional int32 m_moneygold = 4;
inline bool db_brief::_internal_has_m_moneygold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool db_brief::has_m_moneygold() const {
  return _internal_has_m_moneygold();
}
inline void db_brief::clear_m_moneygold() {
  _impl_.m_moneygold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t db_brief::_internal_m_moneygold() const {
  return _impl_.m_moneygold_;
}
inline int32_t db_brief::m_moneygold() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.m_moneygold)
  return _internal_m_moneygold();
}
inline void db_brief::_internal_set_m_moneygold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.m_moneygold_ = value;
}
inline void db_brief::set_m_moneygold(int32_t value) {
  _internal_set_m_moneygold(value);
  // @@protoc_insertion_point(field_set:pbdb.db_brief.m_moneygold)
}

// optional int32 m_moneysilver = 5;
inline bool db_brief::_internal_has_m_moneysilver() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool db_brief::has_m_moneysilver() const {
  return _internal_has_m_moneysilver();
}
inline void db_brief::clear_m_moneysilver() {
  _impl_.m_moneysilver_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t db_brief::_internal_m_moneysilver() const {
  return _impl_.m_moneysilver_;
}
inline int32_t db_brief::m_moneysilver() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.m_moneysilver)
  return _internal_m_moneysilver();
}
inline void db_brief::_internal_set_m_moneysilver(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.m_moneysilver_ = value;
}
inline void db_brief::set_m_moneysilver(int32_t value) {
  _internal_set_m_moneysilver(value);
  // @@protoc_insertion_point(field_set:pbdb.db_brief.m_moneysilver)
}

// optional int32 m_vip = 6;
inline bool db_brief::_internal_has_m_vip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool db_brief::has_m_vip() const {
  return _internal_has_m_vip();
}
inline void db_brief::clear_m_vip() {
  _impl_.m_vip_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t db_brief::_internal_m_vip() const {
  return _impl_.m_vip_;
}
inline int32_t db_brief::m_vip() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.m_vip)
  return _internal_m_vip();
}
inline void db_brief::_internal_set_m_vip(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.m_vip_ = value;
}
inline void db_brief::set_m_vip(int32_t value) {
  _internal_set_m_vip(value);
  // @@protoc_insertion_point(field_set:pbdb.db_brief.m_vip)
}

// optional int32 m_notalkutc = 7;
inline bool db_brief::_internal_has_m_notalkutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool db_brief::has_m_notalkutc() const {
  return _internal_has_m_notalkutc();
}
inline void db_brief::clear_m_notalkutc() {
  _impl_.m_notalkutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t db_brief::_internal_m_notalkutc() const {
  return _impl_.m_notalkutc_;
}
inline int32_t db_brief::m_notalkutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.m_notalkutc)
  return _internal_m_notalkutc();
}
inline void db_brief::_internal_set_m_notalkutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.m_notalkutc_ = value;
}
inline void db_brief::set_m_notalkutc(int32_t value) {
  _internal_set_m_notalkutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_brief.m_notalkutc)
}

// optional int32 m_createutc = 8;
inline bool db_brief::_internal_has_m_createutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool db_brief::has_m_createutc() const {
  return _internal_has_m_createutc();
}
inline void db_brief::clear_m_createutc() {
  _impl_.m_createutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t db_brief::_internal_m_createutc() const {
  return _impl_.m_createutc_;
}
inline int32_t db_brief::m_createutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.m_createutc)
  return _internal_m_createutc();
}
inline void db_brief::_internal_set_m_createutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.m_createutc_ = value;
}
inline void db_brief::set_m_createutc(int32_t value) {
  _internal_set_m_createutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_brief.m_createutc)
}

// -------------------------------------------------------------------

// db_role_recharge

// optional int32 m_rechargeid = 1;
inline bool db_role_recharge::_internal_has_m_rechargeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_role_recharge::has_m_rechargeid() const {
  return _internal_has_m_rechargeid();
}
inline void db_role_recharge::clear_m_rechargeid() {
  _impl_.m_rechargeid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t db_role_recharge::_internal_m_rechargeid() const {
  return _impl_.m_rechargeid_;
}
inline int32_t db_role_recharge::m_rechargeid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_role.recharge.m_rechargeid)
  return _internal_m_rechargeid();
}
inline void db_role_recharge::_internal_set_m_rechargeid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_rechargeid_ = value;
}
inline void db_role_recharge::set_m_rechargeid(int32_t value) {
  _internal_set_m_rechargeid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_role.recharge.m_rechargeid)
}

// optional int32 m_utc = 2;
inline bool db_role_recharge::_internal_has_m_utc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_role_recharge::has_m_utc() const {
  return _internal_has_m_utc();
}
inline void db_role_recharge::clear_m_utc() {
  _impl_.m_utc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t db_role_recharge::_internal_m_utc() const {
  return _impl_.m_utc_;
}
inline int32_t db_role_recharge::m_utc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_role.recharge.m_utc)
  return _internal_m_utc();
}
inline void db_role_recharge::_internal_set_m_utc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_utc_ = value;
}
inline void db_role_recharge::set_m_utc(int32_t value) {
  _internal_set_m_utc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_role.recharge.m_utc)
}

// -------------------------------------------------------------------

// db_role

// optional int64 m_id = 1;
inline bool db_role::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_role::has_m_id() const {
  return _internal_has_m_id();
}
inline void db_role::clear_m_id() {
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t db_role::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int64_t db_role::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.db_role.m_id)
  return _internal_m_id();
}
inline void db_role::_internal_set_m_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_id_ = value;
}
inline void db_role::set_m_id(int64_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.db_role.m_id)
}

// optional .pbdb.db_brief m_base = 2;
inline bool db_role::_internal_has_m_base() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.m_base_ != nullptr);
  return value;
}
inline bool db_role::has_m_base() const {
  return _internal_has_m_base();
}
inline void db_role::clear_m_base() {
  if (_impl_.m_base_ != nullptr) _impl_.m_base_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::pbdb::db_brief& db_role::_internal_m_base() const {
  const ::pbdb::db_brief* p = _impl_.m_base_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbdb::db_brief&>(
      ::pbdb::_db_brief_default_instance_);
}
inline const ::pbdb::db_brief& db_role::m_base() const {
  // @@protoc_insertion_point(field_get:pbdb.db_role.m_base)
  return _internal_m_base();
}
inline void db_role::unsafe_arena_set_allocated_m_base(
    ::pbdb::db_brief* m_base) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.m_base_);
  }
  _impl_.m_base_ = m_base;
  if (m_base) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbdb.db_role.m_base)
}
inline ::pbdb::db_brief* db_role::release_m_base() {
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pbdb::db_brief* temp = _impl_.m_base_;
  _impl_.m_base_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbdb::db_brief* db_role::unsafe_arena_release_m_base() {
  // @@protoc_insertion_point(field_release:pbdb.db_role.m_base)
  _impl_._has_bits_[0] &= ~0x00000001u;
  ::pbdb::db_brief* temp = _impl_.m_base_;
  _impl_.m_base_ = nullptr;
  return temp;
}
inline ::pbdb::db_brief* db_role::_internal_mutable_m_base() {
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.m_base_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbdb::db_brief>(GetArenaForAllocation());
    _impl_.m_base_ = p;
  }
  return _impl_.m_base_;
}
inline ::pbdb::db_brief* db_role::mutable_m_base() {
  ::pbdb::db_brief* _msg = _internal_mutable_m_base();
  // @@protoc_insertion_point(field_mutable:pbdb.db_role.m_base)
  return _msg;
}
inline void db_role::set_allocated_m_base(::pbdb::db_brief* m_base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.m_base_;
  }
  if (m_base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(m_base);
    if (message_arena != submessage_arena) {
      m_base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, m_base, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.m_base_ = m_base;
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_role.m_base)
}

// repeated .pbdb.db_role.recharge m_recharge = 3;
inline int db_role::_internal_m_recharge_size() const {
  return _impl_.m_recharge_.size();
}
inline int db_role::m_recharge_size() const {
  return _internal_m_recharge_size();
}
inline void db_role::clear_m_recharge() {
  _impl_.m_recharge_.Clear();
}
inline ::pbdb::db_role_recharge* db_role::mutable_m_recharge(int index) {
  // @@protoc_insertion_point(field_mutable:pbdb.db_role.m_recharge)
  return _impl_.m_recharge_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_role_recharge >*
db_role::mutable_m_recharge() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.db_role.m_recharge)
  return &_impl_.m_recharge_;
}
inline const ::pbdb::db_role_recharge& db_role::_internal_m_recharge(int index) const {
  return _impl_.m_recharge_.Get(index);
}
inline const ::pbdb::db_role_recharge& db_role::m_recharge(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.db_role.m_recharge)
  return _internal_m_recharge(index);
}
inline ::pbdb::db_role_recharge* db_role::_internal_add_m_recharge() {
  return _impl_.m_recharge_.Add();
}
inline ::pbdb::db_role_recharge* db_role::add_m_recharge() {
  ::pbdb::db_role_recharge* _add = _internal_add_m_recharge();
  // @@protoc_insertion_point(field_add:pbdb.db_role.m_recharge)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_role_recharge >&
db_role::m_recharge() const {
  // @@protoc_insertion_point(field_list:pbdb.db_role.m_recharge)
  return _impl_.m_recharge_;
}

// -------------------------------------------------------------------

// item

// optional int32 m_id = 1;
inline bool item::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool item::has_m_id() const {
  return _internal_has_m_id();
}
inline void item::clear_m_id() {
  _impl_.m_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t item::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int32_t item::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.item.m_id)
  return _internal_m_id();
}
inline void item::_internal_set_m_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_id_ = value;
}
inline void item::set_m_id(int32_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.item.m_id)
}

// optional int32 m_tid = 2;
inline bool item::_internal_has_m_tid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool item::has_m_tid() const {
  return _internal_has_m_tid();
}
inline void item::clear_m_tid() {
  _impl_.m_tid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t item::_internal_m_tid() const {
  return _impl_.m_tid_;
}
inline int32_t item::m_tid() const {
  // @@protoc_insertion_point(field_get:pbdb.item.m_tid)
  return _internal_m_tid();
}
inline void item::_internal_set_m_tid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_tid_ = value;
}
inline void item::set_m_tid(int32_t value) {
  _internal_set_m_tid(value);
  // @@protoc_insertion_point(field_set:pbdb.item.m_tid)
}

// optional int32 m_count = 3;
inline bool item::_internal_has_m_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool item::has_m_count() const {
  return _internal_has_m_count();
}
inline void item::clear_m_count() {
  _impl_.m_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t item::_internal_m_count() const {
  return _impl_.m_count_;
}
inline int32_t item::m_count() const {
  // @@protoc_insertion_point(field_get:pbdb.item.m_count)
  return _internal_m_count();
}
inline void item::_internal_set_m_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.m_count_ = value;
}
inline void item::set_m_count(int32_t value) {
  _internal_set_m_count(value);
  // @@protoc_insertion_point(field_set:pbdb.item.m_count)
}

// optional int32 m_lv = 4;
inline bool item::_internal_has_m_lv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool item::has_m_lv() const {
  return _internal_has_m_lv();
}
inline void item::clear_m_lv() {
  _impl_.m_lv_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t item::_internal_m_lv() const {
  return _impl_.m_lv_;
}
inline int32_t item::m_lv() const {
  // @@protoc_insertion_point(field_get:pbdb.item.m_lv)
  return _internal_m_lv();
}
inline void item::_internal_set_m_lv(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.m_lv_ = value;
}
inline void item::set_m_lv(int32_t value) {
  _internal_set_m_lv(value);
  // @@protoc_insertion_point(field_set:pbdb.item.m_lv)
}

// optional int32 m_star = 5;
inline bool item::_internal_has_m_star() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool item::has_m_star() const {
  return _internal_has_m_star();
}
inline void item::clear_m_star() {
  _impl_.m_star_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t item::_internal_m_star() const {
  return _impl_.m_star_;
}
inline int32_t item::m_star() const {
  // @@protoc_insertion_point(field_get:pbdb.item.m_star)
  return _internal_m_star();
}
inline void item::_internal_set_m_star(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.m_star_ = value;
}
inline void item::set_m_star(int32_t value) {
  _internal_set_m_star(value);
  // @@protoc_insertion_point(field_set:pbdb.item.m_star)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// db_bag

// optional int64 m_id = 1;
inline bool db_bag::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_bag::has_m_id() const {
  return _internal_has_m_id();
}
inline void db_bag::clear_m_id() {
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_bag::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int64_t db_bag::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.db_bag.m_id)
  return _internal_m_id();
}
inline void db_bag::_internal_set_m_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_id_ = value;
}
inline void db_bag::set_m_id(int64_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.db_bag.m_id)
}

// map<int32, .pbdb.item> m_items = 2;
inline int db_bag::_internal_m_items_size() const {
  return _impl_.m_items_.size();
}
inline int db_bag::m_items_size() const {
  return _internal_m_items_size();
}
inline void db_bag::clear_m_items() {
  _impl_.m_items_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >&
db_bag::_internal_m_items() const {
  return _impl_.m_items_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >&
db_bag::m_items() const {
  // @@protoc_insertion_point(field_map:pbdb.db_bag.m_items)
  return _internal_m_items();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >*
db_bag::_internal_mutable_m_items() {
  return _impl_.m_items_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >*
db_bag::mutable_m_items() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_bag.m_items)
  return _internal_mutable_m_items();
}

// optional int32 m_maxid = 3;
inline bool db_bag::_internal_has_m_maxid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_bag::has_m_maxid() const {
  return _internal_has_m_maxid();
}
inline void db_bag::clear_m_maxid() {
  _impl_.m_maxid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t db_bag::_internal_m_maxid() const {
  return _impl_.m_maxid_;
}
inline int32_t db_bag::m_maxid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_bag.m_maxid)
  return _internal_m_maxid();
}
inline void db_bag::_internal_set_m_maxid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_maxid_ = value;
}
inline void db_bag::set_m_maxid(int32_t value) {
  _internal_set_m_maxid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_bag.m_maxid)
}

// -------------------------------------------------------------------

// db_keyvalue

// optional int64 m_id = 1;
inline bool db_keyvalue::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_keyvalue::has_m_id() const {
  return _internal_has_m_id();
}
inline void db_keyvalue::clear_m_id() {
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t db_keyvalue::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int64_t db_keyvalue::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.db_keyvalue.m_id)
  return _internal_m_id();
}
inline void db_keyvalue::_internal_set_m_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_id_ = value;
}
inline void db_keyvalue::set_m_id(int64_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.db_keyvalue.m_id)
}

// optional string m_value = 2;
inline bool db_keyvalue::_internal_has_m_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_keyvalue::has_m_value() const {
  return _internal_has_m_value();
}
inline void db_keyvalue::clear_m_value() {
  _impl_.m_value_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& db_keyvalue::m_value() const {
  // @@protoc_insertion_point(field_get:pbdb.db_keyvalue.m_value)
  return _internal_m_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void db_keyvalue::set_m_value(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.m_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.db_keyvalue.m_value)
}
inline std::string* db_keyvalue::mutable_m_value() {
  std::string* _s = _internal_mutable_m_value();
  // @@protoc_insertion_point(field_mutable:pbdb.db_keyvalue.m_value)
  return _s;
}
inline const std::string& db_keyvalue::_internal_m_value() const {
  return _impl_.m_value_.Get();
}
inline void db_keyvalue::_internal_set_m_value(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_value_.Set(value, GetArenaForAllocation());
}
inline std::string* db_keyvalue::_internal_mutable_m_value() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.m_value_.Mutable(GetArenaForAllocation());
}
inline std::string* db_keyvalue::release_m_value() {
  // @@protoc_insertion_point(field_release:pbdb.db_keyvalue.m_value)
  if (!_internal_has_m_value()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.m_value_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_value_.IsDefault()) {
    _impl_.m_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void db_keyvalue::set_allocated_m_value(std::string* m_value) {
  if (m_value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.m_value_.SetAllocated(m_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_value_.IsDefault()) {
    _impl_.m_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_keyvalue.m_value)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// db_rolekeyvalue

// optional int64 m_id = 1;
inline bool db_rolekeyvalue::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_rolekeyvalue::has_m_id() const {
  return _internal_has_m_id();
}
inline void db_rolekeyvalue::clear_m_id() {
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_rolekeyvalue::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int64_t db_rolekeyvalue::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.db_rolekeyvalue.m_id)
  return _internal_m_id();
}
inline void db_rolekeyvalue::_internal_set_m_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_id_ = value;
}
inline void db_rolekeyvalue::set_m_id(int64_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.db_rolekeyvalue.m_id)
}

// map<string, string> m_data = 2;
inline int db_rolekeyvalue::_internal_m_data_size() const {
  return _impl_.m_data_.size();
}
inline int db_rolekeyvalue::m_data_size() const {
  return _internal_m_data_size();
}
inline void db_rolekeyvalue::clear_m_data() {
  _impl_.m_data_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
db_rolekeyvalue::_internal_m_data() const {
  return _impl_.m_data_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
db_rolekeyvalue::m_data() const {
  // @@protoc_insertion_point(field_map:pbdb.db_rolekeyvalue.m_data)
  return _internal_m_data();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
db_rolekeyvalue::_internal_mutable_m_data() {
  return _impl_.m_data_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
db_rolekeyvalue::mutable_m_data() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_rolekeyvalue.m_data)
  return _internal_mutable_m_data();
}

// -------------------------------------------------------------------

// mailitem

// optional int32 m_itemtid = 1;
inline bool mailitem::_internal_has_m_itemtid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool mailitem::has_m_itemtid() const {
  return _internal_has_m_itemtid();
}
inline void mailitem::clear_m_itemtid() {
  _impl_.m_itemtid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t mailitem::_internal_m_itemtid() const {
  return _impl_.m_itemtid_;
}
inline int32_t mailitem::m_itemtid() const {
  // @@protoc_insertion_point(field_get:pbdb.mailitem.m_itemtid)
  return _internal_m_itemtid();
}
inline void mailitem::_internal_set_m_itemtid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_itemtid_ = value;
}
inline void mailitem::set_m_itemtid(int32_t value) {
  _internal_set_m_itemtid(value);
  // @@protoc_insertion_point(field_set:pbdb.mailitem.m_itemtid)
}

// optional int32 m_count = 2;
inline bool mailitem::_internal_has_m_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool mailitem::has_m_count() const {
  return _internal_has_m_count();
}
inline void mailitem::clear_m_count() {
  _impl_.m_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t mailitem::_internal_m_count() const {
  return _impl_.m_count_;
}
inline int32_t mailitem::m_count() const {
  // @@protoc_insertion_point(field_get:pbdb.mailitem.m_count)
  return _internal_m_count();
}
inline void mailitem::_internal_set_m_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_count_ = value;
}
inline void mailitem::set_m_count(int32_t value) {
  _internal_set_m_count(value);
  // @@protoc_insertion_point(field_set:pbdb.mailitem.m_count)
}

// -------------------------------------------------------------------

// mail

// optional int32 m_id = 1;
inline bool mail::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool mail::has_m_id() const {
  return _internal_has_m_id();
}
inline void mail::clear_m_id() {
  _impl_.m_id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t mail::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int32_t mail::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.mail.m_id)
  return _internal_m_id();
}
inline void mail::_internal_set_m_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.m_id_ = value;
}
inline void mail::set_m_id(int32_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.mail.m_id)
}

// optional int32 m_createutc = 2;
inline bool mail::_internal_has_m_createutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool mail::has_m_createutc() const {
  return _internal_has_m_createutc();
}
inline void mail::clear_m_createutc() {
  _impl_.m_createutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t mail::_internal_m_createutc() const {
  return _impl_.m_createutc_;
}
inline int32_t mail::m_createutc() const {
  // @@protoc_insertion_point(field_get:pbdb.mail.m_createutc)
  return _internal_m_createutc();
}
inline void mail::_internal_set_m_createutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.m_createutc_ = value;
}
inline void mail::set_m_createutc(int32_t value) {
  _internal_set_m_createutc(value);
  // @@protoc_insertion_point(field_set:pbdb.mail.m_createutc)
}

// optional int32 m_tid = 3;
inline bool mail::_internal_has_m_tid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool mail::has_m_tid() const {
  return _internal_has_m_tid();
}
inline void mail::clear_m_tid() {
  _impl_.m_tid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t mail::_internal_m_tid() const {
  return _impl_.m_tid_;
}
inline int32_t mail::m_tid() const {
  // @@protoc_insertion_point(field_get:pbdb.mail.m_tid)
  return _internal_m_tid();
}
inline void mail::_internal_set_m_tid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.m_tid_ = value;
}
inline void mail::set_m_tid(int32_t value) {
  _internal_set_m_tid(value);
  // @@protoc_insertion_point(field_set:pbdb.mail.m_tid)
}

// optional string m_prams = 4;
inline bool mail::_internal_has_m_prams() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool mail::has_m_prams() const {
  return _internal_has_m_prams();
}
inline void mail::clear_m_prams() {
  _impl_.m_prams_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& mail::m_prams() const {
  // @@protoc_insertion_point(field_get:pbdb.mail.m_prams)
  return _internal_m_prams();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void mail::set_m_prams(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.m_prams_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.mail.m_prams)
}
inline std::string* mail::mutable_m_prams() {
  std::string* _s = _internal_mutable_m_prams();
  // @@protoc_insertion_point(field_mutable:pbdb.mail.m_prams)
  return _s;
}
inline const std::string& mail::_internal_m_prams() const {
  return _impl_.m_prams_.Get();
}
inline void mail::_internal_set_m_prams(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_prams_.Set(value, GetArenaForAllocation());
}
inline std::string* mail::_internal_mutable_m_prams() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.m_prams_.Mutable(GetArenaForAllocation());
}
inline std::string* mail::release_m_prams() {
  // @@protoc_insertion_point(field_release:pbdb.mail.m_prams)
  if (!_internal_has_m_prams()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.m_prams_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_prams_.IsDefault()) {
    _impl_.m_prams_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void mail::set_allocated_m_prams(std::string* m_prams) {
  if (m_prams != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.m_prams_.SetAllocated(m_prams, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_prams_.IsDefault()) {
    _impl_.m_prams_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.mail.m_prams)
}

// optional string m_content = 5;
inline bool mail::_internal_has_m_content() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool mail::has_m_content() const {
  return _internal_has_m_content();
}
inline void mail::clear_m_content() {
  _impl_.m_content_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& mail::m_content() const {
  // @@protoc_insertion_point(field_get:pbdb.mail.m_content)
  return _internal_m_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void mail::set_m_content(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.m_content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.mail.m_content)
}
inline std::string* mail::mutable_m_content() {
  std::string* _s = _internal_mutable_m_content();
  // @@protoc_insertion_point(field_mutable:pbdb.mail.m_content)
  return _s;
}
inline const std::string& mail::_internal_m_content() const {
  return _impl_.m_content_.Get();
}
inline void mail::_internal_set_m_content(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_content_.Set(value, GetArenaForAllocation());
}
inline std::string* mail::_internal_mutable_m_content() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.m_content_.Mutable(GetArenaForAllocation());
}
inline std::string* mail::release_m_content() {
  // @@protoc_insertion_point(field_release:pbdb.mail.m_content)
  if (!_internal_has_m_content()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.m_content_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_content_.IsDefault()) {
    _impl_.m_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void mail::set_allocated_m_content(std::string* m_content) {
  if (m_content != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.m_content_.SetAllocated(m_content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_content_.IsDefault()) {
    _impl_.m_content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.mail.m_content)
}

// repeated .pbdb.mailitem m_items = 6;
inline int mail::_internal_m_items_size() const {
  return _impl_.m_items_.size();
}
inline int mail::m_items_size() const {
  return _internal_m_items_size();
}
inline void mail::clear_m_items() {
  _impl_.m_items_.Clear();
}
inline ::pbdb::mailitem* mail::mutable_m_items(int index) {
  // @@protoc_insertion_point(field_mutable:pbdb.mail.m_items)
  return _impl_.m_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::mailitem >*
mail::mutable_m_items() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.mail.m_items)
  return &_impl_.m_items_;
}
inline const ::pbdb::mailitem& mail::_internal_m_items(int index) const {
  return _impl_.m_items_.Get(index);
}
inline const ::pbdb::mailitem& mail::m_items(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.mail.m_items)
  return _internal_m_items(index);
}
inline ::pbdb::mailitem* mail::_internal_add_m_items() {
  return _impl_.m_items_.Add();
}
inline ::pbdb::mailitem* mail::add_m_items() {
  ::pbdb::mailitem* _add = _internal_add_m_items();
  // @@protoc_insertion_point(field_add:pbdb.mail.m_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::mailitem >&
mail::m_items() const {
  // @@protoc_insertion_point(field_list:pbdb.mail.m_items)
  return _impl_.m_items_;
}

// optional bool m_read = 7;
inline bool mail::_internal_has_m_read() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool mail::has_m_read() const {
  return _internal_has_m_read();
}
inline void mail::clear_m_read() {
  _impl_.m_read_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool mail::_internal_m_read() const {
  return _impl_.m_read_;
}
inline bool mail::m_read() const {
  // @@protoc_insertion_point(field_get:pbdb.mail.m_read)
  return _internal_m_read();
}
inline void mail::_internal_set_m_read(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.m_read_ = value;
}
inline void mail::set_m_read(bool value) {
  _internal_set_m_read(value);
  // @@protoc_insertion_point(field_set:pbdb.mail.m_read)
}

// optional bool m_draw = 8;
inline bool mail::_internal_has_m_draw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool mail::has_m_draw() const {
  return _internal_has_m_draw();
}
inline void mail::clear_m_draw() {
  _impl_.m_draw_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool mail::_internal_m_draw() const {
  return _impl_.m_draw_;
}
inline bool mail::m_draw() const {
  // @@protoc_insertion_point(field_get:pbdb.mail.m_draw)
  return _internal_m_draw();
}
inline void mail::_internal_set_m_draw(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.m_draw_ = value;
}
inline void mail::set_m_draw(bool value) {
  _internal_set_m_draw(value);
  // @@protoc_insertion_point(field_set:pbdb.mail.m_draw)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// db_mail

// optional int64 m_id = 1;
inline bool db_mail::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_mail::has_m_id() const {
  return _internal_has_m_id();
}
inline void db_mail::clear_m_id() {
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_mail::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int64_t db_mail::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.db_mail.m_id)
  return _internal_m_id();
}
inline void db_mail::_internal_set_m_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_id_ = value;
}
inline void db_mail::set_m_id(int64_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.db_mail.m_id)
}

// map<int32, .pbdb.mail> m_mail = 2;
inline int db_mail::_internal_m_mail_size() const {
  return _impl_.m_mail_.size();
}
inline int db_mail::m_mail_size() const {
  return _internal_m_mail_size();
}
inline void db_mail::clear_m_mail() {
  _impl_.m_mail_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >&
db_mail::_internal_m_mail() const {
  return _impl_.m_mail_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >&
db_mail::m_mail() const {
  // @@protoc_insertion_point(field_map:pbdb.db_mail.m_mail)
  return _internal_m_mail();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >*
db_mail::_internal_mutable_m_mail() {
  return _impl_.m_mail_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >*
db_mail::mutable_m_mail() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_mail.m_mail)
  return _internal_mutable_m_mail();
}

// -------------------------------------------------------------------

// db_guild

// optional int64 m_id = 1;
inline bool db_guild::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_guild::has_m_id() const {
  return _internal_has_m_id();
}
inline void db_guild::clear_m_id() {
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t db_guild::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int64_t db_guild::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.db_guild.m_id)
  return _internal_m_id();
}
inline void db_guild::_internal_set_m_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_id_ = value;
}
inline void db_guild::set_m_id(int64_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.db_guild.m_id)
}

// optional string m_guild = 2;
inline bool db_guild::_internal_has_m_guild() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_guild::has_m_guild() const {
  return _internal_has_m_guild();
}
inline void db_guild::clear_m_guild() {
  _impl_.m_guild_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& db_guild::m_guild() const {
  // @@protoc_insertion_point(field_get:pbdb.db_guild.m_guild)
  return _internal_m_guild();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void db_guild::set_m_guild(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.m_guild_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.db_guild.m_guild)
}
inline std::string* db_guild::mutable_m_guild() {
  std::string* _s = _internal_mutable_m_guild();
  // @@protoc_insertion_point(field_mutable:pbdb.db_guild.m_guild)
  return _s;
}
inline const std::string& db_guild::_internal_m_guild() const {
  return _impl_.m_guild_.Get();
}
inline void db_guild::_internal_set_m_guild(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_guild_.Set(value, GetArenaForAllocation());
}
inline std::string* db_guild::_internal_mutable_m_guild() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.m_guild_.Mutable(GetArenaForAllocation());
}
inline std::string* db_guild::release_m_guild() {
  // @@protoc_insertion_point(field_release:pbdb.db_guild.m_guild)
  if (!_internal_has_m_guild()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.m_guild_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_guild_.IsDefault()) {
    _impl_.m_guild_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void db_guild::set_allocated_m_guild(std::string* m_guild) {
  if (m_guild != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.m_guild_.SetAllocated(m_guild, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_guild_.IsDefault()) {
    _impl_.m_guild_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_guild.m_guild)
}

// optional int64 m_leader = 3;
inline bool db_guild::_internal_has_m_leader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_guild::has_m_leader() const {
  return _internal_has_m_leader();
}
inline void db_guild::clear_m_leader() {
  _impl_.m_leader_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t db_guild::_internal_m_leader() const {
  return _impl_.m_leader_;
}
inline int64_t db_guild::m_leader() const {
  // @@protoc_insertion_point(field_get:pbdb.db_guild.m_leader)
  return _internal_m_leader();
}
inline void db_guild::_internal_set_m_leader(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.m_leader_ = value;
}
inline void db_guild::set_m_leader(int64_t value) {
  _internal_set_m_leader(value);
  // @@protoc_insertion_point(field_set:pbdb.db_guild.m_leader)
}

// repeated int64 m_members = 4;
inline int db_guild::_internal_m_members_size() const {
  return _impl_.m_members_.size();
}
inline int db_guild::m_members_size() const {
  return _internal_m_members_size();
}
inline void db_guild::clear_m_members() {
  _impl_.m_members_.Clear();
}
inline int64_t db_guild::_internal_m_members(int index) const {
  return _impl_.m_members_.Get(index);
}
inline int64_t db_guild::m_members(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.db_guild.m_members)
  return _internal_m_members(index);
}
inline void db_guild::set_m_members(int index, int64_t value) {
  _impl_.m_members_.Set(index, value);
  // @@protoc_insertion_point(field_set:pbdb.db_guild.m_members)
}
inline void db_guild::_internal_add_m_members(int64_t value) {
  _impl_.m_members_.Add(value);
}
inline void db_guild::add_m_members(int64_t value) {
  _internal_add_m_members(value);
  // @@protoc_insertion_point(field_add:pbdb.db_guild.m_members)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_guild::_internal_m_members() const {
  return _impl_.m_members_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_guild::m_members() const {
  // @@protoc_insertion_point(field_list:pbdb.db_guild.m_members)
  return _internal_m_members();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_guild::_internal_mutable_m_members() {
  return &_impl_.m_members_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_guild::mutable_m_members() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.db_guild.m_members)
  return _internal_mutable_m_members();
}

// -------------------------------------------------------------------

// db_notice

// optional int64 m_id = 1;
inline bool db_notice::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_notice::has_m_id() const {
  return _internal_has_m_id();
}
inline void db_notice::clear_m_id() {
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t db_notice::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int64_t db_notice::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.db_notice.m_id)
  return _internal_m_id();
}
inline void db_notice::_internal_set_m_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_id_ = value;
}
inline void db_notice::set_m_id(int64_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.db_notice.m_id)
}

// optional string m_notice = 2;
inline bool db_notice::_internal_has_m_notice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_notice::has_m_notice() const {
  return _internal_has_m_notice();
}
inline void db_notice::clear_m_notice() {
  _impl_.m_notice_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& db_notice::m_notice() const {
  // @@protoc_insertion_point(field_get:pbdb.db_notice.m_notice)
  return _internal_m_notice();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void db_notice::set_m_notice(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.m_notice_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.db_notice.m_notice)
}
inline std::string* db_notice::mutable_m_notice() {
  std::string* _s = _internal_mutable_m_notice();
  // @@protoc_insertion_point(field_mutable:pbdb.db_notice.m_notice)
  return _s;
}
inline const std::string& db_notice::_internal_m_notice() const {
  return _impl_.m_notice_.Get();
}
inline void db_notice::_internal_set_m_notice(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_notice_.Set(value, GetArenaForAllocation());
}
inline std::string* db_notice::_internal_mutable_m_notice() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.m_notice_.Mutable(GetArenaForAllocation());
}
inline std::string* db_notice::release_m_notice() {
  // @@protoc_insertion_point(field_release:pbdb.db_notice.m_notice)
  if (!_internal_has_m_notice()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.m_notice_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_notice_.IsDefault()) {
    _impl_.m_notice_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void db_notice::set_allocated_m_notice(std::string* m_notice) {
  if (m_notice != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.m_notice_.SetAllocated(m_notice, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_notice_.IsDefault()) {
    _impl_.m_notice_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_notice.m_notice)
}

// optional int32 m_starttime = 3;
inline bool db_notice::_internal_has_m_starttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_notice::has_m_starttime() const {
  return _internal_has_m_starttime();
}
inline void db_notice::clear_m_starttime() {
  _impl_.m_starttime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t db_notice::_internal_m_starttime() const {
  return _impl_.m_starttime_;
}
inline int32_t db_notice::m_starttime() const {
  // @@protoc_insertion_point(field_get:pbdb.db_notice.m_starttime)
  return _internal_m_starttime();
}
inline void db_notice::_internal_set_m_starttime(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.m_starttime_ = value;
}
inline void db_notice::set_m_starttime(int32_t value) {
  _internal_set_m_starttime(value);
  // @@protoc_insertion_point(field_set:pbdb.db_notice.m_starttime)
}

// optional int32 m_finishtime = 4;
inline bool db_notice::_internal_has_m_finishtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool db_notice::has_m_finishtime() const {
  return _internal_has_m_finishtime();
}
inline void db_notice::clear_m_finishtime() {
  _impl_.m_finishtime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t db_notice::_internal_m_finishtime() const {
  return _impl_.m_finishtime_;
}
inline int32_t db_notice::m_finishtime() const {
  // @@protoc_insertion_point(field_get:pbdb.db_notice.m_finishtime)
  return _internal_m_finishtime();
}
inline void db_notice::_internal_set_m_finishtime(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.m_finishtime_ = value;
}
inline void db_notice::set_m_finishtime(int32_t value) {
  _internal_set_m_finishtime(value);
  // @@protoc_insertion_point(field_set:pbdb.db_notice.m_finishtime)
}

// -------------------------------------------------------------------

// rankitem

// optional int64 m_value = 1;
inline bool rankitem::_internal_has_m_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool rankitem::has_m_value() const {
  return _internal_has_m_value();
}
inline void rankitem::clear_m_value() {
  _impl_.m_value_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t rankitem::_internal_m_value() const {
  return _impl_.m_value_;
}
inline int64_t rankitem::m_value() const {
  // @@protoc_insertion_point(field_get:pbdb.rankitem.m_value)
  return _internal_m_value();
}
inline void rankitem::_internal_set_m_value(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_value_ = value;
}
inline void rankitem::set_m_value(int64_t value) {
  _internal_set_m_value(value);
  // @@protoc_insertion_point(field_set:pbdb.rankitem.m_value)
}

// optional int32 m_time = 2;
inline bool rankitem::_internal_has_m_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool rankitem::has_m_time() const {
  return _internal_has_m_time();
}
inline void rankitem::clear_m_time() {
  _impl_.m_time_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t rankitem::_internal_m_time() const {
  return _impl_.m_time_;
}
inline int32_t rankitem::m_time() const {
  // @@protoc_insertion_point(field_get:pbdb.rankitem.m_time)
  return _internal_m_time();
}
inline void rankitem::_internal_set_m_time(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_time_ = value;
}
inline void rankitem::set_m_time(int32_t value) {
  _internal_set_m_time(value);
  // @@protoc_insertion_point(field_set:pbdb.rankitem.m_time)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// db_ranklist

// optional int64 m_id = 1;
inline bool db_ranklist::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_ranklist::has_m_id() const {
  return _internal_has_m_id();
}
inline void db_ranklist::clear_m_id() {
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_ranklist::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int64_t db_ranklist::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.db_ranklist.m_id)
  return _internal_m_id();
}
inline void db_ranklist::_internal_set_m_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_id_ = value;
}
inline void db_ranklist::set_m_id(int64_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.db_ranklist.m_id)
}

// map<int32, .pbdb.rankitem> m_items = 2;
inline int db_ranklist::_internal_m_items_size() const {
  return _impl_.m_items_.size();
}
inline int db_ranklist::m_items_size() const {
  return _internal_m_items_size();
}
inline void db_ranklist::clear_m_items() {
  _impl_.m_items_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >&
db_ranklist::_internal_m_items() const {
  return _impl_.m_items_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >&
db_ranklist::m_items() const {
  // @@protoc_insertion_point(field_map:pbdb.db_ranklist.m_items)
  return _internal_m_items();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >*
db_ranklist::_internal_mutable_m_items() {
  return _impl_.m_items_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >*
db_ranklist::mutable_m_items() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_ranklist.m_items)
  return _internal_mutable_m_items();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// db_activity_drawcompliance

// optional int32 m_count = 1;
inline bool db_activity_drawcompliance::_internal_has_m_count() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_activity_drawcompliance::has_m_count() const {
  return _internal_has_m_count();
}
inline void db_activity_drawcompliance::clear_m_count() {
  _impl_.m_count_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t db_activity_drawcompliance::_internal_m_count() const {
  return _impl_.m_count_;
}
inline int32_t db_activity_drawcompliance::m_count() const {
  // @@protoc_insertion_point(field_get:pbdb.db_activity.drawcompliance.m_count)
  return _internal_m_count();
}
inline void db_activity_drawcompliance::_internal_set_m_count(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_count_ = value;
}
inline void db_activity_drawcompliance::set_m_count(int32_t value) {
  _internal_set_m_count(value);
  // @@protoc_insertion_point(field_set:pbdb.db_activity.drawcompliance.m_count)
}

// map<int32, bool> m_reward = 2;
inline int db_activity_drawcompliance::_internal_m_reward_size() const {
  return _impl_.m_reward_.size();
}
inline int db_activity_drawcompliance::m_reward_size() const {
  return _internal_m_reward_size();
}
inline void db_activity_drawcompliance::clear_m_reward() {
  _impl_.m_reward_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >&
db_activity_drawcompliance::_internal_m_reward() const {
  return _impl_.m_reward_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >&
db_activity_drawcompliance::m_reward() const {
  // @@protoc_insertion_point(field_map:pbdb.db_activity.drawcompliance.m_reward)
  return _internal_m_reward();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >*
db_activity_drawcompliance::_internal_mutable_m_reward() {
  return _impl_.m_reward_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >*
db_activity_drawcompliance::mutable_m_reward() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_activity.drawcompliance.m_reward)
  return _internal_mutable_m_reward();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// db_activity

// optional int64 m_id = 1;
inline bool db_activity::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_activity::has_m_id() const {
  return _internal_has_m_id();
}
inline void db_activity::clear_m_id() {
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_activity::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int64_t db_activity::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.db_activity.m_id)
  return _internal_m_id();
}
inline void db_activity::_internal_set_m_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_id_ = value;
}
inline void db_activity::set_m_id(int64_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.db_activity.m_id)
}

// optional int32 m_beg = 2;
inline bool db_activity::_internal_has_m_beg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_activity::has_m_beg() const {
  return _internal_has_m_beg();
}
inline void db_activity::clear_m_beg() {
  _impl_.m_beg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t db_activity::_internal_m_beg() const {
  return _impl_.m_beg_;
}
inline int32_t db_activity::m_beg() const {
  // @@protoc_insertion_point(field_get:pbdb.db_activity.m_beg)
  return _internal_m_beg();
}
inline void db_activity::_internal_set_m_beg(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_beg_ = value;
}
inline void db_activity::set_m_beg(int32_t value) {
  _internal_set_m_beg(value);
  // @@protoc_insertion_point(field_set:pbdb.db_activity.m_beg)
}

// optional int32 m_end = 3;
inline bool db_activity::_internal_has_m_end() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_activity::has_m_end() const {
  return _internal_has_m_end();
}
inline void db_activity::clear_m_end() {
  _impl_.m_end_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t db_activity::_internal_m_end() const {
  return _impl_.m_end_;
}
inline int32_t db_activity::m_end() const {
  // @@protoc_insertion_point(field_get:pbdb.db_activity.m_end)
  return _internal_m_end();
}
inline void db_activity::_internal_set_m_end(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.m_end_ = value;
}
inline void db_activity::set_m_end(int32_t value) {
  _internal_set_m_end(value);
  // @@protoc_insertion_point(field_set:pbdb.db_activity.m_end)
}

// optional bool m_start = 4;
inline bool db_activity::_internal_has_m_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool db_activity::has_m_start() const {
  return _internal_has_m_start();
}
inline void db_activity::clear_m_start() {
  _impl_.m_start_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool db_activity::_internal_m_start() const {
  return _impl_.m_start_;
}
inline bool db_activity::m_start() const {
  // @@protoc_insertion_point(field_get:pbdb.db_activity.m_start)
  return _internal_m_start();
}
inline void db_activity::_internal_set_m_start(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.m_start_ = value;
}
inline void db_activity::set_m_start(bool value) {
  _internal_set_m_start(value);
  // @@protoc_insertion_point(field_set:pbdb.db_activity.m_start)
}

// optional bool m_finish = 5;
inline bool db_activity::_internal_has_m_finish() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool db_activity::has_m_finish() const {
  return _internal_has_m_finish();
}
inline void db_activity::clear_m_finish() {
  _impl_.m_finish_ = false;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline bool db_activity::_internal_m_finish() const {
  return _impl_.m_finish_;
}
inline bool db_activity::m_finish() const {
  // @@protoc_insertion_point(field_get:pbdb.db_activity.m_finish)
  return _internal_m_finish();
}
inline void db_activity::_internal_set_m_finish(bool value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.m_finish_ = value;
}
inline void db_activity::set_m_finish(bool value) {
  _internal_set_m_finish(value);
  // @@protoc_insertion_point(field_set:pbdb.db_activity.m_finish)
}

// optional int32 m_calendarid = 6;
inline bool db_activity::_internal_has_m_calendarid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool db_activity::has_m_calendarid() const {
  return _internal_has_m_calendarid();
}
inline void db_activity::clear_m_calendarid() {
  _impl_.m_calendarid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t db_activity::_internal_m_calendarid() const {
  return _impl_.m_calendarid_;
}
inline int32_t db_activity::m_calendarid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_activity.m_calendarid)
  return _internal_m_calendarid();
}
inline void db_activity::_internal_set_m_calendarid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.m_calendarid_ = value;
}
inline void db_activity::set_m_calendarid(int32_t value) {
  _internal_set_m_calendarid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_activity.m_calendarid)
}

// map<int64, .pbdb.db_activity.drawcompliance> m_drawcompliance = 7;
inline int db_activity::_internal_m_drawcompliance_size() const {
  return _impl_.m_drawcompliance_.size();
}
inline int db_activity::m_drawcompliance_size() const {
  return _internal_m_drawcompliance_size();
}
inline void db_activity::clear_m_drawcompliance() {
  _impl_.m_drawcompliance_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::db_activity_drawcompliance >&
db_activity::_internal_m_drawcompliance() const {
  return _impl_.m_drawcompliance_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::db_activity_drawcompliance >&
db_activity::m_drawcompliance() const {
  // @@protoc_insertion_point(field_map:pbdb.db_activity.m_drawcompliance)
  return _internal_m_drawcompliance();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::db_activity_drawcompliance >*
db_activity::_internal_mutable_m_drawcompliance() {
  return _impl_.m_drawcompliance_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::db_activity_drawcompliance >*
db_activity::mutable_m_drawcompliance() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_activity.m_drawcompliance)
  return _internal_mutable_m_drawcompliance();
}

// -------------------------------------------------------------------

// db_task_data_schedule

// optional int32 m_type = 1;
inline bool db_task_data_schedule::_internal_has_m_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_task_data_schedule::has_m_type() const {
  return _internal_has_m_type();
}
inline void db_task_data_schedule::clear_m_type() {
  _impl_.m_type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t db_task_data_schedule::_internal_m_type() const {
  return _impl_.m_type_;
}
inline int32_t db_task_data_schedule::m_type() const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.data_schedule.m_type)
  return _internal_m_type();
}
inline void db_task_data_schedule::_internal_set_m_type(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_type_ = value;
}
inline void db_task_data_schedule::set_m_type(int32_t value) {
  _internal_set_m_type(value);
  // @@protoc_insertion_point(field_set:pbdb.db_task.data_schedule.m_type)
}

// optional int32 m_value = 2;
inline bool db_task_data_schedule::_internal_has_m_value() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_task_data_schedule::has_m_value() const {
  return _internal_has_m_value();
}
inline void db_task_data_schedule::clear_m_value() {
  _impl_.m_value_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t db_task_data_schedule::_internal_m_value() const {
  return _impl_.m_value_;
}
inline int32_t db_task_data_schedule::m_value() const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.data_schedule.m_value)
  return _internal_m_value();
}
inline void db_task_data_schedule::_internal_set_m_value(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_value_ = value;
}
inline void db_task_data_schedule::set_m_value(int32_t value) {
  _internal_set_m_value(value);
  // @@protoc_insertion_point(field_set:pbdb.db_task.data_schedule.m_value)
}

// optional int32 m_sumint = 3;
inline bool db_task_data_schedule::_internal_has_m_sumint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_task_data_schedule::has_m_sumint() const {
  return _internal_has_m_sumint();
}
inline void db_task_data_schedule::clear_m_sumint() {
  _impl_.m_sumint_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t db_task_data_schedule::_internal_m_sumint() const {
  return _impl_.m_sumint_;
}
inline int32_t db_task_data_schedule::m_sumint() const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.data_schedule.m_sumint)
  return _internal_m_sumint();
}
inline void db_task_data_schedule::_internal_set_m_sumint(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.m_sumint_ = value;
}
inline void db_task_data_schedule::set_m_sumint(int32_t value) {
  _internal_set_m_sumint(value);
  // @@protoc_insertion_point(field_set:pbdb.db_task.data_schedule.m_sumint)
}

// -------------------------------------------------------------------

// db_task_data

// optional int32 m_taskid = 1;
inline bool db_task_data::_internal_has_m_taskid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_task_data::has_m_taskid() const {
  return _internal_has_m_taskid();
}
inline void db_task_data::clear_m_taskid() {
  _impl_.m_taskid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t db_task_data::_internal_m_taskid() const {
  return _impl_.m_taskid_;
}
inline int32_t db_task_data::m_taskid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.data.m_taskid)
  return _internal_m_taskid();
}
inline void db_task_data::_internal_set_m_taskid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_taskid_ = value;
}
inline void db_task_data::set_m_taskid(int32_t value) {
  _internal_set_m_taskid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_task.data.m_taskid)
}

// optional int32 m_receiveutc = 2;
inline bool db_task_data::_internal_has_m_receiveutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_task_data::has_m_receiveutc() const {
  return _internal_has_m_receiveutc();
}
inline void db_task_data::clear_m_receiveutc() {
  _impl_.m_receiveutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t db_task_data::_internal_m_receiveutc() const {
  return _impl_.m_receiveutc_;
}
inline int32_t db_task_data::m_receiveutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.data.m_receiveutc)
  return _internal_m_receiveutc();
}
inline void db_task_data::_internal_set_m_receiveutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_receiveutc_ = value;
}
inline void db_task_data::set_m_receiveutc(int32_t value) {
  _internal_set_m_receiveutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_task.data.m_receiveutc)
}

// optional int32 m_finshutc = 3;
inline bool db_task_data::_internal_has_m_finshutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_task_data::has_m_finshutc() const {
  return _internal_has_m_finshutc();
}
inline void db_task_data::clear_m_finshutc() {
  _impl_.m_finshutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t db_task_data::_internal_m_finshutc() const {
  return _impl_.m_finshutc_;
}
inline int32_t db_task_data::m_finshutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.data.m_finshutc)
  return _internal_m_finshutc();
}
inline void db_task_data::_internal_set_m_finshutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.m_finshutc_ = value;
}
inline void db_task_data::set_m_finshutc(int32_t value) {
  _internal_set_m_finshutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_task.data.m_finshutc)
}

// repeated .pbdb.db_task.data_schedule m_schedules = 4;
inline int db_task_data::_internal_m_schedules_size() const {
  return _impl_.m_schedules_.size();
}
inline int db_task_data::m_schedules_size() const {
  return _internal_m_schedules_size();
}
inline void db_task_data::clear_m_schedules() {
  _impl_.m_schedules_.Clear();
}
inline ::pbdb::db_task_data_schedule* db_task_data::mutable_m_schedules(int index) {
  // @@protoc_insertion_point(field_mutable:pbdb.db_task.data.m_schedules)
  return _impl_.m_schedules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_task_data_schedule >*
db_task_data::mutable_m_schedules() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.db_task.data.m_schedules)
  return &_impl_.m_schedules_;
}
inline const ::pbdb::db_task_data_schedule& db_task_data::_internal_m_schedules(int index) const {
  return _impl_.m_schedules_.Get(index);
}
inline const ::pbdb::db_task_data_schedule& db_task_data::m_schedules(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.data.m_schedules)
  return _internal_m_schedules(index);
}
inline ::pbdb::db_task_data_schedule* db_task_data::_internal_add_m_schedules() {
  return _impl_.m_schedules_.Add();
}
inline ::pbdb::db_task_data_schedule* db_task_data::add_m_schedules() {
  ::pbdb::db_task_data_schedule* _add = _internal_add_m_schedules();
  // @@protoc_insertion_point(field_add:pbdb.db_task.data.m_schedules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_task_data_schedule >&
db_task_data::m_schedules() const {
  // @@protoc_insertion_point(field_list:pbdb.db_task.data.m_schedules)
  return _impl_.m_schedules_;
}

// optional bool m_receive = 5;
inline bool db_task_data::_internal_has_m_receive() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool db_task_data::has_m_receive() const {
  return _internal_has_m_receive();
}
inline void db_task_data::clear_m_receive() {
  _impl_.m_receive_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool db_task_data::_internal_m_receive() const {
  return _impl_.m_receive_;
}
inline bool db_task_data::m_receive() const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.data.m_receive)
  return _internal_m_receive();
}
inline void db_task_data::_internal_set_m_receive(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.m_receive_ = value;
}
inline void db_task_data::set_m_receive(bool value) {
  _internal_set_m_receive(value);
  // @@protoc_insertion_point(field_set:pbdb.db_task.data.m_receive)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// db_task

// optional int64 m_id = 1;
inline bool db_task::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_task::has_m_id() const {
  return _internal_has_m_id();
}
inline void db_task::clear_m_id() {
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_task::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int64_t db_task::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.m_id)
  return _internal_m_id();
}
inline void db_task::_internal_set_m_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_id_ = value;
}
inline void db_task::set_m_id(int64_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.db_task.m_id)
}

// map<int32, .pbdb.db_task.data> m_rundatas = 2;
inline int db_task::_internal_m_rundatas_size() const {
  return _impl_.m_rundatas_.size();
}
inline int db_task::m_rundatas_size() const {
  return _internal_m_rundatas_size();
}
inline void db_task::clear_m_rundatas() {
  _impl_.m_rundatas_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >&
db_task::_internal_m_rundatas() const {
  return _impl_.m_rundatas_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >&
db_task::m_rundatas() const {
  // @@protoc_insertion_point(field_map:pbdb.db_task.m_rundatas)
  return _internal_m_rundatas();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >*
db_task::_internal_mutable_m_rundatas() {
  return _impl_.m_rundatas_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >*
db_task::mutable_m_rundatas() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_task.m_rundatas)
  return _internal_mutable_m_rundatas();
}

// map<int32, .pbdb.db_task.data> m_completeddatas = 3;
inline int db_task::_internal_m_completeddatas_size() const {
  return _impl_.m_completeddatas_.size();
}
inline int db_task::m_completeddatas_size() const {
  return _internal_m_completeddatas_size();
}
inline void db_task::clear_m_completeddatas() {
  _impl_.m_completeddatas_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >&
db_task::_internal_m_completeddatas() const {
  return _impl_.m_completeddatas_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >&
db_task::m_completeddatas() const {
  // @@protoc_insertion_point(field_map:pbdb.db_task.m_completeddatas)
  return _internal_m_completeddatas();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >*
db_task::_internal_mutable_m_completeddatas() {
  return _impl_.m_completeddatas_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >*
db_task::mutable_m_completeddatas() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_task.m_completeddatas)
  return _internal_mutable_m_completeddatas();
}

// -------------------------------------------------------------------

// db_calendar

// optional int64 m_id = 1;
inline bool db_calendar::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_calendar::has_m_id() const {
  return _internal_has_m_id();
}
inline void db_calendar::clear_m_id() {
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_calendar::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int64_t db_calendar::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.db_calendar.m_id)
  return _internal_m_id();
}
inline void db_calendar::_internal_set_m_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_id_ = value;
}
inline void db_calendar::set_m_id(int64_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.db_calendar.m_id)
}

// optional int64 m_time = 2;
inline bool db_calendar::_internal_has_m_time() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_calendar::has_m_time() const {
  return _internal_has_m_time();
}
inline void db_calendar::clear_m_time() {
  _impl_.m_time_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t db_calendar::_internal_m_time() const {
  return _impl_.m_time_;
}
inline int64_t db_calendar::m_time() const {
  // @@protoc_insertion_point(field_get:pbdb.db_calendar.m_time)
  return _internal_m_time();
}
inline void db_calendar::_internal_set_m_time(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_time_ = value;
}
inline void db_calendar::set_m_time(int64_t value) {
  _internal_set_m_time(value);
  // @@protoc_insertion_point(field_set:pbdb.db_calendar.m_time)
}

// optional bool m_start = 3;
inline bool db_calendar::_internal_has_m_start() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_calendar::has_m_start() const {
  return _internal_has_m_start();
}
inline void db_calendar::clear_m_start() {
  _impl_.m_start_ = false;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline bool db_calendar::_internal_m_start() const {
  return _impl_.m_start_;
}
inline bool db_calendar::m_start() const {
  // @@protoc_insertion_point(field_get:pbdb.db_calendar.m_start)
  return _internal_m_start();
}
inline void db_calendar::_internal_set_m_start(bool value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.m_start_ = value;
}
inline void db_calendar::set_m_start(bool value) {
  _internal_set_m_start(value);
  // @@protoc_insertion_point(field_set:pbdb.db_calendar.m_start)
}

// optional bool m_finish = 4;
inline bool db_calendar::_internal_has_m_finish() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool db_calendar::has_m_finish() const {
  return _internal_has_m_finish();
}
inline void db_calendar::clear_m_finish() {
  _impl_.m_finish_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool db_calendar::_internal_m_finish() const {
  return _impl_.m_finish_;
}
inline bool db_calendar::m_finish() const {
  // @@protoc_insertion_point(field_get:pbdb.db_calendar.m_finish)
  return _internal_m_finish();
}
inline void db_calendar::_internal_set_m_finish(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.m_finish_ = value;
}
inline void db_calendar::set_m_finish(bool value) {
  _internal_set_m_finish(value);
  // @@protoc_insertion_point(field_set:pbdb.db_calendar.m_finish)
}

// -------------------------------------------------------------------

// db_familyer

// optional int64 m_id = 1;
inline bool db_familyer::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_familyer::has_m_id() const {
  return _internal_has_m_id();
}
inline void db_familyer::clear_m_id() {
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_familyer::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int64_t db_familyer::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.db_familyer.m_id)
  return _internal_m_id();
}
inline void db_familyer::_internal_set_m_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_id_ = value;
}
inline void db_familyer::set_m_id(int64_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.db_familyer.m_id)
}

// optional int32 m_joinutc = 2;
inline bool db_familyer::_internal_has_m_joinutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_familyer::has_m_joinutc() const {
  return _internal_has_m_joinutc();
}
inline void db_familyer::clear_m_joinutc() {
  _impl_.m_joinutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t db_familyer::_internal_m_joinutc() const {
  return _impl_.m_joinutc_;
}
inline int32_t db_familyer::m_joinutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_familyer.m_joinutc)
  return _internal_m_joinutc();
}
inline void db_familyer::_internal_set_m_joinutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_joinutc_ = value;
}
inline void db_familyer::set_m_joinutc(int32_t value) {
  _internal_set_m_joinutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_familyer.m_joinutc)
}

// optional int32 m_lastsignutc = 3;
inline bool db_familyer::_internal_has_m_lastsignutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_familyer::has_m_lastsignutc() const {
  return _internal_has_m_lastsignutc();
}
inline void db_familyer::clear_m_lastsignutc() {
  _impl_.m_lastsignutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t db_familyer::_internal_m_lastsignutc() const {
  return _impl_.m_lastsignutc_;
}
inline int32_t db_familyer::m_lastsignutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_familyer.m_lastsignutc)
  return _internal_m_lastsignutc();
}
inline void db_familyer::_internal_set_m_lastsignutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.m_lastsignutc_ = value;
}
inline void db_familyer::set_m_lastsignutc(int32_t value) {
  _internal_set_m_lastsignutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_familyer.m_lastsignutc)
}

// optional int32 m_lastleaveutc = 4;
inline bool db_familyer::_internal_has_m_lastleaveutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool db_familyer::has_m_lastleaveutc() const {
  return _internal_has_m_lastleaveutc();
}
inline void db_familyer::clear_m_lastleaveutc() {
  _impl_.m_lastleaveutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t db_familyer::_internal_m_lastleaveutc() const {
  return _impl_.m_lastleaveutc_;
}
inline int32_t db_familyer::m_lastleaveutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_familyer.m_lastleaveutc)
  return _internal_m_lastleaveutc();
}
inline void db_familyer::_internal_set_m_lastleaveutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.m_lastleaveutc_ = value;
}
inline void db_familyer::set_m_lastleaveutc(int32_t value) {
  _internal_set_m_lastleaveutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_familyer.m_lastleaveutc)
}

// optional .pbdb.db_familyer.eposition m_position = 5;
inline bool db_familyer::_internal_has_m_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool db_familyer::has_m_position() const {
  return _internal_has_m_position();
}
inline void db_familyer::clear_m_position() {
  _impl_.m_position_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::pbdb::db_familyer_eposition db_familyer::_internal_m_position() const {
  return static_cast< ::pbdb::db_familyer_eposition >(_impl_.m_position_);
}
inline ::pbdb::db_familyer_eposition db_familyer::m_position() const {
  // @@protoc_insertion_point(field_get:pbdb.db_familyer.m_position)
  return _internal_m_position();
}
inline void db_familyer::_internal_set_m_position(::pbdb::db_familyer_eposition value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.m_position_ = value;
}
inline void db_familyer::set_m_position(::pbdb::db_familyer_eposition value) {
  _internal_set_m_position(value);
  // @@protoc_insertion_point(field_set:pbdb.db_familyer.m_position)
}

// -------------------------------------------------------------------

// db_family

// optional int64 m_id = 1;
inline bool db_family::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_family::has_m_id() const {
  return _internal_has_m_id();
}
inline void db_family::clear_m_id() {
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t db_family::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int64_t db_family::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.db_family.m_id)
  return _internal_m_id();
}
inline void db_family::_internal_set_m_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.m_id_ = value;
}
inline void db_family::set_m_id(int64_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.db_family.m_id)
}

// optional int32 m_createutc = 2;
inline bool db_family::_internal_has_m_createutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_family::has_m_createutc() const {
  return _internal_has_m_createutc();
}
inline void db_family::clear_m_createutc() {
  _impl_.m_createutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t db_family::_internal_m_createutc() const {
  return _impl_.m_createutc_;
}
inline int32_t db_family::m_createutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_family.m_createutc)
  return _internal_m_createutc();
}
inline void db_family::_internal_set_m_createutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.m_createutc_ = value;
}
inline void db_family::set_m_createutc(int32_t value) {
  _internal_set_m_createutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_family.m_createutc)
}

// optional string m_name = 3;
inline bool db_family::_internal_has_m_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_family::has_m_name() const {
  return _internal_has_m_name();
}
inline void db_family::clear_m_name() {
  _impl_.m_name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& db_family::m_name() const {
  // @@protoc_insertion_point(field_get:pbdb.db_family.m_name)
  return _internal_m_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void db_family::set_m_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.m_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.db_family.m_name)
}
inline std::string* db_family::mutable_m_name() {
  std::string* _s = _internal_mutable_m_name();
  // @@protoc_insertion_point(field_mutable:pbdb.db_family.m_name)
  return _s;
}
inline const std::string& db_family::_internal_m_name() const {
  return _impl_.m_name_.Get();
}
inline void db_family::_internal_set_m_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_name_.Set(value, GetArenaForAllocation());
}
inline std::string* db_family::_internal_mutable_m_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.m_name_.Mutable(GetArenaForAllocation());
}
inline std::string* db_family::release_m_name() {
  // @@protoc_insertion_point(field_release:pbdb.db_family.m_name)
  if (!_internal_has_m_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.m_name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_name_.IsDefault()) {
    _impl_.m_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void db_family::set_allocated_m_name(std::string* m_name) {
  if (m_name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.m_name_.SetAllocated(m_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.m_name_.IsDefault()) {
    _impl_.m_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_family.m_name)
}

// optional int64 m_leader = 4;
inline bool db_family::_internal_has_m_leader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool db_family::has_m_leader() const {
  return _internal_has_m_leader();
}
inline void db_family::clear_m_leader() {
  _impl_.m_leader_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t db_family::_internal_m_leader() const {
  return _impl_.m_leader_;
}
inline int64_t db_family::m_leader() const {
  // @@protoc_insertion_point(field_get:pbdb.db_family.m_leader)
  return _internal_m_leader();
}
inline void db_family::_internal_set_m_leader(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.m_leader_ = value;
}
inline void db_family::set_m_leader(int64_t value) {
  _internal_set_m_leader(value);
  // @@protoc_insertion_point(field_set:pbdb.db_family.m_leader)
}

// optional int32 m_lv = 5;
inline bool db_family::_internal_has_m_lv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool db_family::has_m_lv() const {
  return _internal_has_m_lv();
}
inline void db_family::clear_m_lv() {
  _impl_.m_lv_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t db_family::_internal_m_lv() const {
  return _impl_.m_lv_;
}
inline int32_t db_family::m_lv() const {
  // @@protoc_insertion_point(field_get:pbdb.db_family.m_lv)
  return _internal_m_lv();
}
inline void db_family::_internal_set_m_lv(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.m_lv_ = value;
}
inline void db_family::set_m_lv(int32_t value) {
  _internal_set_m_lv(value);
  // @@protoc_insertion_point(field_set:pbdb.db_family.m_lv)
}

// optional int32 m_exp = 6;
inline bool db_family::_internal_has_m_exp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool db_family::has_m_exp() const {
  return _internal_has_m_exp();
}
inline void db_family::clear_m_exp() {
  _impl_.m_exp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t db_family::_internal_m_exp() const {
  return _impl_.m_exp_;
}
inline int32_t db_family::m_exp() const {
  // @@protoc_insertion_point(field_get:pbdb.db_family.m_exp)
  return _internal_m_exp();
}
inline void db_family::_internal_set_m_exp(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.m_exp_ = value;
}
inline void db_family::set_m_exp(int32_t value) {
  _internal_set_m_exp(value);
  // @@protoc_insertion_point(field_set:pbdb.db_family.m_exp)
}

// repeated int64 m_member = 7;
inline int db_family::_internal_m_member_size() const {
  return _impl_.m_member_.size();
}
inline int db_family::m_member_size() const {
  return _internal_m_member_size();
}
inline void db_family::clear_m_member() {
  _impl_.m_member_.Clear();
}
inline int64_t db_family::_internal_m_member(int index) const {
  return _impl_.m_member_.Get(index);
}
inline int64_t db_family::m_member(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.db_family.m_member)
  return _internal_m_member(index);
}
inline void db_family::set_m_member(int index, int64_t value) {
  _impl_.m_member_.Set(index, value);
  // @@protoc_insertion_point(field_set:pbdb.db_family.m_member)
}
inline void db_family::_internal_add_m_member(int64_t value) {
  _impl_.m_member_.Add(value);
}
inline void db_family::add_m_member(int64_t value) {
  _internal_add_m_member(value);
  // @@protoc_insertion_point(field_add:pbdb.db_family.m_member)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_family::_internal_m_member() const {
  return _impl_.m_member_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_family::m_member() const {
  // @@protoc_insertion_point(field_list:pbdb.db_family.m_member)
  return _internal_m_member();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_family::_internal_mutable_m_member() {
  return &_impl_.m_member_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_family::mutable_m_member() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.db_family.m_member)
  return _internal_mutable_m_member();
}

// repeated int64 m_applylist = 8;
inline int db_family::_internal_m_applylist_size() const {
  return _impl_.m_applylist_.size();
}
inline int db_family::m_applylist_size() const {
  return _internal_m_applylist_size();
}
inline void db_family::clear_m_applylist() {
  _impl_.m_applylist_.Clear();
}
inline int64_t db_family::_internal_m_applylist(int index) const {
  return _impl_.m_applylist_.Get(index);
}
inline int64_t db_family::m_applylist(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.db_family.m_applylist)
  return _internal_m_applylist(index);
}
inline void db_family::set_m_applylist(int index, int64_t value) {
  _impl_.m_applylist_.Set(index, value);
  // @@protoc_insertion_point(field_set:pbdb.db_family.m_applylist)
}
inline void db_family::_internal_add_m_applylist(int64_t value) {
  _impl_.m_applylist_.Add(value);
}
inline void db_family::add_m_applylist(int64_t value) {
  _internal_add_m_applylist(value);
  // @@protoc_insertion_point(field_add:pbdb.db_family.m_applylist)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_family::_internal_m_applylist() const {
  return _impl_.m_applylist_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_family::m_applylist() const {
  // @@protoc_insertion_point(field_list:pbdb.db_family.m_applylist)
  return _internal_m_applylist();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_family::_internal_mutable_m_applylist() {
  return &_impl_.m_applylist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_family::mutable_m_applylist() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.db_family.m_applylist)
  return _internal_mutable_m_applylist();
}

// -------------------------------------------------------------------

// db_friends

// optional int64 m_id = 1;
inline bool db_friends::_internal_has_m_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_friends::has_m_id() const {
  return _internal_has_m_id();
}
inline void db_friends::clear_m_id() {
  _impl_.m_id_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_friends::_internal_m_id() const {
  return _impl_.m_id_;
}
inline int64_t db_friends::m_id() const {
  // @@protoc_insertion_point(field_get:pbdb.db_friends.m_id)
  return _internal_m_id();
}
inline void db_friends::_internal_set_m_id(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.m_id_ = value;
}
inline void db_friends::set_m_id(int64_t value) {
  _internal_set_m_id(value);
  // @@protoc_insertion_point(field_set:pbdb.db_friends.m_id)
}

// repeated int64 m_friends = 2;
inline int db_friends::_internal_m_friends_size() const {
  return _impl_.m_friends_.size();
}
inline int db_friends::m_friends_size() const {
  return _internal_m_friends_size();
}
inline void db_friends::clear_m_friends() {
  _impl_.m_friends_.Clear();
}
inline int64_t db_friends::_internal_m_friends(int index) const {
  return _impl_.m_friends_.Get(index);
}
inline int64_t db_friends::m_friends(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.db_friends.m_friends)
  return _internal_m_friends(index);
}
inline void db_friends::set_m_friends(int index, int64_t value) {
  _impl_.m_friends_.Set(index, value);
  // @@protoc_insertion_point(field_set:pbdb.db_friends.m_friends)
}
inline void db_friends::_internal_add_m_friends(int64_t value) {
  _impl_.m_friends_.Add(value);
}
inline void db_friends::add_m_friends(int64_t value) {
  _internal_add_m_friends(value);
  // @@protoc_insertion_point(field_add:pbdb.db_friends.m_friends)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_friends::_internal_m_friends() const {
  return _impl_.m_friends_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_friends::m_friends() const {
  // @@protoc_insertion_point(field_list:pbdb.db_friends.m_friends)
  return _internal_m_friends();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_friends::_internal_mutable_m_friends() {
  return &_impl_.m_friends_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_friends::mutable_m_friends() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.db_friends.m_friends)
  return _internal_mutable_m_friends();
}

// repeated int64 m_applyfriends = 3;
inline int db_friends::_internal_m_applyfriends_size() const {
  return _impl_.m_applyfriends_.size();
}
inline int db_friends::m_applyfriends_size() const {
  return _internal_m_applyfriends_size();
}
inline void db_friends::clear_m_applyfriends() {
  _impl_.m_applyfriends_.Clear();
}
inline int64_t db_friends::_internal_m_applyfriends(int index) const {
  return _impl_.m_applyfriends_.Get(index);
}
inline int64_t db_friends::m_applyfriends(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.db_friends.m_applyfriends)
  return _internal_m_applyfriends(index);
}
inline void db_friends::set_m_applyfriends(int index, int64_t value) {
  _impl_.m_applyfriends_.Set(index, value);
  // @@protoc_insertion_point(field_set:pbdb.db_friends.m_applyfriends)
}
inline void db_friends::_internal_add_m_applyfriends(int64_t value) {
  _impl_.m_applyfriends_.Add(value);
}
inline void db_friends::add_m_applyfriends(int64_t value) {
  _internal_add_m_applyfriends(value);
  // @@protoc_insertion_point(field_add:pbdb.db_friends.m_applyfriends)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_friends::_internal_m_applyfriends() const {
  return _impl_.m_applyfriends_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_friends::m_applyfriends() const {
  // @@protoc_insertion_point(field_list:pbdb.db_friends.m_applyfriends)
  return _internal_m_applyfriends();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_friends::_internal_mutable_m_applyfriends() {
  return &_impl_.m_applyfriends_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_friends::mutable_m_applyfriends() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.db_friends.m_applyfriends)
  return _internal_mutable_m_applyfriends();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbdb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pbdb::db_keyvalue_ekv> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbdb::db_keyvalue_ekv>() {
  return ::pbdb::db_keyvalue_ekv_descriptor();
}
template <> struct is_proto_enum< ::pbdb::db_familyer_eposition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbdb::db_familyer_eposition>() {
  return ::pbdb::db_familyer_eposition_descriptor();
}
template <> struct is_proto_enum< ::pbdb::ENUM_DB> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbdb::ENUM_DB>() {
  return ::pbdb::ENUM_DB_descriptor();
}
template <> struct is_proto_enum< ::pbdb::eranklist> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbdb::eranklist>() {
  return ::pbdb::eranklist_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_db_2eproto
