// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: db.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_db_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_db_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_db_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_db_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_db_2eproto;
namespace pbdb {
class activity_drawcompliance;
struct activity_drawcomplianceDefaultTypeInternal;
extern activity_drawcomplianceDefaultTypeInternal _activity_drawcompliance_default_instance_;
class activity_drawcompliance_MrewardEntry_DoNotUse;
struct activity_drawcompliance_MrewardEntry_DoNotUseDefaultTypeInternal;
extern activity_drawcompliance_MrewardEntry_DoNotUseDefaultTypeInternal _activity_drawcompliance_MrewardEntry_DoNotUse_default_instance_;
class activity_task;
struct activity_taskDefaultTypeInternal;
extern activity_taskDefaultTypeInternal _activity_task_default_instance_;
class activity_task_McloseEntry_DoNotUse;
struct activity_task_McloseEntry_DoNotUseDefaultTypeInternal;
extern activity_task_McloseEntry_DoNotUseDefaultTypeInternal _activity_task_McloseEntry_DoNotUse_default_instance_;
class activity_task_MopenEntry_DoNotUse;
struct activity_task_MopenEntry_DoNotUseDefaultTypeInternal;
extern activity_task_MopenEntry_DoNotUseDefaultTypeInternal _activity_task_MopenEntry_DoNotUse_default_instance_;
class brief_activityvalues;
struct brief_activityvaluesDefaultTypeInternal;
extern brief_activityvaluesDefaultTypeInternal _brief_activityvalues_default_instance_;
class brief_activityvalues_MactivityRolegoldEntry_DoNotUse;
struct brief_activityvalues_MactivityRolegoldEntry_DoNotUseDefaultTypeInternal;
extern brief_activityvalues_MactivityRolegoldEntry_DoNotUseDefaultTypeInternal _brief_activityvalues_MactivityRolegoldEntry_DoNotUse_default_instance_;
class brief_activityvalues_MactivityRolelvEntry_DoNotUse;
struct brief_activityvalues_MactivityRolelvEntry_DoNotUseDefaultTypeInternal;
extern brief_activityvalues_MactivityRolelvEntry_DoNotUseDefaultTypeInternal _brief_activityvalues_MactivityRolelvEntry_DoNotUse_default_instance_;
class db_account;
struct db_accountDefaultTypeInternal;
extern db_accountDefaultTypeInternal _db_account_default_instance_;
class db_activity;
struct db_activityDefaultTypeInternal;
extern db_activityDefaultTypeInternal _db_activity_default_instance_;
class db_activity_MdrawcomplianceEntry_DoNotUse;
struct db_activity_MdrawcomplianceEntry_DoNotUseDefaultTypeInternal;
extern db_activity_MdrawcomplianceEntry_DoNotUseDefaultTypeInternal _db_activity_MdrawcomplianceEntry_DoNotUse_default_instance_;
class db_activity_MtaskEntry_DoNotUse;
struct db_activity_MtaskEntry_DoNotUseDefaultTypeInternal;
extern db_activity_MtaskEntry_DoNotUseDefaultTypeInternal _db_activity_MtaskEntry_DoNotUse_default_instance_;
class db_activitytimes;
struct db_activitytimesDefaultTypeInternal;
extern db_activitytimesDefaultTypeInternal _db_activitytimes_default_instance_;
class db_bag;
struct db_bagDefaultTypeInternal;
extern db_bagDefaultTypeInternal _db_bag_default_instance_;
class db_bag_MitemsEntry_DoNotUse;
struct db_bag_MitemsEntry_DoNotUseDefaultTypeInternal;
extern db_bag_MitemsEntry_DoNotUseDefaultTypeInternal _db_bag_MitemsEntry_DoNotUse_default_instance_;
class db_brief;
struct db_briefDefaultTypeInternal;
extern db_briefDefaultTypeInternal _db_brief_default_instance_;
class db_family;
struct db_familyDefaultTypeInternal;
extern db_familyDefaultTypeInternal _db_family_default_instance_;
class db_familyer;
struct db_familyerDefaultTypeInternal;
extern db_familyerDefaultTypeInternal _db_familyer_default_instance_;
class db_friends;
struct db_friendsDefaultTypeInternal;
extern db_friendsDefaultTypeInternal _db_friends_default_instance_;
class db_keyvalue;
struct db_keyvalueDefaultTypeInternal;
extern db_keyvalueDefaultTypeInternal _db_keyvalue_default_instance_;
class db_mail;
struct db_mailDefaultTypeInternal;
extern db_mailDefaultTypeInternal _db_mail_default_instance_;
class db_mail_MmailEntry_DoNotUse;
struct db_mail_MmailEntry_DoNotUseDefaultTypeInternal;
extern db_mail_MmailEntry_DoNotUseDefaultTypeInternal _db_mail_MmailEntry_DoNotUse_default_instance_;
class db_notice;
struct db_noticeDefaultTypeInternal;
extern db_noticeDefaultTypeInternal _db_notice_default_instance_;
class db_ranklist;
struct db_ranklistDefaultTypeInternal;
extern db_ranklistDefaultTypeInternal _db_ranklist_default_instance_;
class db_ranklist_MitemsEntry_DoNotUse;
struct db_ranklist_MitemsEntry_DoNotUseDefaultTypeInternal;
extern db_ranklist_MitemsEntry_DoNotUseDefaultTypeInternal _db_ranklist_MitemsEntry_DoNotUse_default_instance_;
class db_role;
struct db_roleDefaultTypeInternal;
extern db_roleDefaultTypeInternal _db_role_default_instance_;
class db_role_recharge;
struct db_role_rechargeDefaultTypeInternal;
extern db_role_rechargeDefaultTypeInternal _db_role_recharge_default_instance_;
class db_rolekeyvalue;
struct db_rolekeyvalueDefaultTypeInternal;
extern db_rolekeyvalueDefaultTypeInternal _db_rolekeyvalue_default_instance_;
class db_rolekeyvalue_MdataEntry_DoNotUse;
struct db_rolekeyvalue_MdataEntry_DoNotUseDefaultTypeInternal;
extern db_rolekeyvalue_MdataEntry_DoNotUseDefaultTypeInternal _db_rolekeyvalue_MdataEntry_DoNotUse_default_instance_;
class db_task;
struct db_taskDefaultTypeInternal;
extern db_taskDefaultTypeInternal _db_task_default_instance_;
class db_task_McompleteddatasEntry_DoNotUse;
struct db_task_McompleteddatasEntry_DoNotUseDefaultTypeInternal;
extern db_task_McompleteddatasEntry_DoNotUseDefaultTypeInternal _db_task_McompleteddatasEntry_DoNotUse_default_instance_;
class db_task_MrundatasEntry_DoNotUse;
struct db_task_MrundatasEntry_DoNotUseDefaultTypeInternal;
extern db_task_MrundatasEntry_DoNotUseDefaultTypeInternal _db_task_MrundatasEntry_DoNotUse_default_instance_;
class db_task_complete;
struct db_task_completeDefaultTypeInternal;
extern db_task_completeDefaultTypeInternal _db_task_complete_default_instance_;
class db_task_data;
struct db_task_dataDefaultTypeInternal;
extern db_task_dataDefaultTypeInternal _db_task_data_default_instance_;
class db_task_data_schedule;
struct db_task_data_scheduleDefaultTypeInternal;
extern db_task_data_scheduleDefaultTypeInternal _db_task_data_schedule_default_instance_;
class db_testlua;
struct db_testluaDefaultTypeInternal;
extern db_testluaDefaultTypeInternal _db_testlua_default_instance_;
class db_testlua_MdatasEntry_DoNotUse;
struct db_testlua_MdatasEntry_DoNotUseDefaultTypeInternal;
extern db_testlua_MdatasEntry_DoNotUseDefaultTypeInternal _db_testlua_MdatasEntry_DoNotUse_default_instance_;
class db_testlua_luadata;
struct db_testlua_luadataDefaultTypeInternal;
extern db_testlua_luadataDefaultTypeInternal _db_testlua_luadata_default_instance_;
class dbcross_test;
struct dbcross_testDefaultTypeInternal;
extern dbcross_testDefaultTypeInternal _dbcross_test_default_instance_;
class item;
struct itemDefaultTypeInternal;
extern itemDefaultTypeInternal _item_default_instance_;
class mail;
struct mailDefaultTypeInternal;
extern mailDefaultTypeInternal _mail_default_instance_;
class mailitem;
struct mailitemDefaultTypeInternal;
extern mailitemDefaultTypeInternal _mailitem_default_instance_;
class rankitem;
struct rankitemDefaultTypeInternal;
extern rankitemDefaultTypeInternal _rankitem_default_instance_;
}  // namespace pbdb
PROTOBUF_NAMESPACE_OPEN
template<> ::pbdb::activity_drawcompliance* Arena::CreateMaybeMessage<::pbdb::activity_drawcompliance>(Arena*);
template<> ::pbdb::activity_drawcompliance_MrewardEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::activity_drawcompliance_MrewardEntry_DoNotUse>(Arena*);
template<> ::pbdb::activity_task* Arena::CreateMaybeMessage<::pbdb::activity_task>(Arena*);
template<> ::pbdb::activity_task_McloseEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::activity_task_McloseEntry_DoNotUse>(Arena*);
template<> ::pbdb::activity_task_MopenEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::activity_task_MopenEntry_DoNotUse>(Arena*);
template<> ::pbdb::brief_activityvalues* Arena::CreateMaybeMessage<::pbdb::brief_activityvalues>(Arena*);
template<> ::pbdb::brief_activityvalues_MactivityRolegoldEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::brief_activityvalues_MactivityRolegoldEntry_DoNotUse>(Arena*);
template<> ::pbdb::brief_activityvalues_MactivityRolelvEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::brief_activityvalues_MactivityRolelvEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_account* Arena::CreateMaybeMessage<::pbdb::db_account>(Arena*);
template<> ::pbdb::db_activity* Arena::CreateMaybeMessage<::pbdb::db_activity>(Arena*);
template<> ::pbdb::db_activity_MdrawcomplianceEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_activity_MdrawcomplianceEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_activity_MtaskEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_activity_MtaskEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_activitytimes* Arena::CreateMaybeMessage<::pbdb::db_activitytimes>(Arena*);
template<> ::pbdb::db_bag* Arena::CreateMaybeMessage<::pbdb::db_bag>(Arena*);
template<> ::pbdb::db_bag_MitemsEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_bag_MitemsEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_brief* Arena::CreateMaybeMessage<::pbdb::db_brief>(Arena*);
template<> ::pbdb::db_family* Arena::CreateMaybeMessage<::pbdb::db_family>(Arena*);
template<> ::pbdb::db_familyer* Arena::CreateMaybeMessage<::pbdb::db_familyer>(Arena*);
template<> ::pbdb::db_friends* Arena::CreateMaybeMessage<::pbdb::db_friends>(Arena*);
template<> ::pbdb::db_keyvalue* Arena::CreateMaybeMessage<::pbdb::db_keyvalue>(Arena*);
template<> ::pbdb::db_mail* Arena::CreateMaybeMessage<::pbdb::db_mail>(Arena*);
template<> ::pbdb::db_mail_MmailEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_mail_MmailEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_notice* Arena::CreateMaybeMessage<::pbdb::db_notice>(Arena*);
template<> ::pbdb::db_ranklist* Arena::CreateMaybeMessage<::pbdb::db_ranklist>(Arena*);
template<> ::pbdb::db_ranklist_MitemsEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_ranklist_MitemsEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_role* Arena::CreateMaybeMessage<::pbdb::db_role>(Arena*);
template<> ::pbdb::db_role_recharge* Arena::CreateMaybeMessage<::pbdb::db_role_recharge>(Arena*);
template<> ::pbdb::db_rolekeyvalue* Arena::CreateMaybeMessage<::pbdb::db_rolekeyvalue>(Arena*);
template<> ::pbdb::db_rolekeyvalue_MdataEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_rolekeyvalue_MdataEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_task* Arena::CreateMaybeMessage<::pbdb::db_task>(Arena*);
template<> ::pbdb::db_task_McompleteddatasEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_task_McompleteddatasEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_task_MrundatasEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_task_MrundatasEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_task_complete* Arena::CreateMaybeMessage<::pbdb::db_task_complete>(Arena*);
template<> ::pbdb::db_task_data* Arena::CreateMaybeMessage<::pbdb::db_task_data>(Arena*);
template<> ::pbdb::db_task_data_schedule* Arena::CreateMaybeMessage<::pbdb::db_task_data_schedule>(Arena*);
template<> ::pbdb::db_testlua* Arena::CreateMaybeMessage<::pbdb::db_testlua>(Arena*);
template<> ::pbdb::db_testlua_MdatasEntry_DoNotUse* Arena::CreateMaybeMessage<::pbdb::db_testlua_MdatasEntry_DoNotUse>(Arena*);
template<> ::pbdb::db_testlua_luadata* Arena::CreateMaybeMessage<::pbdb::db_testlua_luadata>(Arena*);
template<> ::pbdb::dbcross_test* Arena::CreateMaybeMessage<::pbdb::dbcross_test>(Arena*);
template<> ::pbdb::item* Arena::CreateMaybeMessage<::pbdb::item>(Arena*);
template<> ::pbdb::mail* Arena::CreateMaybeMessage<::pbdb::mail>(Arena*);
template<> ::pbdb::mailitem* Arena::CreateMaybeMessage<::pbdb::mailitem>(Arena*);
template<> ::pbdb::rankitem* Arena::CreateMaybeMessage<::pbdb::rankitem>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace pbdb {

enum db_keyvalue_ekv : int {
  db_keyvalue_ekv_none = 0,
  db_keyvalue_ekv_account_ban = 1,
  db_keyvalue_ekv_open_server = 2,
  db_keyvalue_ekv_db_keyvalue_ekv_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  db_keyvalue_ekv_db_keyvalue_ekv_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool db_keyvalue_ekv_IsValid(int value);
constexpr db_keyvalue_ekv db_keyvalue_ekv_ekv_MIN = db_keyvalue_ekv_none;
constexpr db_keyvalue_ekv db_keyvalue_ekv_ekv_MAX = db_keyvalue_ekv_open_server;
constexpr int db_keyvalue_ekv_ekv_ARRAYSIZE = db_keyvalue_ekv_ekv_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* db_keyvalue_ekv_descriptor();
template<typename T>
inline const std::string& db_keyvalue_ekv_Name(T enum_t_value) {
  static_assert(::std::is_same<T, db_keyvalue_ekv>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function db_keyvalue_ekv_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    db_keyvalue_ekv_descriptor(), enum_t_value);
}
inline bool db_keyvalue_ekv_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, db_keyvalue_ekv* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<db_keyvalue_ekv>(
    db_keyvalue_ekv_descriptor(), name, value);
}
enum db_familyer_eposition : int {
  db_familyer_eposition_none = 0,
  db_familyer_eposition_leader = 1,
  db_familyer_eposition_counsellor = 2,
  db_familyer_eposition_ordinary = 3,
  db_familyer_eposition_db_familyer_eposition_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  db_familyer_eposition_db_familyer_eposition_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool db_familyer_eposition_IsValid(int value);
constexpr db_familyer_eposition db_familyer_eposition_eposition_MIN = db_familyer_eposition_none;
constexpr db_familyer_eposition db_familyer_eposition_eposition_MAX = db_familyer_eposition_ordinary;
constexpr int db_familyer_eposition_eposition_ARRAYSIZE = db_familyer_eposition_eposition_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* db_familyer_eposition_descriptor();
template<typename T>
inline const std::string& db_familyer_eposition_Name(T enum_t_value) {
  static_assert(::std::is_same<T, db_familyer_eposition>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function db_familyer_eposition_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    db_familyer_eposition_descriptor(), enum_t_value);
}
inline bool db_familyer_eposition_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, db_familyer_eposition* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<db_familyer_eposition>(
    db_familyer_eposition_descriptor(), name, value);
}
enum ENUM_DB : int {
  ENUM_DB_ACCOUNT = 0,
  ENUM_DB_ROLE = 1,
  ENUM_DB_BRIEF = 2,
  ENUM_DB_BAG = 3,
  ENUM_DB_KEYVALUE = 4,
  ENUM_DB_MAIL = 5,
  ENUM_DB_NOTICE = 6,
  ENUM_DB_RANKLIST = 7,
  ENUM_DB_ACTIVITY = 8,
  ENUM_DB_ACTIVITYTIMES = 9,
  ENUM_DB_TASK = 10,
  ENUM_DB_ROLEKEYVALUE = 11,
  ENUM_DB_FAMILY = 12,
  ENUM_DB_FAMILYER = 13,
  ENUM_DB_FRIENDS = 14,
  ENUM_DB_TESTLUA = 15,
  ENUM_DB_COUNT = 16,
  ENUM_DBCROSS_TEST = 1001,
  ENUM_DB_FAIL = -1,
  ENUM_DB_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ENUM_DB_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ENUM_DB_IsValid(int value);
constexpr ENUM_DB ENUM_DB_MIN = ENUM_DB_FAIL;
constexpr ENUM_DB ENUM_DB_MAX = ENUM_DBCROSS_TEST;
constexpr int ENUM_DB_ARRAYSIZE = ENUM_DB_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ENUM_DB_descriptor();
template<typename T>
inline const std::string& ENUM_DB_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ENUM_DB>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ENUM_DB_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ENUM_DB_descriptor(), enum_t_value);
}
inline bool ENUM_DB_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ENUM_DB* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ENUM_DB>(
    ENUM_DB_descriptor(), name, value);
}
enum eranklist : int {
  eranklist_null = 0,
  lv = 1,
  gold = 2,
  count = 3,
  activity_lv = 1000000,
  activity_gold = 2000000,
  eranklist_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  eranklist_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool eranklist_IsValid(int value);
constexpr eranklist eranklist_MIN = eranklist_null;
constexpr eranklist eranklist_MAX = activity_gold;
constexpr int eranklist_ARRAYSIZE = eranklist_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* eranklist_descriptor();
template<typename T>
inline const std::string& eranklist_Name(T enum_t_value) {
  static_assert(::std::is_same<T, eranklist>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function eranklist_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    eranklist_descriptor(), enum_t_value);
}
inline bool eranklist_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, eranklist* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<eranklist>(
    eranklist_descriptor(), name, value);
}
// ===================================================================

class db_account final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_account) */ {
 public:
  inline db_account() : db_account(nullptr) {}
  ~db_account() override;
  explicit PROTOBUF_CONSTEXPR db_account(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_account(const db_account& from);
  db_account(db_account&& from) noexcept
    : db_account() {
    *this = ::std::move(from);
  }

  inline db_account& operator=(const db_account& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_account& operator=(db_account&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_account& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_account* internal_default_instance() {
    return reinterpret_cast<const db_account*>(
               &_db_account_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(db_account& a, db_account& b) {
    a.Swap(&b);
  }
  inline void Swap(db_account* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_account* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_account* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_account>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_account& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_account& from) {
    db_account::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_account* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_account";
  }
  protected:
  explicit db_account(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaccountFieldNumber = 3,
    kMpassworldFieldNumber = 4,
    kMidFieldNumber = 1,
    kMroleidFieldNumber = 2,
    kMareaFieldNumber = 5,
  };
  // optional string maccount = 3;
  bool has_maccount() const;
  private:
  bool _internal_has_maccount() const;
  public:
  void clear_maccount();
  const std::string& maccount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_maccount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_maccount();
  PROTOBUF_NODISCARD std::string* release_maccount();
  void set_allocated_maccount(std::string* maccount);
  private:
  const std::string& _internal_maccount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_maccount(const std::string& value);
  std::string* _internal_mutable_maccount();
  public:

  // optional string mpassworld = 4;
  bool has_mpassworld() const;
  private:
  bool _internal_has_mpassworld() const;
  public:
  void clear_mpassworld();
  const std::string& mpassworld() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mpassworld(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mpassworld();
  PROTOBUF_NODISCARD std::string* release_mpassworld();
  void set_allocated_mpassworld(std::string* mpassworld);
  private:
  const std::string& _internal_mpassworld() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mpassworld(const std::string& value);
  std::string* _internal_mutable_mpassworld();
  public:

  // optional int64 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int64_t mid() const;
  void set_mid(int64_t value);
  private:
  int64_t _internal_mid() const;
  void _internal_set_mid(int64_t value);
  public:

  // optional int64 mroleid = 2;
  bool has_mroleid() const;
  private:
  bool _internal_has_mroleid() const;
  public:
  void clear_mroleid();
  int64_t mroleid() const;
  void set_mroleid(int64_t value);
  private:
  int64_t _internal_mroleid() const;
  void _internal_set_mroleid(int64_t value);
  public:

  // optional int32 marea = 5;
  bool has_marea() const;
  private:
  bool _internal_has_marea() const;
  public:
  void clear_marea();
  int32_t marea() const;
  void set_marea(int32_t value);
  private:
  int32_t _internal_marea() const;
  void _internal_set_marea(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_account)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr maccount_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mpassworld_;
    int64_t mid_;
    int64_t mroleid_;
    int32_t marea_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class brief_activityvalues_MactivityRolelvEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<brief_activityvalues_MactivityRolelvEntry_DoNotUse, 
    int32_t, int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<brief_activityvalues_MactivityRolelvEntry_DoNotUse, 
    int32_t, int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  brief_activityvalues_MactivityRolelvEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR brief_activityvalues_MactivityRolelvEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit brief_activityvalues_MactivityRolelvEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const brief_activityvalues_MactivityRolelvEntry_DoNotUse& other);
  static const brief_activityvalues_MactivityRolelvEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const brief_activityvalues_MactivityRolelvEntry_DoNotUse*>(&_brief_activityvalues_MactivityRolelvEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class brief_activityvalues_MactivityRolegoldEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<brief_activityvalues_MactivityRolegoldEntry_DoNotUse, 
    int32_t, int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<brief_activityvalues_MactivityRolegoldEntry_DoNotUse, 
    int32_t, int32_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> SuperType;
  brief_activityvalues_MactivityRolegoldEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR brief_activityvalues_MactivityRolegoldEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit brief_activityvalues_MactivityRolegoldEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const brief_activityvalues_MactivityRolegoldEntry_DoNotUse& other);
  static const brief_activityvalues_MactivityRolegoldEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const brief_activityvalues_MactivityRolegoldEntry_DoNotUse*>(&_brief_activityvalues_MactivityRolegoldEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class brief_activityvalues final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.brief_activityvalues) */ {
 public:
  inline brief_activityvalues() : brief_activityvalues(nullptr) {}
  ~brief_activityvalues() override;
  explicit PROTOBUF_CONSTEXPR brief_activityvalues(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  brief_activityvalues(const brief_activityvalues& from);
  brief_activityvalues(brief_activityvalues&& from) noexcept
    : brief_activityvalues() {
    *this = ::std::move(from);
  }

  inline brief_activityvalues& operator=(const brief_activityvalues& from) {
    CopyFrom(from);
    return *this;
  }
  inline brief_activityvalues& operator=(brief_activityvalues&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const brief_activityvalues& default_instance() {
    return *internal_default_instance();
  }
  static inline const brief_activityvalues* internal_default_instance() {
    return reinterpret_cast<const brief_activityvalues*>(
               &_brief_activityvalues_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(brief_activityvalues& a, brief_activityvalues& b) {
    a.Swap(&b);
  }
  inline void Swap(brief_activityvalues* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(brief_activityvalues* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  brief_activityvalues* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<brief_activityvalues>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const brief_activityvalues& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const brief_activityvalues& from) {
    brief_activityvalues::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(brief_activityvalues* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.brief_activityvalues";
  }
  protected:
  explicit brief_activityvalues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMactivityRolelvFieldNumber = 1,
    kMactivityRolegoldFieldNumber = 2,
  };
  // map<int32, int32> mactivity_rolelv = 1;
  int mactivity_rolelv_size() const;
  private:
  int _internal_mactivity_rolelv_size() const;
  public:
  void clear_mactivity_rolelv();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >&
      _internal_mactivity_rolelv() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >*
      _internal_mutable_mactivity_rolelv();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >&
      mactivity_rolelv() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >*
      mutable_mactivity_rolelv();

  // map<int32, int32> mactivity_rolegold = 2;
  int mactivity_rolegold_size() const;
  private:
  int _internal_mactivity_rolegold_size() const;
  public:
  void clear_mactivity_rolegold();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >&
      _internal_mactivity_rolegold() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >*
      _internal_mutable_mactivity_rolegold();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >&
      mactivity_rolegold() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >*
      mutable_mactivity_rolegold();

  // @@protoc_insertion_point(class_scope:pbdb.brief_activityvalues)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        brief_activityvalues_MactivityRolelvEntry_DoNotUse,
        int32_t, int32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> mactivity_rolelv_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        brief_activityvalues_MactivityRolegoldEntry_DoNotUse,
        int32_t, int32_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32> mactivity_rolegold_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_brief final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_brief) */ {
 public:
  inline db_brief() : db_brief(nullptr) {}
  ~db_brief() override;
  explicit PROTOBUF_CONSTEXPR db_brief(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_brief(const db_brief& from);
  db_brief(db_brief&& from) noexcept
    : db_brief() {
    *this = ::std::move(from);
  }

  inline db_brief& operator=(const db_brief& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_brief& operator=(db_brief&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_brief& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_brief* internal_default_instance() {
    return reinterpret_cast<const db_brief*>(
               &_db_brief_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(db_brief& a, db_brief& b) {
    a.Swap(&b);
  }
  inline void Swap(db_brief* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_brief* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_brief* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_brief>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_brief& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_brief& from) {
    db_brief::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_brief* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_brief";
  }
  protected:
  explicit db_brief(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMnameFieldNumber = 2,
    kMactivityvaluesFieldNumber = 9,
    kMidFieldNumber = 1,
    kMlvFieldNumber = 3,
    kMmoneygoldFieldNumber = 4,
    kMmoneysilverFieldNumber = 5,
    kMvipFieldNumber = 6,
    kMnotalkutcFieldNumber = 7,
    kMcreateutcFieldNumber = 8,
  };
  // optional string mname = 2;
  bool has_mname() const;
  private:
  bool _internal_has_mname() const;
  public:
  void clear_mname();
  const std::string& mname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mname();
  PROTOBUF_NODISCARD std::string* release_mname();
  void set_allocated_mname(std::string* mname);
  private:
  const std::string& _internal_mname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mname(const std::string& value);
  std::string* _internal_mutable_mname();
  public:

  // optional .pbdb.brief_activityvalues mactivityvalues = 9;
  bool has_mactivityvalues() const;
  private:
  bool _internal_has_mactivityvalues() const;
  public:
  void clear_mactivityvalues();
  const ::pbdb::brief_activityvalues& mactivityvalues() const;
  PROTOBUF_NODISCARD ::pbdb::brief_activityvalues* release_mactivityvalues();
  ::pbdb::brief_activityvalues* mutable_mactivityvalues();
  void set_allocated_mactivityvalues(::pbdb::brief_activityvalues* mactivityvalues);
  private:
  const ::pbdb::brief_activityvalues& _internal_mactivityvalues() const;
  ::pbdb::brief_activityvalues* _internal_mutable_mactivityvalues();
  public:
  void unsafe_arena_set_allocated_mactivityvalues(
      ::pbdb::brief_activityvalues* mactivityvalues);
  ::pbdb::brief_activityvalues* unsafe_arena_release_mactivityvalues();

  // optional int64 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int64_t mid() const;
  void set_mid(int64_t value);
  private:
  int64_t _internal_mid() const;
  void _internal_set_mid(int64_t value);
  public:

  // optional int32 mlv = 3;
  bool has_mlv() const;
  private:
  bool _internal_has_mlv() const;
  public:
  void clear_mlv();
  int32_t mlv() const;
  void set_mlv(int32_t value);
  private:
  int32_t _internal_mlv() const;
  void _internal_set_mlv(int32_t value);
  public:

  // optional int32 mmoneygold = 4;
  bool has_mmoneygold() const;
  private:
  bool _internal_has_mmoneygold() const;
  public:
  void clear_mmoneygold();
  int32_t mmoneygold() const;
  void set_mmoneygold(int32_t value);
  private:
  int32_t _internal_mmoneygold() const;
  void _internal_set_mmoneygold(int32_t value);
  public:

  // optional int32 mmoneysilver = 5;
  bool has_mmoneysilver() const;
  private:
  bool _internal_has_mmoneysilver() const;
  public:
  void clear_mmoneysilver();
  int32_t mmoneysilver() const;
  void set_mmoneysilver(int32_t value);
  private:
  int32_t _internal_mmoneysilver() const;
  void _internal_set_mmoneysilver(int32_t value);
  public:

  // optional int32 mvip = 6;
  bool has_mvip() const;
  private:
  bool _internal_has_mvip() const;
  public:
  void clear_mvip();
  int32_t mvip() const;
  void set_mvip(int32_t value);
  private:
  int32_t _internal_mvip() const;
  void _internal_set_mvip(int32_t value);
  public:

  // optional int32 mnotalkutc = 7;
  bool has_mnotalkutc() const;
  private:
  bool _internal_has_mnotalkutc() const;
  public:
  void clear_mnotalkutc();
  int32_t mnotalkutc() const;
  void set_mnotalkutc(int32_t value);
  private:
  int32_t _internal_mnotalkutc() const;
  void _internal_set_mnotalkutc(int32_t value);
  public:

  // optional int32 mcreateutc = 8;
  bool has_mcreateutc() const;
  private:
  bool _internal_has_mcreateutc() const;
  public:
  void clear_mcreateutc();
  int32_t mcreateutc() const;
  void set_mcreateutc(int32_t value);
  private:
  int32_t _internal_mcreateutc() const;
  void _internal_set_mcreateutc(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_brief)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mname_;
    ::pbdb::brief_activityvalues* mactivityvalues_;
    int64_t mid_;
    int32_t mlv_;
    int32_t mmoneygold_;
    int32_t mmoneysilver_;
    int32_t mvip_;
    int32_t mnotalkutc_;
    int32_t mcreateutc_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_role_recharge final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_role.recharge) */ {
 public:
  inline db_role_recharge() : db_role_recharge(nullptr) {}
  ~db_role_recharge() override;
  explicit PROTOBUF_CONSTEXPR db_role_recharge(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_role_recharge(const db_role_recharge& from);
  db_role_recharge(db_role_recharge&& from) noexcept
    : db_role_recharge() {
    *this = ::std::move(from);
  }

  inline db_role_recharge& operator=(const db_role_recharge& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_role_recharge& operator=(db_role_recharge&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_role_recharge& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_role_recharge* internal_default_instance() {
    return reinterpret_cast<const db_role_recharge*>(
               &_db_role_recharge_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(db_role_recharge& a, db_role_recharge& b) {
    a.Swap(&b);
  }
  inline void Swap(db_role_recharge* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_role_recharge* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_role_recharge* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_role_recharge>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_role_recharge& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_role_recharge& from) {
    db_role_recharge::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_role_recharge* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_role.recharge";
  }
  protected:
  explicit db_role_recharge(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMrechargeidFieldNumber = 1,
    kMutcFieldNumber = 2,
  };
  // optional int32 mrechargeid = 1;
  bool has_mrechargeid() const;
  private:
  bool _internal_has_mrechargeid() const;
  public:
  void clear_mrechargeid();
  int32_t mrechargeid() const;
  void set_mrechargeid(int32_t value);
  private:
  int32_t _internal_mrechargeid() const;
  void _internal_set_mrechargeid(int32_t value);
  public:

  // optional int32 mutc = 2;
  bool has_mutc() const;
  private:
  bool _internal_has_mutc() const;
  public:
  void clear_mutc();
  int32_t mutc() const;
  void set_mutc(int32_t value);
  private:
  int32_t _internal_mutc() const;
  void _internal_set_mutc(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_role.recharge)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t mrechargeid_;
    int32_t mutc_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_role final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_role) */ {
 public:
  inline db_role() : db_role(nullptr) {}
  ~db_role() override;
  explicit PROTOBUF_CONSTEXPR db_role(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_role(const db_role& from);
  db_role(db_role&& from) noexcept
    : db_role() {
    *this = ::std::move(from);
  }

  inline db_role& operator=(const db_role& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_role& operator=(db_role&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_role& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_role* internal_default_instance() {
    return reinterpret_cast<const db_role*>(
               &_db_role_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(db_role& a, db_role& b) {
    a.Swap(&b);
  }
  inline void Swap(db_role* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_role* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_role* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_role>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_role& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_role& from) {
    db_role::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_role* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_role";
  }
  protected:
  explicit db_role(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef db_role_recharge recharge;

  // accessors -------------------------------------------------------

  enum : int {
    kMrechargeFieldNumber = 2,
    kMidFieldNumber = 1,
  };
  // repeated .pbdb.db_role.recharge mrecharge = 2;
  int mrecharge_size() const;
  private:
  int _internal_mrecharge_size() const;
  public:
  void clear_mrecharge();
  ::pbdb::db_role_recharge* mutable_mrecharge(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_role_recharge >*
      mutable_mrecharge();
  private:
  const ::pbdb::db_role_recharge& _internal_mrecharge(int index) const;
  ::pbdb::db_role_recharge* _internal_add_mrecharge();
  public:
  const ::pbdb::db_role_recharge& mrecharge(int index) const;
  ::pbdb::db_role_recharge* add_mrecharge();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_role_recharge >&
      mrecharge() const;

  // optional int64 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int64_t mid() const;
  void set_mid(int64_t value);
  private:
  int64_t _internal_mid() const;
  void _internal_set_mid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_role)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_role_recharge > mrecharge_;
    int64_t mid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class item final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.item) */ {
 public:
  inline item() : item(nullptr) {}
  ~item() override;
  explicit PROTOBUF_CONSTEXPR item(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  item(const item& from);
  item(item&& from) noexcept
    : item() {
    *this = ::std::move(from);
  }

  inline item& operator=(const item& from) {
    CopyFrom(from);
    return *this;
  }
  inline item& operator=(item&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const item& default_instance() {
    return *internal_default_instance();
  }
  static inline const item* internal_default_instance() {
    return reinterpret_cast<const item*>(
               &_item_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(item& a, item& b) {
    a.Swap(&b);
  }
  inline void Swap(item* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(item* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  item* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<item>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const item& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const item& from) {
    item::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(item* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.item";
  }
  protected:
  explicit item(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMidFieldNumber = 1,
    kMtidFieldNumber = 2,
    kMcountFieldNumber = 3,
    kMlvFieldNumber = 4,
    kMstarFieldNumber = 5,
  };
  // optional int32 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int32_t mid() const;
  void set_mid(int32_t value);
  private:
  int32_t _internal_mid() const;
  void _internal_set_mid(int32_t value);
  public:

  // optional int32 mtid = 2;
  bool has_mtid() const;
  private:
  bool _internal_has_mtid() const;
  public:
  void clear_mtid();
  int32_t mtid() const;
  void set_mtid(int32_t value);
  private:
  int32_t _internal_mtid() const;
  void _internal_set_mtid(int32_t value);
  public:

  // optional int32 mcount = 3;
  bool has_mcount() const;
  private:
  bool _internal_has_mcount() const;
  public:
  void clear_mcount();
  int32_t mcount() const;
  void set_mcount(int32_t value);
  private:
  int32_t _internal_mcount() const;
  void _internal_set_mcount(int32_t value);
  public:

  // optional int32 mlv = 4;
  bool has_mlv() const;
  private:
  bool _internal_has_mlv() const;
  public:
  void clear_mlv();
  int32_t mlv() const;
  void set_mlv(int32_t value);
  private:
  int32_t _internal_mlv() const;
  void _internal_set_mlv(int32_t value);
  public:

  // optional int32 mstar = 5;
  bool has_mstar() const;
  private:
  bool _internal_has_mstar() const;
  public:
  void clear_mstar();
  int32_t mstar() const;
  void set_mstar(int32_t value);
  private:
  int32_t _internal_mstar() const;
  void _internal_set_mstar(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.item)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t mid_;
    int32_t mtid_;
    int32_t mcount_;
    int32_t mlv_;
    int32_t mstar_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_bag_MitemsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_bag_MitemsEntry_DoNotUse, 
    int32_t, ::pbdb::item,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_bag_MitemsEntry_DoNotUse, 
    int32_t, ::pbdb::item,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  db_bag_MitemsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_bag_MitemsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_bag_MitemsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_bag_MitemsEntry_DoNotUse& other);
  static const db_bag_MitemsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_bag_MitemsEntry_DoNotUse*>(&_db_bag_MitemsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_bag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_bag) */ {
 public:
  inline db_bag() : db_bag(nullptr) {}
  ~db_bag() override;
  explicit PROTOBUF_CONSTEXPR db_bag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_bag(const db_bag& from);
  db_bag(db_bag&& from) noexcept
    : db_bag() {
    *this = ::std::move(from);
  }

  inline db_bag& operator=(const db_bag& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_bag& operator=(db_bag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_bag& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_bag* internal_default_instance() {
    return reinterpret_cast<const db_bag*>(
               &_db_bag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(db_bag& a, db_bag& b) {
    a.Swap(&b);
  }
  inline void Swap(db_bag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_bag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_bag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_bag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_bag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_bag& from) {
    db_bag::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_bag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_bag";
  }
  protected:
  explicit db_bag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMitemsFieldNumber = 2,
    kMidFieldNumber = 1,
    kMmaxidFieldNumber = 3,
  };
  // map<int32, .pbdb.item> mitems = 2;
  int mitems_size() const;
  private:
  int _internal_mitems_size() const;
  public:
  void clear_mitems();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >&
      _internal_mitems() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >*
      _internal_mutable_mitems();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >&
      mitems() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >*
      mutable_mitems();

  // optional int64 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int64_t mid() const;
  void set_mid(int64_t value);
  private:
  int64_t _internal_mid() const;
  void _internal_set_mid(int64_t value);
  public:

  // optional int32 mmaxid = 3;
  bool has_mmaxid() const;
  private:
  bool _internal_has_mmaxid() const;
  public:
  void clear_mmaxid();
  int32_t mmaxid() const;
  void set_mmaxid(int32_t value);
  private:
  int32_t _internal_mmaxid() const;
  void _internal_set_mmaxid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_bag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_bag_MitemsEntry_DoNotUse,
        int32_t, ::pbdb::item,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> mitems_;
    int64_t mid_;
    int32_t mmaxid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_keyvalue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_keyvalue) */ {
 public:
  inline db_keyvalue() : db_keyvalue(nullptr) {}
  ~db_keyvalue() override;
  explicit PROTOBUF_CONSTEXPR db_keyvalue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_keyvalue(const db_keyvalue& from);
  db_keyvalue(db_keyvalue&& from) noexcept
    : db_keyvalue() {
    *this = ::std::move(from);
  }

  inline db_keyvalue& operator=(const db_keyvalue& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_keyvalue& operator=(db_keyvalue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_keyvalue& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_keyvalue* internal_default_instance() {
    return reinterpret_cast<const db_keyvalue*>(
               &_db_keyvalue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(db_keyvalue& a, db_keyvalue& b) {
    a.Swap(&b);
  }
  inline void Swap(db_keyvalue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_keyvalue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_keyvalue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_keyvalue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_keyvalue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_keyvalue& from) {
    db_keyvalue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_keyvalue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_keyvalue";
  }
  protected:
  explicit db_keyvalue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef db_keyvalue_ekv ekv;
  static constexpr ekv none =
    db_keyvalue_ekv_none;
  static constexpr ekv account_ban =
    db_keyvalue_ekv_account_ban;
  static constexpr ekv open_server =
    db_keyvalue_ekv_open_server;
  static inline bool ekv_IsValid(int value) {
    return db_keyvalue_ekv_IsValid(value);
  }
  static constexpr ekv ekv_MIN =
    db_keyvalue_ekv_ekv_MIN;
  static constexpr ekv ekv_MAX =
    db_keyvalue_ekv_ekv_MAX;
  static constexpr int ekv_ARRAYSIZE =
    db_keyvalue_ekv_ekv_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ekv_descriptor() {
    return db_keyvalue_ekv_descriptor();
  }
  template<typename T>
  static inline const std::string& ekv_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ekv>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ekv_Name.");
    return db_keyvalue_ekv_Name(enum_t_value);
  }
  static inline bool ekv_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ekv* value) {
    return db_keyvalue_ekv_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMvalueFieldNumber = 2,
    kMidFieldNumber = 1,
  };
  // optional string mvalue = 2;
  bool has_mvalue() const;
  private:
  bool _internal_has_mvalue() const;
  public:
  void clear_mvalue();
  const std::string& mvalue() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mvalue(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mvalue();
  PROTOBUF_NODISCARD std::string* release_mvalue();
  void set_allocated_mvalue(std::string* mvalue);
  private:
  const std::string& _internal_mvalue() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mvalue(const std::string& value);
  std::string* _internal_mutable_mvalue();
  public:

  // optional int64 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int64_t mid() const;
  void set_mid(int64_t value);
  private:
  int64_t _internal_mid() const;
  void _internal_set_mid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_keyvalue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mvalue_;
    int64_t mid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_rolekeyvalue_MdataEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_rolekeyvalue_MdataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_rolekeyvalue_MdataEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  db_rolekeyvalue_MdataEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_rolekeyvalue_MdataEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_rolekeyvalue_MdataEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_rolekeyvalue_MdataEntry_DoNotUse& other);
  static const db_rolekeyvalue_MdataEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_rolekeyvalue_MdataEntry_DoNotUse*>(&_db_rolekeyvalue_MdataEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "pbdb.db_rolekeyvalue.MdataEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "pbdb.db_rolekeyvalue.MdataEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_rolekeyvalue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_rolekeyvalue) */ {
 public:
  inline db_rolekeyvalue() : db_rolekeyvalue(nullptr) {}
  ~db_rolekeyvalue() override;
  explicit PROTOBUF_CONSTEXPR db_rolekeyvalue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_rolekeyvalue(const db_rolekeyvalue& from);
  db_rolekeyvalue(db_rolekeyvalue&& from) noexcept
    : db_rolekeyvalue() {
    *this = ::std::move(from);
  }

  inline db_rolekeyvalue& operator=(const db_rolekeyvalue& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_rolekeyvalue& operator=(db_rolekeyvalue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_rolekeyvalue& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_rolekeyvalue* internal_default_instance() {
    return reinterpret_cast<const db_rolekeyvalue*>(
               &_db_rolekeyvalue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(db_rolekeyvalue& a, db_rolekeyvalue& b) {
    a.Swap(&b);
  }
  inline void Swap(db_rolekeyvalue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_rolekeyvalue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_rolekeyvalue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_rolekeyvalue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_rolekeyvalue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_rolekeyvalue& from) {
    db_rolekeyvalue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_rolekeyvalue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_rolekeyvalue";
  }
  protected:
  explicit db_rolekeyvalue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMdataFieldNumber = 2,
    kMidFieldNumber = 1,
  };
  // map<string, string> mdata = 2;
  int mdata_size() const;
  private:
  int _internal_mdata_size() const;
  public:
  void clear_mdata();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_mdata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_mdata();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      mdata() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_mdata();

  // optional int64 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int64_t mid() const;
  void set_mid(int64_t value);
  private:
  int64_t _internal_mid() const;
  void _internal_set_mid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_rolekeyvalue)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_rolekeyvalue_MdataEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> mdata_;
    int64_t mid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class mailitem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.mailitem) */ {
 public:
  inline mailitem() : mailitem(nullptr) {}
  ~mailitem() override;
  explicit PROTOBUF_CONSTEXPR mailitem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  mailitem(const mailitem& from);
  mailitem(mailitem&& from) noexcept
    : mailitem() {
    *this = ::std::move(from);
  }

  inline mailitem& operator=(const mailitem& from) {
    CopyFrom(from);
    return *this;
  }
  inline mailitem& operator=(mailitem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const mailitem& default_instance() {
    return *internal_default_instance();
  }
  static inline const mailitem* internal_default_instance() {
    return reinterpret_cast<const mailitem*>(
               &_mailitem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(mailitem& a, mailitem& b) {
    a.Swap(&b);
  }
  inline void Swap(mailitem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mailitem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  mailitem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<mailitem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const mailitem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const mailitem& from) {
    mailitem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mailitem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.mailitem";
  }
  protected:
  explicit mailitem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMitemtidFieldNumber = 1,
    kMcountFieldNumber = 2,
  };
  // optional int32 mitemtid = 1;
  bool has_mitemtid() const;
  private:
  bool _internal_has_mitemtid() const;
  public:
  void clear_mitemtid();
  int32_t mitemtid() const;
  void set_mitemtid(int32_t value);
  private:
  int32_t _internal_mitemtid() const;
  void _internal_set_mitemtid(int32_t value);
  public:

  // optional int32 mcount = 2;
  bool has_mcount() const;
  private:
  bool _internal_has_mcount() const;
  public:
  void clear_mcount();
  int32_t mcount() const;
  void set_mcount(int32_t value);
  private:
  int32_t _internal_mcount() const;
  void _internal_set_mcount(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.mailitem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t mitemtid_;
    int32_t mcount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class mail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.mail) */ {
 public:
  inline mail() : mail(nullptr) {}
  ~mail() override;
  explicit PROTOBUF_CONSTEXPR mail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  mail(const mail& from);
  mail(mail&& from) noexcept
    : mail() {
    *this = ::std::move(from);
  }

  inline mail& operator=(const mail& from) {
    CopyFrom(from);
    return *this;
  }
  inline mail& operator=(mail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const mail& default_instance() {
    return *internal_default_instance();
  }
  static inline const mail* internal_default_instance() {
    return reinterpret_cast<const mail*>(
               &_mail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(mail& a, mail& b) {
    a.Swap(&b);
  }
  inline void Swap(mail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(mail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  mail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<mail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const mail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const mail& from) {
    mail::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.mail";
  }
  protected:
  explicit mail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMitemsFieldNumber = 6,
    kMpramsFieldNumber = 4,
    kMcontentFieldNumber = 5,
    kMidFieldNumber = 1,
    kMcreateutcFieldNumber = 2,
    kMtidFieldNumber = 3,
    kMreadFieldNumber = 7,
    kMdrawFieldNumber = 8,
  };
  // repeated .pbdb.mailitem mitems = 6;
  int mitems_size() const;
  private:
  int _internal_mitems_size() const;
  public:
  void clear_mitems();
  ::pbdb::mailitem* mutable_mitems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::mailitem >*
      mutable_mitems();
  private:
  const ::pbdb::mailitem& _internal_mitems(int index) const;
  ::pbdb::mailitem* _internal_add_mitems();
  public:
  const ::pbdb::mailitem& mitems(int index) const;
  ::pbdb::mailitem* add_mitems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::mailitem >&
      mitems() const;

  // optional string mprams = 4;
  bool has_mprams() const;
  private:
  bool _internal_has_mprams() const;
  public:
  void clear_mprams();
  const std::string& mprams() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mprams(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mprams();
  PROTOBUF_NODISCARD std::string* release_mprams();
  void set_allocated_mprams(std::string* mprams);
  private:
  const std::string& _internal_mprams() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mprams(const std::string& value);
  std::string* _internal_mutable_mprams();
  public:

  // optional string mcontent = 5;
  bool has_mcontent() const;
  private:
  bool _internal_has_mcontent() const;
  public:
  void clear_mcontent();
  const std::string& mcontent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mcontent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mcontent();
  PROTOBUF_NODISCARD std::string* release_mcontent();
  void set_allocated_mcontent(std::string* mcontent);
  private:
  const std::string& _internal_mcontent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mcontent(const std::string& value);
  std::string* _internal_mutable_mcontent();
  public:

  // optional int32 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int32_t mid() const;
  void set_mid(int32_t value);
  private:
  int32_t _internal_mid() const;
  void _internal_set_mid(int32_t value);
  public:

  // optional int32 mcreateutc = 2;
  bool has_mcreateutc() const;
  private:
  bool _internal_has_mcreateutc() const;
  public:
  void clear_mcreateutc();
  int32_t mcreateutc() const;
  void set_mcreateutc(int32_t value);
  private:
  int32_t _internal_mcreateutc() const;
  void _internal_set_mcreateutc(int32_t value);
  public:

  // optional int32 mtid = 3;
  bool has_mtid() const;
  private:
  bool _internal_has_mtid() const;
  public:
  void clear_mtid();
  int32_t mtid() const;
  void set_mtid(int32_t value);
  private:
  int32_t _internal_mtid() const;
  void _internal_set_mtid(int32_t value);
  public:

  // optional bool mread = 7;
  bool has_mread() const;
  private:
  bool _internal_has_mread() const;
  public:
  void clear_mread();
  bool mread() const;
  void set_mread(bool value);
  private:
  bool _internal_mread() const;
  void _internal_set_mread(bool value);
  public:

  // optional bool mdraw = 8;
  bool has_mdraw() const;
  private:
  bool _internal_has_mdraw() const;
  public:
  void clear_mdraw();
  bool mdraw() const;
  void set_mdraw(bool value);
  private:
  bool _internal_mdraw() const;
  void _internal_set_mdraw(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.mail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::mailitem > mitems_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mprams_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mcontent_;
    int32_t mid_;
    int32_t mcreateutc_;
    int32_t mtid_;
    bool mread_;
    bool mdraw_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_mail_MmailEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_mail_MmailEntry_DoNotUse, 
    int32_t, ::pbdb::mail,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_mail_MmailEntry_DoNotUse, 
    int32_t, ::pbdb::mail,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  db_mail_MmailEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_mail_MmailEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_mail_MmailEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_mail_MmailEntry_DoNotUse& other);
  static const db_mail_MmailEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_mail_MmailEntry_DoNotUse*>(&_db_mail_MmailEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_mail final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_mail) */ {
 public:
  inline db_mail() : db_mail(nullptr) {}
  ~db_mail() override;
  explicit PROTOBUF_CONSTEXPR db_mail(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_mail(const db_mail& from);
  db_mail(db_mail&& from) noexcept
    : db_mail() {
    *this = ::std::move(from);
  }

  inline db_mail& operator=(const db_mail& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_mail& operator=(db_mail&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_mail& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_mail* internal_default_instance() {
    return reinterpret_cast<const db_mail*>(
               &_db_mail_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(db_mail& a, db_mail& b) {
    a.Swap(&b);
  }
  inline void Swap(db_mail* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_mail* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_mail* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_mail>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_mail& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_mail& from) {
    db_mail::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_mail* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_mail";
  }
  protected:
  explicit db_mail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMmailFieldNumber = 2,
    kMidFieldNumber = 1,
  };
  // map<int32, .pbdb.mail> mmail = 2;
  int mmail_size() const;
  private:
  int _internal_mmail_size() const;
  public:
  void clear_mmail();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >&
      _internal_mmail() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >*
      _internal_mutable_mmail();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >&
      mmail() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >*
      mutable_mmail();

  // optional int64 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int64_t mid() const;
  void set_mid(int64_t value);
  private:
  int64_t _internal_mid() const;
  void _internal_set_mid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_mail)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_mail_MmailEntry_DoNotUse,
        int32_t, ::pbdb::mail,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> mmail_;
    int64_t mid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_notice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_notice) */ {
 public:
  inline db_notice() : db_notice(nullptr) {}
  ~db_notice() override;
  explicit PROTOBUF_CONSTEXPR db_notice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_notice(const db_notice& from);
  db_notice(db_notice&& from) noexcept
    : db_notice() {
    *this = ::std::move(from);
  }

  inline db_notice& operator=(const db_notice& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_notice& operator=(db_notice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_notice& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_notice* internal_default_instance() {
    return reinterpret_cast<const db_notice*>(
               &_db_notice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(db_notice& a, db_notice& b) {
    a.Swap(&b);
  }
  inline void Swap(db_notice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_notice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_notice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_notice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_notice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_notice& from) {
    db_notice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_notice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_notice";
  }
  protected:
  explicit db_notice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMnoticeFieldNumber = 2,
    kMidFieldNumber = 1,
    kMstarttimeFieldNumber = 3,
    kMfinishtimeFieldNumber = 4,
  };
  // optional string mnotice = 2;
  bool has_mnotice() const;
  private:
  bool _internal_has_mnotice() const;
  public:
  void clear_mnotice();
  const std::string& mnotice() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mnotice(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mnotice();
  PROTOBUF_NODISCARD std::string* release_mnotice();
  void set_allocated_mnotice(std::string* mnotice);
  private:
  const std::string& _internal_mnotice() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mnotice(const std::string& value);
  std::string* _internal_mutable_mnotice();
  public:

  // optional int64 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int64_t mid() const;
  void set_mid(int64_t value);
  private:
  int64_t _internal_mid() const;
  void _internal_set_mid(int64_t value);
  public:

  // optional int32 mstarttime = 3;
  bool has_mstarttime() const;
  private:
  bool _internal_has_mstarttime() const;
  public:
  void clear_mstarttime();
  int32_t mstarttime() const;
  void set_mstarttime(int32_t value);
  private:
  int32_t _internal_mstarttime() const;
  void _internal_set_mstarttime(int32_t value);
  public:

  // optional int32 mfinishtime = 4;
  bool has_mfinishtime() const;
  private:
  bool _internal_has_mfinishtime() const;
  public:
  void clear_mfinishtime();
  int32_t mfinishtime() const;
  void set_mfinishtime(int32_t value);
  private:
  int32_t _internal_mfinishtime() const;
  void _internal_set_mfinishtime(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_notice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mnotice_;
    int64_t mid_;
    int32_t mstarttime_;
    int32_t mfinishtime_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class rankitem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.rankitem) */ {
 public:
  inline rankitem() : rankitem(nullptr) {}
  ~rankitem() override;
  explicit PROTOBUF_CONSTEXPR rankitem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  rankitem(const rankitem& from);
  rankitem(rankitem&& from) noexcept
    : rankitem() {
    *this = ::std::move(from);
  }

  inline rankitem& operator=(const rankitem& from) {
    CopyFrom(from);
    return *this;
  }
  inline rankitem& operator=(rankitem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const rankitem& default_instance() {
    return *internal_default_instance();
  }
  static inline const rankitem* internal_default_instance() {
    return reinterpret_cast<const rankitem*>(
               &_rankitem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(rankitem& a, rankitem& b) {
    a.Swap(&b);
  }
  inline void Swap(rankitem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(rankitem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  rankitem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<rankitem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const rankitem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const rankitem& from) {
    rankitem::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(rankitem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.rankitem";
  }
  protected:
  explicit rankitem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMvalueFieldNumber = 1,
    kMtimeFieldNumber = 2,
  };
  // optional int64 mvalue = 1;
  bool has_mvalue() const;
  private:
  bool _internal_has_mvalue() const;
  public:
  void clear_mvalue();
  int64_t mvalue() const;
  void set_mvalue(int64_t value);
  private:
  int64_t _internal_mvalue() const;
  void _internal_set_mvalue(int64_t value);
  public:

  // optional int32 mtime = 2;
  bool has_mtime() const;
  private:
  bool _internal_has_mtime() const;
  public:
  void clear_mtime();
  int32_t mtime() const;
  void set_mtime(int32_t value);
  private:
  int32_t _internal_mtime() const;
  void _internal_set_mtime(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.rankitem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t mvalue_;
    int32_t mtime_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_ranklist_MitemsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_ranklist_MitemsEntry_DoNotUse, 
    int32_t, ::pbdb::rankitem,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_ranklist_MitemsEntry_DoNotUse, 
    int32_t, ::pbdb::rankitem,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  db_ranklist_MitemsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_ranklist_MitemsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_ranklist_MitemsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_ranklist_MitemsEntry_DoNotUse& other);
  static const db_ranklist_MitemsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_ranklist_MitemsEntry_DoNotUse*>(&_db_ranklist_MitemsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_ranklist final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_ranklist) */ {
 public:
  inline db_ranklist() : db_ranklist(nullptr) {}
  ~db_ranklist() override;
  explicit PROTOBUF_CONSTEXPR db_ranklist(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_ranklist(const db_ranklist& from);
  db_ranklist(db_ranklist&& from) noexcept
    : db_ranklist() {
    *this = ::std::move(from);
  }

  inline db_ranklist& operator=(const db_ranklist& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_ranklist& operator=(db_ranklist&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_ranklist& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_ranklist* internal_default_instance() {
    return reinterpret_cast<const db_ranklist*>(
               &_db_ranklist_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(db_ranklist& a, db_ranklist& b) {
    a.Swap(&b);
  }
  inline void Swap(db_ranklist* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_ranklist* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_ranklist* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_ranklist>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_ranklist& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_ranklist& from) {
    db_ranklist::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_ranklist* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_ranklist";
  }
  protected:
  explicit db_ranklist(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMitemsFieldNumber = 2,
    kMidFieldNumber = 1,
  };
  // map<int32, .pbdb.rankitem> mitems = 2;
  int mitems_size() const;
  private:
  int _internal_mitems_size() const;
  public:
  void clear_mitems();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >&
      _internal_mitems() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >*
      _internal_mutable_mitems();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >&
      mitems() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >*
      mutable_mitems();

  // optional int64 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int64_t mid() const;
  void set_mid(int64_t value);
  private:
  int64_t _internal_mid() const;
  void _internal_set_mid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_ranklist)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_ranklist_MitemsEntry_DoNotUse,
        int32_t, ::pbdb::rankitem,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> mitems_;
    int64_t mid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_activitytimes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_activitytimes) */ {
 public:
  inline db_activitytimes() : db_activitytimes(nullptr) {}
  ~db_activitytimes() override;
  explicit PROTOBUF_CONSTEXPR db_activitytimes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_activitytimes(const db_activitytimes& from);
  db_activitytimes(db_activitytimes&& from) noexcept
    : db_activitytimes() {
    *this = ::std::move(from);
  }

  inline db_activitytimes& operator=(const db_activitytimes& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_activitytimes& operator=(db_activitytimes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_activitytimes& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_activitytimes* internal_default_instance() {
    return reinterpret_cast<const db_activitytimes*>(
               &_db_activitytimes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(db_activitytimes& a, db_activitytimes& b) {
    a.Swap(&b);
  }
  inline void Swap(db_activitytimes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_activitytimes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_activitytimes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_activitytimes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_activitytimes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_activitytimes& from) {
    db_activitytimes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_activitytimes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_activitytimes";
  }
  protected:
  explicit db_activitytimes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMidFieldNumber = 1,
    kMbegFieldNumber = 2,
    kMdurationFieldNumber = 3,
    kMstartFieldNumber = 4,
  };
  // optional int64 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int64_t mid() const;
  void set_mid(int64_t value);
  private:
  int64_t _internal_mid() const;
  void _internal_set_mid(int64_t value);
  public:

  // optional int32 mbeg = 2;
  bool has_mbeg() const;
  private:
  bool _internal_has_mbeg() const;
  public:
  void clear_mbeg();
  int32_t mbeg() const;
  void set_mbeg(int32_t value);
  private:
  int32_t _internal_mbeg() const;
  void _internal_set_mbeg(int32_t value);
  public:

  // optional int32 mduration = 3;
  bool has_mduration() const;
  private:
  bool _internal_has_mduration() const;
  public:
  void clear_mduration();
  int32_t mduration() const;
  void set_mduration(int32_t value);
  private:
  int32_t _internal_mduration() const;
  void _internal_set_mduration(int32_t value);
  public:

  // optional bool mstart = 4;
  bool has_mstart() const;
  private:
  bool _internal_has_mstart() const;
  public:
  void clear_mstart();
  bool mstart() const;
  void set_mstart(bool value);
  private:
  bool _internal_mstart() const;
  void _internal_set_mstart(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_activitytimes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t mid_;
    int32_t mbeg_;
    int32_t mduration_;
    bool mstart_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class activity_task_MopenEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<activity_task_MopenEntry_DoNotUse, 
    int32_t, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<activity_task_MopenEntry_DoNotUse, 
    int32_t, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> SuperType;
  activity_task_MopenEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR activity_task_MopenEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit activity_task_MopenEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const activity_task_MopenEntry_DoNotUse& other);
  static const activity_task_MopenEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const activity_task_MopenEntry_DoNotUse*>(&_activity_task_MopenEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class activity_task_McloseEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<activity_task_McloseEntry_DoNotUse, 
    int32_t, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<activity_task_McloseEntry_DoNotUse, 
    int32_t, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> SuperType;
  activity_task_McloseEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR activity_task_McloseEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit activity_task_McloseEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const activity_task_McloseEntry_DoNotUse& other);
  static const activity_task_McloseEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const activity_task_McloseEntry_DoNotUse*>(&_activity_task_McloseEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class activity_task final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.activity_task) */ {
 public:
  inline activity_task() : activity_task(nullptr) {}
  ~activity_task() override;
  explicit PROTOBUF_CONSTEXPR activity_task(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  activity_task(const activity_task& from);
  activity_task(activity_task&& from) noexcept
    : activity_task() {
    *this = ::std::move(from);
  }

  inline activity_task& operator=(const activity_task& from) {
    CopyFrom(from);
    return *this;
  }
  inline activity_task& operator=(activity_task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const activity_task& default_instance() {
    return *internal_default_instance();
  }
  static inline const activity_task* internal_default_instance() {
    return reinterpret_cast<const activity_task*>(
               &_activity_task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(activity_task& a, activity_task& b) {
    a.Swap(&b);
  }
  inline void Swap(activity_task* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(activity_task* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  activity_task* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<activity_task>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const activity_task& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const activity_task& from) {
    activity_task::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(activity_task* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.activity_task";
  }
  protected:
  explicit activity_task(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMopenFieldNumber = 1,
    kMcloseFieldNumber = 2,
  };
  // map<int32, bool> mopen = 1;
  int mopen_size() const;
  private:
  int _internal_mopen_size() const;
  public:
  void clear_mopen();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >&
      _internal_mopen() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >*
      _internal_mutable_mopen();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >&
      mopen() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >*
      mutable_mopen();

  // map<int32, bool> mclose = 2;
  int mclose_size() const;
  private:
  int _internal_mclose_size() const;
  public:
  void clear_mclose();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >&
      _internal_mclose() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >*
      _internal_mutable_mclose();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >&
      mclose() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >*
      mutable_mclose();

  // @@protoc_insertion_point(class_scope:pbdb.activity_task)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        activity_task_MopenEntry_DoNotUse,
        int32_t, bool,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> mopen_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        activity_task_McloseEntry_DoNotUse,
        int32_t, bool,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> mclose_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class activity_drawcompliance_MrewardEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<activity_drawcompliance_MrewardEntry_DoNotUse, 
    int32_t, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<activity_drawcompliance_MrewardEntry_DoNotUse, 
    int32_t, bool,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> SuperType;
  activity_drawcompliance_MrewardEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR activity_drawcompliance_MrewardEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit activity_drawcompliance_MrewardEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const activity_drawcompliance_MrewardEntry_DoNotUse& other);
  static const activity_drawcompliance_MrewardEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const activity_drawcompliance_MrewardEntry_DoNotUse*>(&_activity_drawcompliance_MrewardEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class activity_drawcompliance final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.activity_drawcompliance) */ {
 public:
  inline activity_drawcompliance() : activity_drawcompliance(nullptr) {}
  ~activity_drawcompliance() override;
  explicit PROTOBUF_CONSTEXPR activity_drawcompliance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  activity_drawcompliance(const activity_drawcompliance& from);
  activity_drawcompliance(activity_drawcompliance&& from) noexcept
    : activity_drawcompliance() {
    *this = ::std::move(from);
  }

  inline activity_drawcompliance& operator=(const activity_drawcompliance& from) {
    CopyFrom(from);
    return *this;
  }
  inline activity_drawcompliance& operator=(activity_drawcompliance&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const activity_drawcompliance& default_instance() {
    return *internal_default_instance();
  }
  static inline const activity_drawcompliance* internal_default_instance() {
    return reinterpret_cast<const activity_drawcompliance*>(
               &_activity_drawcompliance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(activity_drawcompliance& a, activity_drawcompliance& b) {
    a.Swap(&b);
  }
  inline void Swap(activity_drawcompliance* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(activity_drawcompliance* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  activity_drawcompliance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<activity_drawcompliance>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const activity_drawcompliance& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const activity_drawcompliance& from) {
    activity_drawcompliance::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(activity_drawcompliance* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.activity_drawcompliance";
  }
  protected:
  explicit activity_drawcompliance(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMrewardFieldNumber = 2,
    kMcountFieldNumber = 1,
  };
  // map<int32, bool> mreward = 2;
  int mreward_size() const;
  private:
  int _internal_mreward_size() const;
  public:
  void clear_mreward();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >&
      _internal_mreward() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >*
      _internal_mutable_mreward();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >&
      mreward() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >*
      mutable_mreward();

  // optional int32 mcount = 1;
  bool has_mcount() const;
  private:
  bool _internal_has_mcount() const;
  public:
  void clear_mcount();
  int32_t mcount() const;
  void set_mcount(int32_t value);
  private:
  int32_t _internal_mcount() const;
  void _internal_set_mcount(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.activity_drawcompliance)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        activity_drawcompliance_MrewardEntry_DoNotUse,
        int32_t, bool,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BOOL> mreward_;
    int32_t mcount_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_activity_MtaskEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_activity_MtaskEntry_DoNotUse, 
    int64_t, ::pbdb::activity_task,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_activity_MtaskEntry_DoNotUse, 
    int64_t, ::pbdb::activity_task,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  db_activity_MtaskEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_activity_MtaskEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_activity_MtaskEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_activity_MtaskEntry_DoNotUse& other);
  static const db_activity_MtaskEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_activity_MtaskEntry_DoNotUse*>(&_db_activity_MtaskEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_activity_MdrawcomplianceEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_activity_MdrawcomplianceEntry_DoNotUse, 
    int64_t, ::pbdb::activity_drawcompliance,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_activity_MdrawcomplianceEntry_DoNotUse, 
    int64_t, ::pbdb::activity_drawcompliance,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  db_activity_MdrawcomplianceEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_activity_MdrawcomplianceEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_activity_MdrawcomplianceEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_activity_MdrawcomplianceEntry_DoNotUse& other);
  static const db_activity_MdrawcomplianceEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_activity_MdrawcomplianceEntry_DoNotUse*>(&_db_activity_MdrawcomplianceEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_activity final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_activity) */ {
 public:
  inline db_activity() : db_activity(nullptr) {}
  ~db_activity() override;
  explicit PROTOBUF_CONSTEXPR db_activity(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_activity(const db_activity& from);
  db_activity(db_activity&& from) noexcept
    : db_activity() {
    *this = ::std::move(from);
  }

  inline db_activity& operator=(const db_activity& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_activity& operator=(db_activity&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_activity& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_activity* internal_default_instance() {
    return reinterpret_cast<const db_activity*>(
               &_db_activity_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(db_activity& a, db_activity& b) {
    a.Swap(&b);
  }
  inline void Swap(db_activity* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_activity* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_activity* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_activity>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_activity& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_activity& from) {
    db_activity::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_activity* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_activity";
  }
  protected:
  explicit db_activity(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMtaskFieldNumber = 2,
    kMdrawcomplianceFieldNumber = 3,
    kMidFieldNumber = 1,
  };
  // map<int64, .pbdb.activity_task> mtask = 2;
  int mtask_size() const;
  private:
  int _internal_mtask_size() const;
  public:
  void clear_mtask();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::activity_task >&
      _internal_mtask() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::activity_task >*
      _internal_mutable_mtask();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::activity_task >&
      mtask() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::activity_task >*
      mutable_mtask();

  // map<int64, .pbdb.activity_drawcompliance> mdrawcompliance = 3;
  int mdrawcompliance_size() const;
  private:
  int _internal_mdrawcompliance_size() const;
  public:
  void clear_mdrawcompliance();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::activity_drawcompliance >&
      _internal_mdrawcompliance() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::activity_drawcompliance >*
      _internal_mutable_mdrawcompliance();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::activity_drawcompliance >&
      mdrawcompliance() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::activity_drawcompliance >*
      mutable_mdrawcompliance();

  // optional int64 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int64_t mid() const;
  void set_mid(int64_t value);
  private:
  int64_t _internal_mid() const;
  void _internal_set_mid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_activity)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_activity_MtaskEntry_DoNotUse,
        int64_t, ::pbdb::activity_task,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> mtask_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_activity_MdrawcomplianceEntry_DoNotUse,
        int64_t, ::pbdb::activity_drawcompliance,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> mdrawcompliance_;
    int64_t mid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_task_data_schedule final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_task.data_schedule) */ {
 public:
  inline db_task_data_schedule() : db_task_data_schedule(nullptr) {}
  ~db_task_data_schedule() override;
  explicit PROTOBUF_CONSTEXPR db_task_data_schedule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_task_data_schedule(const db_task_data_schedule& from);
  db_task_data_schedule(db_task_data_schedule&& from) noexcept
    : db_task_data_schedule() {
    *this = ::std::move(from);
  }

  inline db_task_data_schedule& operator=(const db_task_data_schedule& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_task_data_schedule& operator=(db_task_data_schedule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_task_data_schedule& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_task_data_schedule* internal_default_instance() {
    return reinterpret_cast<const db_task_data_schedule*>(
               &_db_task_data_schedule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(db_task_data_schedule& a, db_task_data_schedule& b) {
    a.Swap(&b);
  }
  inline void Swap(db_task_data_schedule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_task_data_schedule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_task_data_schedule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_task_data_schedule>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_task_data_schedule& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_task_data_schedule& from) {
    db_task_data_schedule::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_task_data_schedule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_task.data_schedule";
  }
  protected:
  explicit db_task_data_schedule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMtypeFieldNumber = 1,
    kMvalueFieldNumber = 2,
    kMsumintFieldNumber = 3,
  };
  // optional int32 mtype = 1;
  bool has_mtype() const;
  private:
  bool _internal_has_mtype() const;
  public:
  void clear_mtype();
  int32_t mtype() const;
  void set_mtype(int32_t value);
  private:
  int32_t _internal_mtype() const;
  void _internal_set_mtype(int32_t value);
  public:

  // optional int32 mvalue = 2;
  bool has_mvalue() const;
  private:
  bool _internal_has_mvalue() const;
  public:
  void clear_mvalue();
  int32_t mvalue() const;
  void set_mvalue(int32_t value);
  private:
  int32_t _internal_mvalue() const;
  void _internal_set_mvalue(int32_t value);
  public:

  // optional int32 msumint = 3;
  bool has_msumint() const;
  private:
  bool _internal_has_msumint() const;
  public:
  void clear_msumint();
  int32_t msumint() const;
  void set_msumint(int32_t value);
  private:
  int32_t _internal_msumint() const;
  void _internal_set_msumint(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_task.data_schedule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t mtype_;
    int32_t mvalue_;
    int32_t msumint_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_task_data final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_task.data) */ {
 public:
  inline db_task_data() : db_task_data(nullptr) {}
  ~db_task_data() override;
  explicit PROTOBUF_CONSTEXPR db_task_data(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_task_data(const db_task_data& from);
  db_task_data(db_task_data&& from) noexcept
    : db_task_data() {
    *this = ::std::move(from);
  }

  inline db_task_data& operator=(const db_task_data& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_task_data& operator=(db_task_data&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_task_data& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_task_data* internal_default_instance() {
    return reinterpret_cast<const db_task_data*>(
               &_db_task_data_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(db_task_data& a, db_task_data& b) {
    a.Swap(&b);
  }
  inline void Swap(db_task_data* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_task_data* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_task_data* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_task_data>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_task_data& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_task_data& from) {
    db_task_data::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_task_data* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_task.data";
  }
  protected:
  explicit db_task_data(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMschedulesFieldNumber = 4,
    kMtaskidFieldNumber = 1,
    kMreceiveutcFieldNumber = 2,
    kMfinshutcFieldNumber = 3,
    kMreceiveFieldNumber = 5,
  };
  // repeated .pbdb.db_task.data_schedule mschedules = 4;
  int mschedules_size() const;
  private:
  int _internal_mschedules_size() const;
  public:
  void clear_mschedules();
  ::pbdb::db_task_data_schedule* mutable_mschedules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_task_data_schedule >*
      mutable_mschedules();
  private:
  const ::pbdb::db_task_data_schedule& _internal_mschedules(int index) const;
  ::pbdb::db_task_data_schedule* _internal_add_mschedules();
  public:
  const ::pbdb::db_task_data_schedule& mschedules(int index) const;
  ::pbdb::db_task_data_schedule* add_mschedules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_task_data_schedule >&
      mschedules() const;

  // optional int32 mtaskid = 1;
  bool has_mtaskid() const;
  private:
  bool _internal_has_mtaskid() const;
  public:
  void clear_mtaskid();
  int32_t mtaskid() const;
  void set_mtaskid(int32_t value);
  private:
  int32_t _internal_mtaskid() const;
  void _internal_set_mtaskid(int32_t value);
  public:

  // optional int32 mreceiveutc = 2;
  bool has_mreceiveutc() const;
  private:
  bool _internal_has_mreceiveutc() const;
  public:
  void clear_mreceiveutc();
  int32_t mreceiveutc() const;
  void set_mreceiveutc(int32_t value);
  private:
  int32_t _internal_mreceiveutc() const;
  void _internal_set_mreceiveutc(int32_t value);
  public:

  // optional int32 mfinshutc = 3;
  bool has_mfinshutc() const;
  private:
  bool _internal_has_mfinshutc() const;
  public:
  void clear_mfinshutc();
  int32_t mfinshutc() const;
  void set_mfinshutc(int32_t value);
  private:
  int32_t _internal_mfinshutc() const;
  void _internal_set_mfinshutc(int32_t value);
  public:

  // optional bool mreceive = 5;
  bool has_mreceive() const;
  private:
  bool _internal_has_mreceive() const;
  public:
  void clear_mreceive();
  bool mreceive() const;
  void set_mreceive(bool value);
  private:
  bool _internal_mreceive() const;
  void _internal_set_mreceive(bool value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_task.data)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_task_data_schedule > mschedules_;
    int32_t mtaskid_;
    int32_t mreceiveutc_;
    int32_t mfinshutc_;
    bool mreceive_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_task_complete final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_task.complete) */ {
 public:
  inline db_task_complete() : db_task_complete(nullptr) {}
  ~db_task_complete() override;
  explicit PROTOBUF_CONSTEXPR db_task_complete(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_task_complete(const db_task_complete& from);
  db_task_complete(db_task_complete&& from) noexcept
    : db_task_complete() {
    *this = ::std::move(from);
  }

  inline db_task_complete& operator=(const db_task_complete& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_task_complete& operator=(db_task_complete&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_task_complete& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_task_complete* internal_default_instance() {
    return reinterpret_cast<const db_task_complete*>(
               &_db_task_complete_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(db_task_complete& a, db_task_complete& b) {
    a.Swap(&b);
  }
  inline void Swap(db_task_complete* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_task_complete* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_task_complete* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_task_complete>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_task_complete& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_task_complete& from) {
    db_task_complete::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_task_complete* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_task.complete";
  }
  protected:
  explicit db_task_complete(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMhistoryFieldNumber = 1,
  };
  // repeated .pbdb.db_task.data mhistory = 1;
  int mhistory_size() const;
  private:
  int _internal_mhistory_size() const;
  public:
  void clear_mhistory();
  ::pbdb::db_task_data* mutable_mhistory(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_task_data >*
      mutable_mhistory();
  private:
  const ::pbdb::db_task_data& _internal_mhistory(int index) const;
  ::pbdb::db_task_data* _internal_add_mhistory();
  public:
  const ::pbdb::db_task_data& mhistory(int index) const;
  ::pbdb::db_task_data* add_mhistory();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_task_data >&
      mhistory() const;

  // @@protoc_insertion_point(class_scope:pbdb.db_task.complete)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_task_data > mhistory_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_task_MrundatasEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_task_MrundatasEntry_DoNotUse, 
    int32_t, ::pbdb::db_task_data,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_task_MrundatasEntry_DoNotUse, 
    int32_t, ::pbdb::db_task_data,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  db_task_MrundatasEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_task_MrundatasEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_task_MrundatasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_task_MrundatasEntry_DoNotUse& other);
  static const db_task_MrundatasEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_task_MrundatasEntry_DoNotUse*>(&_db_task_MrundatasEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_task_McompleteddatasEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_task_McompleteddatasEntry_DoNotUse, 
    int32_t, ::pbdb::db_task_complete,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_task_McompleteddatasEntry_DoNotUse, 
    int32_t, ::pbdb::db_task_complete,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  db_task_McompleteddatasEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_task_McompleteddatasEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_task_McompleteddatasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_task_McompleteddatasEntry_DoNotUse& other);
  static const db_task_McompleteddatasEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_task_McompleteddatasEntry_DoNotUse*>(&_db_task_McompleteddatasEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_task final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_task) */ {
 public:
  inline db_task() : db_task(nullptr) {}
  ~db_task() override;
  explicit PROTOBUF_CONSTEXPR db_task(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_task(const db_task& from);
  db_task(db_task&& from) noexcept
    : db_task() {
    *this = ::std::move(from);
  }

  inline db_task& operator=(const db_task& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_task& operator=(db_task&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_task& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_task* internal_default_instance() {
    return reinterpret_cast<const db_task*>(
               &_db_task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(db_task& a, db_task& b) {
    a.Swap(&b);
  }
  inline void Swap(db_task* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_task* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_task* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_task>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_task& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_task& from) {
    db_task::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_task* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_task";
  }
  protected:
  explicit db_task(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef db_task_data_schedule data_schedule;
  typedef db_task_data data;
  typedef db_task_complete complete;

  // accessors -------------------------------------------------------

  enum : int {
    kMrundatasFieldNumber = 2,
    kMcompleteddatasFieldNumber = 3,
    kMidFieldNumber = 1,
  };
  // map<int32, .pbdb.db_task.data> mrundatas = 2;
  int mrundatas_size() const;
  private:
  int _internal_mrundatas_size() const;
  public:
  void clear_mrundatas();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >&
      _internal_mrundatas() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >*
      _internal_mutable_mrundatas();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >&
      mrundatas() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >*
      mutable_mrundatas();

  // map<int32, .pbdb.db_task.complete> mcompleteddatas = 3;
  int mcompleteddatas_size() const;
  private:
  int _internal_mcompleteddatas_size() const;
  public:
  void clear_mcompleteddatas();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_complete >&
      _internal_mcompleteddatas() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_complete >*
      _internal_mutable_mcompleteddatas();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_complete >&
      mcompleteddatas() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_complete >*
      mutable_mcompleteddatas();

  // optional int64 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int64_t mid() const;
  void set_mid(int64_t value);
  private:
  int64_t _internal_mid() const;
  void _internal_set_mid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_task)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_task_MrundatasEntry_DoNotUse,
        int32_t, ::pbdb::db_task_data,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> mrundatas_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_task_McompleteddatasEntry_DoNotUse,
        int32_t, ::pbdb::db_task_complete,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> mcompleteddatas_;
    int64_t mid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_familyer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_familyer) */ {
 public:
  inline db_familyer() : db_familyer(nullptr) {}
  ~db_familyer() override;
  explicit PROTOBUF_CONSTEXPR db_familyer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_familyer(const db_familyer& from);
  db_familyer(db_familyer&& from) noexcept
    : db_familyer() {
    *this = ::std::move(from);
  }

  inline db_familyer& operator=(const db_familyer& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_familyer& operator=(db_familyer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_familyer& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_familyer* internal_default_instance() {
    return reinterpret_cast<const db_familyer*>(
               &_db_familyer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(db_familyer& a, db_familyer& b) {
    a.Swap(&b);
  }
  inline void Swap(db_familyer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_familyer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_familyer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_familyer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_familyer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_familyer& from) {
    db_familyer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_familyer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_familyer";
  }
  protected:
  explicit db_familyer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef db_familyer_eposition eposition;
  static constexpr eposition none =
    db_familyer_eposition_none;
  static constexpr eposition leader =
    db_familyer_eposition_leader;
  static constexpr eposition counsellor =
    db_familyer_eposition_counsellor;
  static constexpr eposition ordinary =
    db_familyer_eposition_ordinary;
  static inline bool eposition_IsValid(int value) {
    return db_familyer_eposition_IsValid(value);
  }
  static constexpr eposition eposition_MIN =
    db_familyer_eposition_eposition_MIN;
  static constexpr eposition eposition_MAX =
    db_familyer_eposition_eposition_MAX;
  static constexpr int eposition_ARRAYSIZE =
    db_familyer_eposition_eposition_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  eposition_descriptor() {
    return db_familyer_eposition_descriptor();
  }
  template<typename T>
  static inline const std::string& eposition_Name(T enum_t_value) {
    static_assert(::std::is_same<T, eposition>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function eposition_Name.");
    return db_familyer_eposition_Name(enum_t_value);
  }
  static inline bool eposition_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      eposition* value) {
    return db_familyer_eposition_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMidFieldNumber = 1,
    kMjoinutcFieldNumber = 2,
    kMlastsignutcFieldNumber = 3,
    kMlastleaveutcFieldNumber = 4,
    kMpositionFieldNumber = 5,
  };
  // optional int64 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int64_t mid() const;
  void set_mid(int64_t value);
  private:
  int64_t _internal_mid() const;
  void _internal_set_mid(int64_t value);
  public:

  // optional int32 mjoinutc = 2;
  bool has_mjoinutc() const;
  private:
  bool _internal_has_mjoinutc() const;
  public:
  void clear_mjoinutc();
  int32_t mjoinutc() const;
  void set_mjoinutc(int32_t value);
  private:
  int32_t _internal_mjoinutc() const;
  void _internal_set_mjoinutc(int32_t value);
  public:

  // optional int32 mlastsignutc = 3;
  bool has_mlastsignutc() const;
  private:
  bool _internal_has_mlastsignutc() const;
  public:
  void clear_mlastsignutc();
  int32_t mlastsignutc() const;
  void set_mlastsignutc(int32_t value);
  private:
  int32_t _internal_mlastsignutc() const;
  void _internal_set_mlastsignutc(int32_t value);
  public:

  // optional int32 mlastleaveutc = 4;
  bool has_mlastleaveutc() const;
  private:
  bool _internal_has_mlastleaveutc() const;
  public:
  void clear_mlastleaveutc();
  int32_t mlastleaveutc() const;
  void set_mlastleaveutc(int32_t value);
  private:
  int32_t _internal_mlastleaveutc() const;
  void _internal_set_mlastleaveutc(int32_t value);
  public:

  // optional .pbdb.db_familyer.eposition mposition = 5;
  bool has_mposition() const;
  private:
  bool _internal_has_mposition() const;
  public:
  void clear_mposition();
  ::pbdb::db_familyer_eposition mposition() const;
  void set_mposition(::pbdb::db_familyer_eposition value);
  private:
  ::pbdb::db_familyer_eposition _internal_mposition() const;
  void _internal_set_mposition(::pbdb::db_familyer_eposition value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_familyer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int64_t mid_;
    int32_t mjoinutc_;
    int32_t mlastsignutc_;
    int32_t mlastleaveutc_;
    int mposition_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_family final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_family) */ {
 public:
  inline db_family() : db_family(nullptr) {}
  ~db_family() override;
  explicit PROTOBUF_CONSTEXPR db_family(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_family(const db_family& from);
  db_family(db_family&& from) noexcept
    : db_family() {
    *this = ::std::move(from);
  }

  inline db_family& operator=(const db_family& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_family& operator=(db_family&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_family& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_family* internal_default_instance() {
    return reinterpret_cast<const db_family*>(
               &_db_family_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(db_family& a, db_family& b) {
    a.Swap(&b);
  }
  inline void Swap(db_family* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_family* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_family* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_family>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_family& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_family& from) {
    db_family::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_family* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_family";
  }
  protected:
  explicit db_family(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMmemberFieldNumber = 7,
    kMapplylistFieldNumber = 8,
    kMnameFieldNumber = 3,
    kMidFieldNumber = 1,
    kMcreateutcFieldNumber = 2,
    kMlvFieldNumber = 5,
    kMleaderFieldNumber = 4,
    kMexpFieldNumber = 6,
  };
  // repeated int64 mmember = 7;
  int mmember_size() const;
  private:
  int _internal_mmember_size() const;
  public:
  void clear_mmember();
  private:
  int64_t _internal_mmember(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_mmember() const;
  void _internal_add_mmember(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_mmember();
  public:
  int64_t mmember(int index) const;
  void set_mmember(int index, int64_t value);
  void add_mmember(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      mmember() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_mmember();

  // repeated int64 mapplylist = 8;
  int mapplylist_size() const;
  private:
  int _internal_mapplylist_size() const;
  public:
  void clear_mapplylist();
  private:
  int64_t _internal_mapplylist(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_mapplylist() const;
  void _internal_add_mapplylist(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_mapplylist();
  public:
  int64_t mapplylist(int index) const;
  void set_mapplylist(int index, int64_t value);
  void add_mapplylist(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      mapplylist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_mapplylist();

  // optional string mname = 3;
  bool has_mname() const;
  private:
  bool _internal_has_mname() const;
  public:
  void clear_mname();
  const std::string& mname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mname();
  PROTOBUF_NODISCARD std::string* release_mname();
  void set_allocated_mname(std::string* mname);
  private:
  const std::string& _internal_mname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mname(const std::string& value);
  std::string* _internal_mutable_mname();
  public:

  // optional int64 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int64_t mid() const;
  void set_mid(int64_t value);
  private:
  int64_t _internal_mid() const;
  void _internal_set_mid(int64_t value);
  public:

  // optional int32 mcreateutc = 2;
  bool has_mcreateutc() const;
  private:
  bool _internal_has_mcreateutc() const;
  public:
  void clear_mcreateutc();
  int32_t mcreateutc() const;
  void set_mcreateutc(int32_t value);
  private:
  int32_t _internal_mcreateutc() const;
  void _internal_set_mcreateutc(int32_t value);
  public:

  // optional int32 mlv = 5;
  bool has_mlv() const;
  private:
  bool _internal_has_mlv() const;
  public:
  void clear_mlv();
  int32_t mlv() const;
  void set_mlv(int32_t value);
  private:
  int32_t _internal_mlv() const;
  void _internal_set_mlv(int32_t value);
  public:

  // optional int64 mleader = 4;
  bool has_mleader() const;
  private:
  bool _internal_has_mleader() const;
  public:
  void clear_mleader();
  int64_t mleader() const;
  void set_mleader(int64_t value);
  private:
  int64_t _internal_mleader() const;
  void _internal_set_mleader(int64_t value);
  public:

  // optional int32 mexp = 6;
  bool has_mexp() const;
  private:
  bool _internal_has_mexp() const;
  public:
  void clear_mexp();
  int32_t mexp() const;
  void set_mexp(int32_t value);
  private:
  int32_t _internal_mexp() const;
  void _internal_set_mexp(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_family)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > mmember_;
    mutable std::atomic<int> _mmember_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > mapplylist_;
    mutable std::atomic<int> _mapplylist_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mname_;
    int64_t mid_;
    int32_t mcreateutc_;
    int32_t mlv_;
    int64_t mleader_;
    int32_t mexp_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_friends final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_friends) */ {
 public:
  inline db_friends() : db_friends(nullptr) {}
  ~db_friends() override;
  explicit PROTOBUF_CONSTEXPR db_friends(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_friends(const db_friends& from);
  db_friends(db_friends&& from) noexcept
    : db_friends() {
    *this = ::std::move(from);
  }

  inline db_friends& operator=(const db_friends& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_friends& operator=(db_friends&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_friends& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_friends* internal_default_instance() {
    return reinterpret_cast<const db_friends*>(
               &_db_friends_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(db_friends& a, db_friends& b) {
    a.Swap(&b);
  }
  inline void Swap(db_friends* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_friends* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_friends* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_friends>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_friends& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_friends& from) {
    db_friends::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_friends* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_friends";
  }
  protected:
  explicit db_friends(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMfriendsFieldNumber = 2,
    kMapplyfriendsFieldNumber = 3,
    kMidFieldNumber = 1,
  };
  // repeated int64 mfriends = 2;
  int mfriends_size() const;
  private:
  int _internal_mfriends_size() const;
  public:
  void clear_mfriends();
  private:
  int64_t _internal_mfriends(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_mfriends() const;
  void _internal_add_mfriends(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_mfriends();
  public:
  int64_t mfriends(int index) const;
  void set_mfriends(int index, int64_t value);
  void add_mfriends(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      mfriends() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_mfriends();

  // repeated int64 mapplyfriends = 3;
  int mapplyfriends_size() const;
  private:
  int _internal_mapplyfriends_size() const;
  public:
  void clear_mapplyfriends();
  private:
  int64_t _internal_mapplyfriends(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_mapplyfriends() const;
  void _internal_add_mapplyfriends(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_mapplyfriends();
  public:
  int64_t mapplyfriends(int index) const;
  void set_mapplyfriends(int index, int64_t value);
  void add_mapplyfriends(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      mapplyfriends() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_mapplyfriends();

  // optional int64 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int64_t mid() const;
  void set_mid(int64_t value);
  private:
  int64_t _internal_mid() const;
  void _internal_set_mid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_friends)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > mfriends_;
    mutable std::atomic<int> _mfriends_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > mapplyfriends_;
    mutable std::atomic<int> _mapplyfriends_cached_byte_size_;
    int64_t mid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class dbcross_test final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.dbcross_test) */ {
 public:
  inline dbcross_test() : dbcross_test(nullptr) {}
  ~dbcross_test() override;
  explicit PROTOBUF_CONSTEXPR dbcross_test(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  dbcross_test(const dbcross_test& from);
  dbcross_test(dbcross_test&& from) noexcept
    : dbcross_test() {
    *this = ::std::move(from);
  }

  inline dbcross_test& operator=(const dbcross_test& from) {
    CopyFrom(from);
    return *this;
  }
  inline dbcross_test& operator=(dbcross_test&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const dbcross_test& default_instance() {
    return *internal_default_instance();
  }
  static inline const dbcross_test* internal_default_instance() {
    return reinterpret_cast<const dbcross_test*>(
               &_dbcross_test_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(dbcross_test& a, dbcross_test& b) {
    a.Swap(&b);
  }
  inline void Swap(dbcross_test* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(dbcross_test* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  dbcross_test* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<dbcross_test>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const dbcross_test& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const dbcross_test& from) {
    dbcross_test::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(dbcross_test* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.dbcross_test";
  }
  protected:
  explicit dbcross_test(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMvalueFieldNumber = 2,
    kMnameFieldNumber = 1,
  };
  // repeated int64 mvalue = 2;
  int mvalue_size() const;
  private:
  int _internal_mvalue_size() const;
  public:
  void clear_mvalue();
  private:
  int64_t _internal_mvalue(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_mvalue() const;
  void _internal_add_mvalue(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_mvalue();
  public:
  int64_t mvalue(int index) const;
  void set_mvalue(int index, int64_t value);
  void add_mvalue(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      mvalue() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_mvalue();

  // optional string mname = 1;
  bool has_mname() const;
  private:
  bool _internal_has_mname() const;
  public:
  void clear_mname();
  const std::string& mname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mname();
  PROTOBUF_NODISCARD std::string* release_mname();
  void set_allocated_mname(std::string* mname);
  private:
  const std::string& _internal_mname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mname(const std::string& value);
  std::string* _internal_mutable_mname();
  public:

  // @@protoc_insertion_point(class_scope:pbdb.dbcross_test)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > mvalue_;
    mutable std::atomic<int> _mvalue_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mname_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_testlua_luadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_testlua.luadata) */ {
 public:
  inline db_testlua_luadata() : db_testlua_luadata(nullptr) {}
  ~db_testlua_luadata() override;
  explicit PROTOBUF_CONSTEXPR db_testlua_luadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_testlua_luadata(const db_testlua_luadata& from);
  db_testlua_luadata(db_testlua_luadata&& from) noexcept
    : db_testlua_luadata() {
    *this = ::std::move(from);
  }

  inline db_testlua_luadata& operator=(const db_testlua_luadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_testlua_luadata& operator=(db_testlua_luadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_testlua_luadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_testlua_luadata* internal_default_instance() {
    return reinterpret_cast<const db_testlua_luadata*>(
               &_db_testlua_luadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(db_testlua_luadata& a, db_testlua_luadata& b) {
    a.Swap(&b);
  }
  inline void Swap(db_testlua_luadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_testlua_luadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_testlua_luadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_testlua_luadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_testlua_luadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_testlua_luadata& from) {
    db_testlua_luadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_testlua_luadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_testlua.luadata";
  }
  protected:
  explicit db_testlua_luadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMkeyFieldNumber = 1,
    kMvalFieldNumber = 2,
  };
  // optional string mkey = 1;
  bool has_mkey() const;
  private:
  bool _internal_has_mkey() const;
  public:
  void clear_mkey();
  const std::string& mkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mkey();
  PROTOBUF_NODISCARD std::string* release_mkey();
  void set_allocated_mkey(std::string* mkey);
  private:
  const std::string& _internal_mkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mkey(const std::string& value);
  std::string* _internal_mutable_mkey();
  public:

  // optional string mval = 2;
  bool has_mval() const;
  private:
  bool _internal_has_mval() const;
  public:
  void clear_mval();
  const std::string& mval() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mval(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mval();
  PROTOBUF_NODISCARD std::string* release_mval();
  void set_allocated_mval(std::string* mval);
  private:
  const std::string& _internal_mval() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mval(const std::string& value);
  std::string* _internal_mutable_mval();
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_testlua.luadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mkey_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mval_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// -------------------------------------------------------------------

class db_testlua_MdatasEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_testlua_MdatasEntry_DoNotUse, 
    int32_t, ::pbdb::db_testlua_luadata,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<db_testlua_MdatasEntry_DoNotUse, 
    int32_t, ::pbdb::db_testlua_luadata,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  db_testlua_MdatasEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR db_testlua_MdatasEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit db_testlua_MdatasEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const db_testlua_MdatasEntry_DoNotUse& other);
  static const db_testlua_MdatasEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const db_testlua_MdatasEntry_DoNotUse*>(&_db_testlua_MdatasEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(void*) { return true; }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_db_2eproto;
};

// -------------------------------------------------------------------

class db_testlua final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:pbdb.db_testlua) */ {
 public:
  inline db_testlua() : db_testlua(nullptr) {}
  ~db_testlua() override;
  explicit PROTOBUF_CONSTEXPR db_testlua(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  db_testlua(const db_testlua& from);
  db_testlua(db_testlua&& from) noexcept
    : db_testlua() {
    *this = ::std::move(from);
  }

  inline db_testlua& operator=(const db_testlua& from) {
    CopyFrom(from);
    return *this;
  }
  inline db_testlua& operator=(db_testlua&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const db_testlua& default_instance() {
    return *internal_default_instance();
  }
  static inline const db_testlua* internal_default_instance() {
    return reinterpret_cast<const db_testlua*>(
               &_db_testlua_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(db_testlua& a, db_testlua& b) {
    a.Swap(&b);
  }
  inline void Swap(db_testlua* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(db_testlua* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  db_testlua* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<db_testlua>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const db_testlua& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const db_testlua& from) {
    db_testlua::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(db_testlua* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "pbdb.db_testlua";
  }
  protected:
  explicit db_testlua(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef db_testlua_luadata luadata;

  // accessors -------------------------------------------------------

  enum : int {
    kMvalueFieldNumber = 2,
    kMdatasFieldNumber = 3,
    kMidFieldNumber = 1,
  };
  // repeated int64 mvalue = 2;
  int mvalue_size() const;
  private:
  int _internal_mvalue_size() const;
  public:
  void clear_mvalue();
  private:
  int64_t _internal_mvalue(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_mvalue() const;
  void _internal_add_mvalue(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_mvalue();
  public:
  int64_t mvalue(int index) const;
  void set_mvalue(int index, int64_t value);
  void add_mvalue(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      mvalue() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_mvalue();

  // map<int32, .pbdb.db_testlua.luadata> mdatas = 3;
  int mdatas_size() const;
  private:
  int _internal_mdatas_size() const;
  public:
  void clear_mdatas();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_testlua_luadata >&
      _internal_mdatas() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_testlua_luadata >*
      _internal_mutable_mdatas();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_testlua_luadata >&
      mdatas() const;
  ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_testlua_luadata >*
      mutable_mdatas();

  // optional int64 mid = 1;
  bool has_mid() const;
  private:
  bool _internal_has_mid() const;
  public:
  void clear_mid();
  int64_t mid() const;
  void set_mid(int64_t value);
  private:
  int64_t _internal_mid() const;
  void _internal_set_mid(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:pbdb.db_testlua)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > mvalue_;
    mutable std::atomic<int> _mvalue_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        db_testlua_MdatasEntry_DoNotUse,
        int32_t, ::pbdb::db_testlua_luadata,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT32,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> mdatas_;
    int64_t mid_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_db_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// db_account

// optional int64 mid = 1;
inline bool db_account::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_account::has_mid() const {
  return _internal_has_mid();
}
inline void db_account::clear_mid() {
  _impl_.mid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t db_account::_internal_mid() const {
  return _impl_.mid_;
}
inline int64_t db_account::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_account.mid)
  return _internal_mid();
}
inline void db_account::_internal_set_mid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mid_ = value;
}
inline void db_account::set_mid(int64_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_account.mid)
}

// optional int64 mroleid = 2;
inline bool db_account::_internal_has_mroleid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool db_account::has_mroleid() const {
  return _internal_has_mroleid();
}
inline void db_account::clear_mroleid() {
  _impl_.mroleid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int64_t db_account::_internal_mroleid() const {
  return _impl_.mroleid_;
}
inline int64_t db_account::mroleid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_account.mroleid)
  return _internal_mroleid();
}
inline void db_account::_internal_set_mroleid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mroleid_ = value;
}
inline void db_account::set_mroleid(int64_t value) {
  _internal_set_mroleid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_account.mroleid)
}

// optional string maccount = 3;
inline bool db_account::_internal_has_maccount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_account::has_maccount() const {
  return _internal_has_maccount();
}
inline void db_account::clear_maccount() {
  _impl_.maccount_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& db_account::maccount() const {
  // @@protoc_insertion_point(field_get:pbdb.db_account.maccount)
  return _internal_maccount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void db_account::set_maccount(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.maccount_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.db_account.maccount)
}
inline std::string* db_account::mutable_maccount() {
  std::string* _s = _internal_mutable_maccount();
  // @@protoc_insertion_point(field_mutable:pbdb.db_account.maccount)
  return _s;
}
inline const std::string& db_account::_internal_maccount() const {
  return _impl_.maccount_.Get();
}
inline void db_account::_internal_set_maccount(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.maccount_.Set(value, GetArenaForAllocation());
}
inline std::string* db_account::_internal_mutable_maccount() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.maccount_.Mutable(GetArenaForAllocation());
}
inline std::string* db_account::release_maccount() {
  // @@protoc_insertion_point(field_release:pbdb.db_account.maccount)
  if (!_internal_has_maccount()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.maccount_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.maccount_.IsDefault()) {
    _impl_.maccount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void db_account::set_allocated_maccount(std::string* maccount) {
  if (maccount != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.maccount_.SetAllocated(maccount, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.maccount_.IsDefault()) {
    _impl_.maccount_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_account.maccount)
}

// optional string mpassworld = 4;
inline bool db_account::_internal_has_mpassworld() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_account::has_mpassworld() const {
  return _internal_has_mpassworld();
}
inline void db_account::clear_mpassworld() {
  _impl_.mpassworld_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& db_account::mpassworld() const {
  // @@protoc_insertion_point(field_get:pbdb.db_account.mpassworld)
  return _internal_mpassworld();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void db_account::set_mpassworld(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.mpassworld_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.db_account.mpassworld)
}
inline std::string* db_account::mutable_mpassworld() {
  std::string* _s = _internal_mutable_mpassworld();
  // @@protoc_insertion_point(field_mutable:pbdb.db_account.mpassworld)
  return _s;
}
inline const std::string& db_account::_internal_mpassworld() const {
  return _impl_.mpassworld_.Get();
}
inline void db_account::_internal_set_mpassworld(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mpassworld_.Set(value, GetArenaForAllocation());
}
inline std::string* db_account::_internal_mutable_mpassworld() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mpassworld_.Mutable(GetArenaForAllocation());
}
inline std::string* db_account::release_mpassworld() {
  // @@protoc_insertion_point(field_release:pbdb.db_account.mpassworld)
  if (!_internal_has_mpassworld()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.mpassworld_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mpassworld_.IsDefault()) {
    _impl_.mpassworld_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void db_account::set_allocated_mpassworld(std::string* mpassworld) {
  if (mpassworld != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mpassworld_.SetAllocated(mpassworld, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mpassworld_.IsDefault()) {
    _impl_.mpassworld_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_account.mpassworld)
}

// optional int32 marea = 5;
inline bool db_account::_internal_has_marea() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool db_account::has_marea() const {
  return _internal_has_marea();
}
inline void db_account::clear_marea() {
  _impl_.marea_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t db_account::_internal_marea() const {
  return _impl_.marea_;
}
inline int32_t db_account::marea() const {
  // @@protoc_insertion_point(field_get:pbdb.db_account.marea)
  return _internal_marea();
}
inline void db_account::_internal_set_marea(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.marea_ = value;
}
inline void db_account::set_marea(int32_t value) {
  _internal_set_marea(value);
  // @@protoc_insertion_point(field_set:pbdb.db_account.marea)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// brief_activityvalues

// map<int32, int32> mactivity_rolelv = 1;
inline int brief_activityvalues::_internal_mactivity_rolelv_size() const {
  return _impl_.mactivity_rolelv_.size();
}
inline int brief_activityvalues::mactivity_rolelv_size() const {
  return _internal_mactivity_rolelv_size();
}
inline void brief_activityvalues::clear_mactivity_rolelv() {
  _impl_.mactivity_rolelv_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >&
brief_activityvalues::_internal_mactivity_rolelv() const {
  return _impl_.mactivity_rolelv_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >&
brief_activityvalues::mactivity_rolelv() const {
  // @@protoc_insertion_point(field_map:pbdb.brief_activityvalues.mactivity_rolelv)
  return _internal_mactivity_rolelv();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >*
brief_activityvalues::_internal_mutable_mactivity_rolelv() {
  return _impl_.mactivity_rolelv_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >*
brief_activityvalues::mutable_mactivity_rolelv() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.brief_activityvalues.mactivity_rolelv)
  return _internal_mutable_mactivity_rolelv();
}

// map<int32, int32> mactivity_rolegold = 2;
inline int brief_activityvalues::_internal_mactivity_rolegold_size() const {
  return _impl_.mactivity_rolegold_.size();
}
inline int brief_activityvalues::mactivity_rolegold_size() const {
  return _internal_mactivity_rolegold_size();
}
inline void brief_activityvalues::clear_mactivity_rolegold() {
  _impl_.mactivity_rolegold_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >&
brief_activityvalues::_internal_mactivity_rolegold() const {
  return _impl_.mactivity_rolegold_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >&
brief_activityvalues::mactivity_rolegold() const {
  // @@protoc_insertion_point(field_map:pbdb.brief_activityvalues.mactivity_rolegold)
  return _internal_mactivity_rolegold();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >*
brief_activityvalues::_internal_mutable_mactivity_rolegold() {
  return _impl_.mactivity_rolegold_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, int32_t >*
brief_activityvalues::mutable_mactivity_rolegold() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.brief_activityvalues.mactivity_rolegold)
  return _internal_mutable_mactivity_rolegold();
}

// -------------------------------------------------------------------

// db_brief

// optional int64 mid = 1;
inline bool db_brief::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_brief::has_mid() const {
  return _internal_has_mid();
}
inline void db_brief::clear_mid() {
  _impl_.mid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t db_brief::_internal_mid() const {
  return _impl_.mid_;
}
inline int64_t db_brief::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.mid)
  return _internal_mid();
}
inline void db_brief::_internal_set_mid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mid_ = value;
}
inline void db_brief::set_mid(int64_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_brief.mid)
}

// optional string mname = 2;
inline bool db_brief::_internal_has_mname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_brief::has_mname() const {
  return _internal_has_mname();
}
inline void db_brief::clear_mname() {
  _impl_.mname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& db_brief::mname() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.mname)
  return _internal_mname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void db_brief::set_mname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.mname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.db_brief.mname)
}
inline std::string* db_brief::mutable_mname() {
  std::string* _s = _internal_mutable_mname();
  // @@protoc_insertion_point(field_mutable:pbdb.db_brief.mname)
  return _s;
}
inline const std::string& db_brief::_internal_mname() const {
  return _impl_.mname_.Get();
}
inline void db_brief::_internal_set_mname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mname_.Set(value, GetArenaForAllocation());
}
inline std::string* db_brief::_internal_mutable_mname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mname_.Mutable(GetArenaForAllocation());
}
inline std::string* db_brief::release_mname() {
  // @@protoc_insertion_point(field_release:pbdb.db_brief.mname)
  if (!_internal_has_mname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.mname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mname_.IsDefault()) {
    _impl_.mname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void db_brief::set_allocated_mname(std::string* mname) {
  if (mname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mname_.SetAllocated(mname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mname_.IsDefault()) {
    _impl_.mname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_brief.mname)
}

// optional int32 mlv = 3;
inline bool db_brief::_internal_has_mlv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool db_brief::has_mlv() const {
  return _internal_has_mlv();
}
inline void db_brief::clear_mlv() {
  _impl_.mlv_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t db_brief::_internal_mlv() const {
  return _impl_.mlv_;
}
inline int32_t db_brief::mlv() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.mlv)
  return _internal_mlv();
}
inline void db_brief::_internal_set_mlv(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mlv_ = value;
}
inline void db_brief::set_mlv(int32_t value) {
  _internal_set_mlv(value);
  // @@protoc_insertion_point(field_set:pbdb.db_brief.mlv)
}

// optional int32 mmoneygold = 4;
inline bool db_brief::_internal_has_mmoneygold() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool db_brief::has_mmoneygold() const {
  return _internal_has_mmoneygold();
}
inline void db_brief::clear_mmoneygold() {
  _impl_.mmoneygold_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t db_brief::_internal_mmoneygold() const {
  return _impl_.mmoneygold_;
}
inline int32_t db_brief::mmoneygold() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.mmoneygold)
  return _internal_mmoneygold();
}
inline void db_brief::_internal_set_mmoneygold(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.mmoneygold_ = value;
}
inline void db_brief::set_mmoneygold(int32_t value) {
  _internal_set_mmoneygold(value);
  // @@protoc_insertion_point(field_set:pbdb.db_brief.mmoneygold)
}

// optional int32 mmoneysilver = 5;
inline bool db_brief::_internal_has_mmoneysilver() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool db_brief::has_mmoneysilver() const {
  return _internal_has_mmoneysilver();
}
inline void db_brief::clear_mmoneysilver() {
  _impl_.mmoneysilver_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t db_brief::_internal_mmoneysilver() const {
  return _impl_.mmoneysilver_;
}
inline int32_t db_brief::mmoneysilver() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.mmoneysilver)
  return _internal_mmoneysilver();
}
inline void db_brief::_internal_set_mmoneysilver(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.mmoneysilver_ = value;
}
inline void db_brief::set_mmoneysilver(int32_t value) {
  _internal_set_mmoneysilver(value);
  // @@protoc_insertion_point(field_set:pbdb.db_brief.mmoneysilver)
}

// optional int32 mvip = 6;
inline bool db_brief::_internal_has_mvip() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool db_brief::has_mvip() const {
  return _internal_has_mvip();
}
inline void db_brief::clear_mvip() {
  _impl_.mvip_ = 0;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline int32_t db_brief::_internal_mvip() const {
  return _impl_.mvip_;
}
inline int32_t db_brief::mvip() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.mvip)
  return _internal_mvip();
}
inline void db_brief::_internal_set_mvip(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.mvip_ = value;
}
inline void db_brief::set_mvip(int32_t value) {
  _internal_set_mvip(value);
  // @@protoc_insertion_point(field_set:pbdb.db_brief.mvip)
}

// optional int32 mnotalkutc = 7;
inline bool db_brief::_internal_has_mnotalkutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool db_brief::has_mnotalkutc() const {
  return _internal_has_mnotalkutc();
}
inline void db_brief::clear_mnotalkutc() {
  _impl_.mnotalkutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline int32_t db_brief::_internal_mnotalkutc() const {
  return _impl_.mnotalkutc_;
}
inline int32_t db_brief::mnotalkutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.mnotalkutc)
  return _internal_mnotalkutc();
}
inline void db_brief::_internal_set_mnotalkutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.mnotalkutc_ = value;
}
inline void db_brief::set_mnotalkutc(int32_t value) {
  _internal_set_mnotalkutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_brief.mnotalkutc)
}

// optional int32 mcreateutc = 8;
inline bool db_brief::_internal_has_mcreateutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool db_brief::has_mcreateutc() const {
  return _internal_has_mcreateutc();
}
inline void db_brief::clear_mcreateutc() {
  _impl_.mcreateutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline int32_t db_brief::_internal_mcreateutc() const {
  return _impl_.mcreateutc_;
}
inline int32_t db_brief::mcreateutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.mcreateutc)
  return _internal_mcreateutc();
}
inline void db_brief::_internal_set_mcreateutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.mcreateutc_ = value;
}
inline void db_brief::set_mcreateutc(int32_t value) {
  _internal_set_mcreateutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_brief.mcreateutc)
}

// optional .pbdb.brief_activityvalues mactivityvalues = 9;
inline bool db_brief::_internal_has_mactivityvalues() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mactivityvalues_ != nullptr);
  return value;
}
inline bool db_brief::has_mactivityvalues() const {
  return _internal_has_mactivityvalues();
}
inline void db_brief::clear_mactivityvalues() {
  if (_impl_.mactivityvalues_ != nullptr) _impl_.mactivityvalues_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::pbdb::brief_activityvalues& db_brief::_internal_mactivityvalues() const {
  const ::pbdb::brief_activityvalues* p = _impl_.mactivityvalues_;
  return p != nullptr ? *p : reinterpret_cast<const ::pbdb::brief_activityvalues&>(
      ::pbdb::_brief_activityvalues_default_instance_);
}
inline const ::pbdb::brief_activityvalues& db_brief::mactivityvalues() const {
  // @@protoc_insertion_point(field_get:pbdb.db_brief.mactivityvalues)
  return _internal_mactivityvalues();
}
inline void db_brief::unsafe_arena_set_allocated_mactivityvalues(
    ::pbdb::brief_activityvalues* mactivityvalues) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mactivityvalues_);
  }
  _impl_.mactivityvalues_ = mactivityvalues;
  if (mactivityvalues) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:pbdb.db_brief.mactivityvalues)
}
inline ::pbdb::brief_activityvalues* db_brief::release_mactivityvalues() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pbdb::brief_activityvalues* temp = _impl_.mactivityvalues_;
  _impl_.mactivityvalues_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::pbdb::brief_activityvalues* db_brief::unsafe_arena_release_mactivityvalues() {
  // @@protoc_insertion_point(field_release:pbdb.db_brief.mactivityvalues)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::pbdb::brief_activityvalues* temp = _impl_.mactivityvalues_;
  _impl_.mactivityvalues_ = nullptr;
  return temp;
}
inline ::pbdb::brief_activityvalues* db_brief::_internal_mutable_mactivityvalues() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.mactivityvalues_ == nullptr) {
    auto* p = CreateMaybeMessage<::pbdb::brief_activityvalues>(GetArenaForAllocation());
    _impl_.mactivityvalues_ = p;
  }
  return _impl_.mactivityvalues_;
}
inline ::pbdb::brief_activityvalues* db_brief::mutable_mactivityvalues() {
  ::pbdb::brief_activityvalues* _msg = _internal_mutable_mactivityvalues();
  // @@protoc_insertion_point(field_mutable:pbdb.db_brief.mactivityvalues)
  return _msg;
}
inline void db_brief::set_allocated_mactivityvalues(::pbdb::brief_activityvalues* mactivityvalues) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mactivityvalues_;
  }
  if (mactivityvalues) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mactivityvalues);
    if (message_arena != submessage_arena) {
      mactivityvalues = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mactivityvalues, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mactivityvalues_ = mactivityvalues;
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_brief.mactivityvalues)
}

// -------------------------------------------------------------------

// db_role_recharge

// optional int32 mrechargeid = 1;
inline bool db_role_recharge::_internal_has_mrechargeid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_role_recharge::has_mrechargeid() const {
  return _internal_has_mrechargeid();
}
inline void db_role_recharge::clear_mrechargeid() {
  _impl_.mrechargeid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t db_role_recharge::_internal_mrechargeid() const {
  return _impl_.mrechargeid_;
}
inline int32_t db_role_recharge::mrechargeid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_role.recharge.mrechargeid)
  return _internal_mrechargeid();
}
inline void db_role_recharge::_internal_set_mrechargeid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mrechargeid_ = value;
}
inline void db_role_recharge::set_mrechargeid(int32_t value) {
  _internal_set_mrechargeid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_role.recharge.mrechargeid)
}

// optional int32 mutc = 2;
inline bool db_role_recharge::_internal_has_mutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_role_recharge::has_mutc() const {
  return _internal_has_mutc();
}
inline void db_role_recharge::clear_mutc() {
  _impl_.mutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t db_role_recharge::_internal_mutc() const {
  return _impl_.mutc_;
}
inline int32_t db_role_recharge::mutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_role.recharge.mutc)
  return _internal_mutc();
}
inline void db_role_recharge::_internal_set_mutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mutc_ = value;
}
inline void db_role_recharge::set_mutc(int32_t value) {
  _internal_set_mutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_role.recharge.mutc)
}

// -------------------------------------------------------------------

// db_role

// optional int64 mid = 1;
inline bool db_role::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_role::has_mid() const {
  return _internal_has_mid();
}
inline void db_role::clear_mid() {
  _impl_.mid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_role::_internal_mid() const {
  return _impl_.mid_;
}
inline int64_t db_role::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_role.mid)
  return _internal_mid();
}
inline void db_role::_internal_set_mid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mid_ = value;
}
inline void db_role::set_mid(int64_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_role.mid)
}

// repeated .pbdb.db_role.recharge mrecharge = 2;
inline int db_role::_internal_mrecharge_size() const {
  return _impl_.mrecharge_.size();
}
inline int db_role::mrecharge_size() const {
  return _internal_mrecharge_size();
}
inline void db_role::clear_mrecharge() {
  _impl_.mrecharge_.Clear();
}
inline ::pbdb::db_role_recharge* db_role::mutable_mrecharge(int index) {
  // @@protoc_insertion_point(field_mutable:pbdb.db_role.mrecharge)
  return _impl_.mrecharge_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_role_recharge >*
db_role::mutable_mrecharge() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.db_role.mrecharge)
  return &_impl_.mrecharge_;
}
inline const ::pbdb::db_role_recharge& db_role::_internal_mrecharge(int index) const {
  return _impl_.mrecharge_.Get(index);
}
inline const ::pbdb::db_role_recharge& db_role::mrecharge(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.db_role.mrecharge)
  return _internal_mrecharge(index);
}
inline ::pbdb::db_role_recharge* db_role::_internal_add_mrecharge() {
  return _impl_.mrecharge_.Add();
}
inline ::pbdb::db_role_recharge* db_role::add_mrecharge() {
  ::pbdb::db_role_recharge* _add = _internal_add_mrecharge();
  // @@protoc_insertion_point(field_add:pbdb.db_role.mrecharge)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_role_recharge >&
db_role::mrecharge() const {
  // @@protoc_insertion_point(field_list:pbdb.db_role.mrecharge)
  return _impl_.mrecharge_;
}

// -------------------------------------------------------------------

// item

// optional int32 mid = 1;
inline bool item::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool item::has_mid() const {
  return _internal_has_mid();
}
inline void item::clear_mid() {
  _impl_.mid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t item::_internal_mid() const {
  return _impl_.mid_;
}
inline int32_t item::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.item.mid)
  return _internal_mid();
}
inline void item::_internal_set_mid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mid_ = value;
}
inline void item::set_mid(int32_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.item.mid)
}

// optional int32 mtid = 2;
inline bool item::_internal_has_mtid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool item::has_mtid() const {
  return _internal_has_mtid();
}
inline void item::clear_mtid() {
  _impl_.mtid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t item::_internal_mtid() const {
  return _impl_.mtid_;
}
inline int32_t item::mtid() const {
  // @@protoc_insertion_point(field_get:pbdb.item.mtid)
  return _internal_mtid();
}
inline void item::_internal_set_mtid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mtid_ = value;
}
inline void item::set_mtid(int32_t value) {
  _internal_set_mtid(value);
  // @@protoc_insertion_point(field_set:pbdb.item.mtid)
}

// optional int32 mcount = 3;
inline bool item::_internal_has_mcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool item::has_mcount() const {
  return _internal_has_mcount();
}
inline void item::clear_mcount() {
  _impl_.mcount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t item::_internal_mcount() const {
  return _impl_.mcount_;
}
inline int32_t item::mcount() const {
  // @@protoc_insertion_point(field_get:pbdb.item.mcount)
  return _internal_mcount();
}
inline void item::_internal_set_mcount(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mcount_ = value;
}
inline void item::set_mcount(int32_t value) {
  _internal_set_mcount(value);
  // @@protoc_insertion_point(field_set:pbdb.item.mcount)
}

// optional int32 mlv = 4;
inline bool item::_internal_has_mlv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool item::has_mlv() const {
  return _internal_has_mlv();
}
inline void item::clear_mlv() {
  _impl_.mlv_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t item::_internal_mlv() const {
  return _impl_.mlv_;
}
inline int32_t item::mlv() const {
  // @@protoc_insertion_point(field_get:pbdb.item.mlv)
  return _internal_mlv();
}
inline void item::_internal_set_mlv(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mlv_ = value;
}
inline void item::set_mlv(int32_t value) {
  _internal_set_mlv(value);
  // @@protoc_insertion_point(field_set:pbdb.item.mlv)
}

// optional int32 mstar = 5;
inline bool item::_internal_has_mstar() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool item::has_mstar() const {
  return _internal_has_mstar();
}
inline void item::clear_mstar() {
  _impl_.mstar_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t item::_internal_mstar() const {
  return _impl_.mstar_;
}
inline int32_t item::mstar() const {
  // @@protoc_insertion_point(field_get:pbdb.item.mstar)
  return _internal_mstar();
}
inline void item::_internal_set_mstar(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.mstar_ = value;
}
inline void item::set_mstar(int32_t value) {
  _internal_set_mstar(value);
  // @@protoc_insertion_point(field_set:pbdb.item.mstar)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// db_bag

// optional int64 mid = 1;
inline bool db_bag::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_bag::has_mid() const {
  return _internal_has_mid();
}
inline void db_bag::clear_mid() {
  _impl_.mid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_bag::_internal_mid() const {
  return _impl_.mid_;
}
inline int64_t db_bag::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_bag.mid)
  return _internal_mid();
}
inline void db_bag::_internal_set_mid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mid_ = value;
}
inline void db_bag::set_mid(int64_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_bag.mid)
}

// map<int32, .pbdb.item> mitems = 2;
inline int db_bag::_internal_mitems_size() const {
  return _impl_.mitems_.size();
}
inline int db_bag::mitems_size() const {
  return _internal_mitems_size();
}
inline void db_bag::clear_mitems() {
  _impl_.mitems_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >&
db_bag::_internal_mitems() const {
  return _impl_.mitems_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >&
db_bag::mitems() const {
  // @@protoc_insertion_point(field_map:pbdb.db_bag.mitems)
  return _internal_mitems();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >*
db_bag::_internal_mutable_mitems() {
  return _impl_.mitems_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::item >*
db_bag::mutable_mitems() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_bag.mitems)
  return _internal_mutable_mitems();
}

// optional int32 mmaxid = 3;
inline bool db_bag::_internal_has_mmaxid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_bag::has_mmaxid() const {
  return _internal_has_mmaxid();
}
inline void db_bag::clear_mmaxid() {
  _impl_.mmaxid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t db_bag::_internal_mmaxid() const {
  return _impl_.mmaxid_;
}
inline int32_t db_bag::mmaxid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_bag.mmaxid)
  return _internal_mmaxid();
}
inline void db_bag::_internal_set_mmaxid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mmaxid_ = value;
}
inline void db_bag::set_mmaxid(int32_t value) {
  _internal_set_mmaxid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_bag.mmaxid)
}

// -------------------------------------------------------------------

// db_keyvalue

// optional int64 mid = 1;
inline bool db_keyvalue::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_keyvalue::has_mid() const {
  return _internal_has_mid();
}
inline void db_keyvalue::clear_mid() {
  _impl_.mid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t db_keyvalue::_internal_mid() const {
  return _impl_.mid_;
}
inline int64_t db_keyvalue::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_keyvalue.mid)
  return _internal_mid();
}
inline void db_keyvalue::_internal_set_mid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mid_ = value;
}
inline void db_keyvalue::set_mid(int64_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_keyvalue.mid)
}

// optional string mvalue = 2;
inline bool db_keyvalue::_internal_has_mvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_keyvalue::has_mvalue() const {
  return _internal_has_mvalue();
}
inline void db_keyvalue::clear_mvalue() {
  _impl_.mvalue_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& db_keyvalue::mvalue() const {
  // @@protoc_insertion_point(field_get:pbdb.db_keyvalue.mvalue)
  return _internal_mvalue();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void db_keyvalue::set_mvalue(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.mvalue_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.db_keyvalue.mvalue)
}
inline std::string* db_keyvalue::mutable_mvalue() {
  std::string* _s = _internal_mutable_mvalue();
  // @@protoc_insertion_point(field_mutable:pbdb.db_keyvalue.mvalue)
  return _s;
}
inline const std::string& db_keyvalue::_internal_mvalue() const {
  return _impl_.mvalue_.Get();
}
inline void db_keyvalue::_internal_set_mvalue(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mvalue_.Set(value, GetArenaForAllocation());
}
inline std::string* db_keyvalue::_internal_mutable_mvalue() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mvalue_.Mutable(GetArenaForAllocation());
}
inline std::string* db_keyvalue::release_mvalue() {
  // @@protoc_insertion_point(field_release:pbdb.db_keyvalue.mvalue)
  if (!_internal_has_mvalue()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.mvalue_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mvalue_.IsDefault()) {
    _impl_.mvalue_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void db_keyvalue::set_allocated_mvalue(std::string* mvalue) {
  if (mvalue != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mvalue_.SetAllocated(mvalue, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mvalue_.IsDefault()) {
    _impl_.mvalue_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_keyvalue.mvalue)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// db_rolekeyvalue

// optional int64 mid = 1;
inline bool db_rolekeyvalue::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_rolekeyvalue::has_mid() const {
  return _internal_has_mid();
}
inline void db_rolekeyvalue::clear_mid() {
  _impl_.mid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_rolekeyvalue::_internal_mid() const {
  return _impl_.mid_;
}
inline int64_t db_rolekeyvalue::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_rolekeyvalue.mid)
  return _internal_mid();
}
inline void db_rolekeyvalue::_internal_set_mid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mid_ = value;
}
inline void db_rolekeyvalue::set_mid(int64_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_rolekeyvalue.mid)
}

// map<string, string> mdata = 2;
inline int db_rolekeyvalue::_internal_mdata_size() const {
  return _impl_.mdata_.size();
}
inline int db_rolekeyvalue::mdata_size() const {
  return _internal_mdata_size();
}
inline void db_rolekeyvalue::clear_mdata() {
  _impl_.mdata_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
db_rolekeyvalue::_internal_mdata() const {
  return _impl_.mdata_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
db_rolekeyvalue::mdata() const {
  // @@protoc_insertion_point(field_map:pbdb.db_rolekeyvalue.mdata)
  return _internal_mdata();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
db_rolekeyvalue::_internal_mutable_mdata() {
  return _impl_.mdata_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
db_rolekeyvalue::mutable_mdata() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_rolekeyvalue.mdata)
  return _internal_mutable_mdata();
}

// -------------------------------------------------------------------

// mailitem

// optional int32 mitemtid = 1;
inline bool mailitem::_internal_has_mitemtid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool mailitem::has_mitemtid() const {
  return _internal_has_mitemtid();
}
inline void mailitem::clear_mitemtid() {
  _impl_.mitemtid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t mailitem::_internal_mitemtid() const {
  return _impl_.mitemtid_;
}
inline int32_t mailitem::mitemtid() const {
  // @@protoc_insertion_point(field_get:pbdb.mailitem.mitemtid)
  return _internal_mitemtid();
}
inline void mailitem::_internal_set_mitemtid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mitemtid_ = value;
}
inline void mailitem::set_mitemtid(int32_t value) {
  _internal_set_mitemtid(value);
  // @@protoc_insertion_point(field_set:pbdb.mailitem.mitemtid)
}

// optional int32 mcount = 2;
inline bool mailitem::_internal_has_mcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool mailitem::has_mcount() const {
  return _internal_has_mcount();
}
inline void mailitem::clear_mcount() {
  _impl_.mcount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t mailitem::_internal_mcount() const {
  return _impl_.mcount_;
}
inline int32_t mailitem::mcount() const {
  // @@protoc_insertion_point(field_get:pbdb.mailitem.mcount)
  return _internal_mcount();
}
inline void mailitem::_internal_set_mcount(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mcount_ = value;
}
inline void mailitem::set_mcount(int32_t value) {
  _internal_set_mcount(value);
  // @@protoc_insertion_point(field_set:pbdb.mailitem.mcount)
}

// -------------------------------------------------------------------

// mail

// optional int32 mid = 1;
inline bool mail::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool mail::has_mid() const {
  return _internal_has_mid();
}
inline void mail::clear_mid() {
  _impl_.mid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t mail::_internal_mid() const {
  return _impl_.mid_;
}
inline int32_t mail::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.mail.mid)
  return _internal_mid();
}
inline void mail::_internal_set_mid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mid_ = value;
}
inline void mail::set_mid(int32_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.mail.mid)
}

// optional int32 mcreateutc = 2;
inline bool mail::_internal_has_mcreateutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool mail::has_mcreateutc() const {
  return _internal_has_mcreateutc();
}
inline void mail::clear_mcreateutc() {
  _impl_.mcreateutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t mail::_internal_mcreateutc() const {
  return _impl_.mcreateutc_;
}
inline int32_t mail::mcreateutc() const {
  // @@protoc_insertion_point(field_get:pbdb.mail.mcreateutc)
  return _internal_mcreateutc();
}
inline void mail::_internal_set_mcreateutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mcreateutc_ = value;
}
inline void mail::set_mcreateutc(int32_t value) {
  _internal_set_mcreateutc(value);
  // @@protoc_insertion_point(field_set:pbdb.mail.mcreateutc)
}

// optional int32 mtid = 3;
inline bool mail::_internal_has_mtid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool mail::has_mtid() const {
  return _internal_has_mtid();
}
inline void mail::clear_mtid() {
  _impl_.mtid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int32_t mail::_internal_mtid() const {
  return _impl_.mtid_;
}
inline int32_t mail::mtid() const {
  // @@protoc_insertion_point(field_get:pbdb.mail.mtid)
  return _internal_mtid();
}
inline void mail::_internal_set_mtid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.mtid_ = value;
}
inline void mail::set_mtid(int32_t value) {
  _internal_set_mtid(value);
  // @@protoc_insertion_point(field_set:pbdb.mail.mtid)
}

// optional string mprams = 4;
inline bool mail::_internal_has_mprams() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool mail::has_mprams() const {
  return _internal_has_mprams();
}
inline void mail::clear_mprams() {
  _impl_.mprams_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& mail::mprams() const {
  // @@protoc_insertion_point(field_get:pbdb.mail.mprams)
  return _internal_mprams();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void mail::set_mprams(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.mprams_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.mail.mprams)
}
inline std::string* mail::mutable_mprams() {
  std::string* _s = _internal_mutable_mprams();
  // @@protoc_insertion_point(field_mutable:pbdb.mail.mprams)
  return _s;
}
inline const std::string& mail::_internal_mprams() const {
  return _impl_.mprams_.Get();
}
inline void mail::_internal_set_mprams(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mprams_.Set(value, GetArenaForAllocation());
}
inline std::string* mail::_internal_mutable_mprams() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mprams_.Mutable(GetArenaForAllocation());
}
inline std::string* mail::release_mprams() {
  // @@protoc_insertion_point(field_release:pbdb.mail.mprams)
  if (!_internal_has_mprams()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.mprams_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mprams_.IsDefault()) {
    _impl_.mprams_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void mail::set_allocated_mprams(std::string* mprams) {
  if (mprams != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mprams_.SetAllocated(mprams, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mprams_.IsDefault()) {
    _impl_.mprams_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.mail.mprams)
}

// optional string mcontent = 5;
inline bool mail::_internal_has_mcontent() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool mail::has_mcontent() const {
  return _internal_has_mcontent();
}
inline void mail::clear_mcontent() {
  _impl_.mcontent_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& mail::mcontent() const {
  // @@protoc_insertion_point(field_get:pbdb.mail.mcontent)
  return _internal_mcontent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void mail::set_mcontent(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.mcontent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.mail.mcontent)
}
inline std::string* mail::mutable_mcontent() {
  std::string* _s = _internal_mutable_mcontent();
  // @@protoc_insertion_point(field_mutable:pbdb.mail.mcontent)
  return _s;
}
inline const std::string& mail::_internal_mcontent() const {
  return _impl_.mcontent_.Get();
}
inline void mail::_internal_set_mcontent(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mcontent_.Set(value, GetArenaForAllocation());
}
inline std::string* mail::_internal_mutable_mcontent() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mcontent_.Mutable(GetArenaForAllocation());
}
inline std::string* mail::release_mcontent() {
  // @@protoc_insertion_point(field_release:pbdb.mail.mcontent)
  if (!_internal_has_mcontent()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.mcontent_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mcontent_.IsDefault()) {
    _impl_.mcontent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void mail::set_allocated_mcontent(std::string* mcontent) {
  if (mcontent != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mcontent_.SetAllocated(mcontent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mcontent_.IsDefault()) {
    _impl_.mcontent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.mail.mcontent)
}

// repeated .pbdb.mailitem mitems = 6;
inline int mail::_internal_mitems_size() const {
  return _impl_.mitems_.size();
}
inline int mail::mitems_size() const {
  return _internal_mitems_size();
}
inline void mail::clear_mitems() {
  _impl_.mitems_.Clear();
}
inline ::pbdb::mailitem* mail::mutable_mitems(int index) {
  // @@protoc_insertion_point(field_mutable:pbdb.mail.mitems)
  return _impl_.mitems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::mailitem >*
mail::mutable_mitems() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.mail.mitems)
  return &_impl_.mitems_;
}
inline const ::pbdb::mailitem& mail::_internal_mitems(int index) const {
  return _impl_.mitems_.Get(index);
}
inline const ::pbdb::mailitem& mail::mitems(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.mail.mitems)
  return _internal_mitems(index);
}
inline ::pbdb::mailitem* mail::_internal_add_mitems() {
  return _impl_.mitems_.Add();
}
inline ::pbdb::mailitem* mail::add_mitems() {
  ::pbdb::mailitem* _add = _internal_add_mitems();
  // @@protoc_insertion_point(field_add:pbdb.mail.mitems)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::mailitem >&
mail::mitems() const {
  // @@protoc_insertion_point(field_list:pbdb.mail.mitems)
  return _impl_.mitems_;
}

// optional bool mread = 7;
inline bool mail::_internal_has_mread() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool mail::has_mread() const {
  return _internal_has_mread();
}
inline void mail::clear_mread() {
  _impl_.mread_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool mail::_internal_mread() const {
  return _impl_.mread_;
}
inline bool mail::mread() const {
  // @@protoc_insertion_point(field_get:pbdb.mail.mread)
  return _internal_mread();
}
inline void mail::_internal_set_mread(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.mread_ = value;
}
inline void mail::set_mread(bool value) {
  _internal_set_mread(value);
  // @@protoc_insertion_point(field_set:pbdb.mail.mread)
}

// optional bool mdraw = 8;
inline bool mail::_internal_has_mdraw() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool mail::has_mdraw() const {
  return _internal_has_mdraw();
}
inline void mail::clear_mdraw() {
  _impl_.mdraw_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool mail::_internal_mdraw() const {
  return _impl_.mdraw_;
}
inline bool mail::mdraw() const {
  // @@protoc_insertion_point(field_get:pbdb.mail.mdraw)
  return _internal_mdraw();
}
inline void mail::_internal_set_mdraw(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.mdraw_ = value;
}
inline void mail::set_mdraw(bool value) {
  _internal_set_mdraw(value);
  // @@protoc_insertion_point(field_set:pbdb.mail.mdraw)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// db_mail

// optional int64 mid = 1;
inline bool db_mail::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_mail::has_mid() const {
  return _internal_has_mid();
}
inline void db_mail::clear_mid() {
  _impl_.mid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_mail::_internal_mid() const {
  return _impl_.mid_;
}
inline int64_t db_mail::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_mail.mid)
  return _internal_mid();
}
inline void db_mail::_internal_set_mid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mid_ = value;
}
inline void db_mail::set_mid(int64_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_mail.mid)
}

// map<int32, .pbdb.mail> mmail = 2;
inline int db_mail::_internal_mmail_size() const {
  return _impl_.mmail_.size();
}
inline int db_mail::mmail_size() const {
  return _internal_mmail_size();
}
inline void db_mail::clear_mmail() {
  _impl_.mmail_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >&
db_mail::_internal_mmail() const {
  return _impl_.mmail_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >&
db_mail::mmail() const {
  // @@protoc_insertion_point(field_map:pbdb.db_mail.mmail)
  return _internal_mmail();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >*
db_mail::_internal_mutable_mmail() {
  return _impl_.mmail_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::mail >*
db_mail::mutable_mmail() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_mail.mmail)
  return _internal_mutable_mmail();
}

// -------------------------------------------------------------------

// db_notice

// optional int64 mid = 1;
inline bool db_notice::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_notice::has_mid() const {
  return _internal_has_mid();
}
inline void db_notice::clear_mid() {
  _impl_.mid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t db_notice::_internal_mid() const {
  return _impl_.mid_;
}
inline int64_t db_notice::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_notice.mid)
  return _internal_mid();
}
inline void db_notice::_internal_set_mid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mid_ = value;
}
inline void db_notice::set_mid(int64_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_notice.mid)
}

// optional string mnotice = 2;
inline bool db_notice::_internal_has_mnotice() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_notice::has_mnotice() const {
  return _internal_has_mnotice();
}
inline void db_notice::clear_mnotice() {
  _impl_.mnotice_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& db_notice::mnotice() const {
  // @@protoc_insertion_point(field_get:pbdb.db_notice.mnotice)
  return _internal_mnotice();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void db_notice::set_mnotice(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.mnotice_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.db_notice.mnotice)
}
inline std::string* db_notice::mutable_mnotice() {
  std::string* _s = _internal_mutable_mnotice();
  // @@protoc_insertion_point(field_mutable:pbdb.db_notice.mnotice)
  return _s;
}
inline const std::string& db_notice::_internal_mnotice() const {
  return _impl_.mnotice_.Get();
}
inline void db_notice::_internal_set_mnotice(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mnotice_.Set(value, GetArenaForAllocation());
}
inline std::string* db_notice::_internal_mutable_mnotice() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mnotice_.Mutable(GetArenaForAllocation());
}
inline std::string* db_notice::release_mnotice() {
  // @@protoc_insertion_point(field_release:pbdb.db_notice.mnotice)
  if (!_internal_has_mnotice()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.mnotice_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mnotice_.IsDefault()) {
    _impl_.mnotice_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void db_notice::set_allocated_mnotice(std::string* mnotice) {
  if (mnotice != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mnotice_.SetAllocated(mnotice, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mnotice_.IsDefault()) {
    _impl_.mnotice_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_notice.mnotice)
}

// optional int32 mstarttime = 3;
inline bool db_notice::_internal_has_mstarttime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_notice::has_mstarttime() const {
  return _internal_has_mstarttime();
}
inline void db_notice::clear_mstarttime() {
  _impl_.mstarttime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t db_notice::_internal_mstarttime() const {
  return _impl_.mstarttime_;
}
inline int32_t db_notice::mstarttime() const {
  // @@protoc_insertion_point(field_get:pbdb.db_notice.mstarttime)
  return _internal_mstarttime();
}
inline void db_notice::_internal_set_mstarttime(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mstarttime_ = value;
}
inline void db_notice::set_mstarttime(int32_t value) {
  _internal_set_mstarttime(value);
  // @@protoc_insertion_point(field_set:pbdb.db_notice.mstarttime)
}

// optional int32 mfinishtime = 4;
inline bool db_notice::_internal_has_mfinishtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool db_notice::has_mfinishtime() const {
  return _internal_has_mfinishtime();
}
inline void db_notice::clear_mfinishtime() {
  _impl_.mfinishtime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t db_notice::_internal_mfinishtime() const {
  return _impl_.mfinishtime_;
}
inline int32_t db_notice::mfinishtime() const {
  // @@protoc_insertion_point(field_get:pbdb.db_notice.mfinishtime)
  return _internal_mfinishtime();
}
inline void db_notice::_internal_set_mfinishtime(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mfinishtime_ = value;
}
inline void db_notice::set_mfinishtime(int32_t value) {
  _internal_set_mfinishtime(value);
  // @@protoc_insertion_point(field_set:pbdb.db_notice.mfinishtime)
}

// -------------------------------------------------------------------

// rankitem

// optional int64 mvalue = 1;
inline bool rankitem::_internal_has_mvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool rankitem::has_mvalue() const {
  return _internal_has_mvalue();
}
inline void rankitem::clear_mvalue() {
  _impl_.mvalue_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t rankitem::_internal_mvalue() const {
  return _impl_.mvalue_;
}
inline int64_t rankitem::mvalue() const {
  // @@protoc_insertion_point(field_get:pbdb.rankitem.mvalue)
  return _internal_mvalue();
}
inline void rankitem::_internal_set_mvalue(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mvalue_ = value;
}
inline void rankitem::set_mvalue(int64_t value) {
  _internal_set_mvalue(value);
  // @@protoc_insertion_point(field_set:pbdb.rankitem.mvalue)
}

// optional int32 mtime = 2;
inline bool rankitem::_internal_has_mtime() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool rankitem::has_mtime() const {
  return _internal_has_mtime();
}
inline void rankitem::clear_mtime() {
  _impl_.mtime_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t rankitem::_internal_mtime() const {
  return _impl_.mtime_;
}
inline int32_t rankitem::mtime() const {
  // @@protoc_insertion_point(field_get:pbdb.rankitem.mtime)
  return _internal_mtime();
}
inline void rankitem::_internal_set_mtime(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mtime_ = value;
}
inline void rankitem::set_mtime(int32_t value) {
  _internal_set_mtime(value);
  // @@protoc_insertion_point(field_set:pbdb.rankitem.mtime)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// db_ranklist

// optional int64 mid = 1;
inline bool db_ranklist::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_ranklist::has_mid() const {
  return _internal_has_mid();
}
inline void db_ranklist::clear_mid() {
  _impl_.mid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_ranklist::_internal_mid() const {
  return _impl_.mid_;
}
inline int64_t db_ranklist::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_ranklist.mid)
  return _internal_mid();
}
inline void db_ranklist::_internal_set_mid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mid_ = value;
}
inline void db_ranklist::set_mid(int64_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_ranklist.mid)
}

// map<int32, .pbdb.rankitem> mitems = 2;
inline int db_ranklist::_internal_mitems_size() const {
  return _impl_.mitems_.size();
}
inline int db_ranklist::mitems_size() const {
  return _internal_mitems_size();
}
inline void db_ranklist::clear_mitems() {
  _impl_.mitems_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >&
db_ranklist::_internal_mitems() const {
  return _impl_.mitems_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >&
db_ranklist::mitems() const {
  // @@protoc_insertion_point(field_map:pbdb.db_ranklist.mitems)
  return _internal_mitems();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >*
db_ranklist::_internal_mutable_mitems() {
  return _impl_.mitems_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::rankitem >*
db_ranklist::mutable_mitems() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_ranklist.mitems)
  return _internal_mutable_mitems();
}

// -------------------------------------------------------------------

// db_activitytimes

// optional int64 mid = 1;
inline bool db_activitytimes::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_activitytimes::has_mid() const {
  return _internal_has_mid();
}
inline void db_activitytimes::clear_mid() {
  _impl_.mid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_activitytimes::_internal_mid() const {
  return _impl_.mid_;
}
inline int64_t db_activitytimes::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_activitytimes.mid)
  return _internal_mid();
}
inline void db_activitytimes::_internal_set_mid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mid_ = value;
}
inline void db_activitytimes::set_mid(int64_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_activitytimes.mid)
}

// optional int32 mbeg = 2;
inline bool db_activitytimes::_internal_has_mbeg() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_activitytimes::has_mbeg() const {
  return _internal_has_mbeg();
}
inline void db_activitytimes::clear_mbeg() {
  _impl_.mbeg_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t db_activitytimes::_internal_mbeg() const {
  return _impl_.mbeg_;
}
inline int32_t db_activitytimes::mbeg() const {
  // @@protoc_insertion_point(field_get:pbdb.db_activitytimes.mbeg)
  return _internal_mbeg();
}
inline void db_activitytimes::_internal_set_mbeg(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mbeg_ = value;
}
inline void db_activitytimes::set_mbeg(int32_t value) {
  _internal_set_mbeg(value);
  // @@protoc_insertion_point(field_set:pbdb.db_activitytimes.mbeg)
}

// optional int32 mduration = 3;
inline bool db_activitytimes::_internal_has_mduration() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_activitytimes::has_mduration() const {
  return _internal_has_mduration();
}
inline void db_activitytimes::clear_mduration() {
  _impl_.mduration_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t db_activitytimes::_internal_mduration() const {
  return _impl_.mduration_;
}
inline int32_t db_activitytimes::mduration() const {
  // @@protoc_insertion_point(field_get:pbdb.db_activitytimes.mduration)
  return _internal_mduration();
}
inline void db_activitytimes::_internal_set_mduration(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mduration_ = value;
}
inline void db_activitytimes::set_mduration(int32_t value) {
  _internal_set_mduration(value);
  // @@protoc_insertion_point(field_set:pbdb.db_activitytimes.mduration)
}

// optional bool mstart = 4;
inline bool db_activitytimes::_internal_has_mstart() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool db_activitytimes::has_mstart() const {
  return _internal_has_mstart();
}
inline void db_activitytimes::clear_mstart() {
  _impl_.mstart_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool db_activitytimes::_internal_mstart() const {
  return _impl_.mstart_;
}
inline bool db_activitytimes::mstart() const {
  // @@protoc_insertion_point(field_get:pbdb.db_activitytimes.mstart)
  return _internal_mstart();
}
inline void db_activitytimes::_internal_set_mstart(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mstart_ = value;
}
inline void db_activitytimes::set_mstart(bool value) {
  _internal_set_mstart(value);
  // @@protoc_insertion_point(field_set:pbdb.db_activitytimes.mstart)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// activity_task

// map<int32, bool> mopen = 1;
inline int activity_task::_internal_mopen_size() const {
  return _impl_.mopen_.size();
}
inline int activity_task::mopen_size() const {
  return _internal_mopen_size();
}
inline void activity_task::clear_mopen() {
  _impl_.mopen_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >&
activity_task::_internal_mopen() const {
  return _impl_.mopen_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >&
activity_task::mopen() const {
  // @@protoc_insertion_point(field_map:pbdb.activity_task.mopen)
  return _internal_mopen();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >*
activity_task::_internal_mutable_mopen() {
  return _impl_.mopen_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >*
activity_task::mutable_mopen() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.activity_task.mopen)
  return _internal_mutable_mopen();
}

// map<int32, bool> mclose = 2;
inline int activity_task::_internal_mclose_size() const {
  return _impl_.mclose_.size();
}
inline int activity_task::mclose_size() const {
  return _internal_mclose_size();
}
inline void activity_task::clear_mclose() {
  _impl_.mclose_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >&
activity_task::_internal_mclose() const {
  return _impl_.mclose_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >&
activity_task::mclose() const {
  // @@protoc_insertion_point(field_map:pbdb.activity_task.mclose)
  return _internal_mclose();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >*
activity_task::_internal_mutable_mclose() {
  return _impl_.mclose_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >*
activity_task::mutable_mclose() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.activity_task.mclose)
  return _internal_mutable_mclose();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// activity_drawcompliance

// optional int32 mcount = 1;
inline bool activity_drawcompliance::_internal_has_mcount() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool activity_drawcompliance::has_mcount() const {
  return _internal_has_mcount();
}
inline void activity_drawcompliance::clear_mcount() {
  _impl_.mcount_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t activity_drawcompliance::_internal_mcount() const {
  return _impl_.mcount_;
}
inline int32_t activity_drawcompliance::mcount() const {
  // @@protoc_insertion_point(field_get:pbdb.activity_drawcompliance.mcount)
  return _internal_mcount();
}
inline void activity_drawcompliance::_internal_set_mcount(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mcount_ = value;
}
inline void activity_drawcompliance::set_mcount(int32_t value) {
  _internal_set_mcount(value);
  // @@protoc_insertion_point(field_set:pbdb.activity_drawcompliance.mcount)
}

// map<int32, bool> mreward = 2;
inline int activity_drawcompliance::_internal_mreward_size() const {
  return _impl_.mreward_.size();
}
inline int activity_drawcompliance::mreward_size() const {
  return _internal_mreward_size();
}
inline void activity_drawcompliance::clear_mreward() {
  _impl_.mreward_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >&
activity_drawcompliance::_internal_mreward() const {
  return _impl_.mreward_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >&
activity_drawcompliance::mreward() const {
  // @@protoc_insertion_point(field_map:pbdb.activity_drawcompliance.mreward)
  return _internal_mreward();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >*
activity_drawcompliance::_internal_mutable_mreward() {
  return _impl_.mreward_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, bool >*
activity_drawcompliance::mutable_mreward() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.activity_drawcompliance.mreward)
  return _internal_mutable_mreward();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// db_activity

// optional int64 mid = 1;
inline bool db_activity::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_activity::has_mid() const {
  return _internal_has_mid();
}
inline void db_activity::clear_mid() {
  _impl_.mid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_activity::_internal_mid() const {
  return _impl_.mid_;
}
inline int64_t db_activity::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_activity.mid)
  return _internal_mid();
}
inline void db_activity::_internal_set_mid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mid_ = value;
}
inline void db_activity::set_mid(int64_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_activity.mid)
}

// map<int64, .pbdb.activity_task> mtask = 2;
inline int db_activity::_internal_mtask_size() const {
  return _impl_.mtask_.size();
}
inline int db_activity::mtask_size() const {
  return _internal_mtask_size();
}
inline void db_activity::clear_mtask() {
  _impl_.mtask_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::activity_task >&
db_activity::_internal_mtask() const {
  return _impl_.mtask_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::activity_task >&
db_activity::mtask() const {
  // @@protoc_insertion_point(field_map:pbdb.db_activity.mtask)
  return _internal_mtask();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::activity_task >*
db_activity::_internal_mutable_mtask() {
  return _impl_.mtask_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::activity_task >*
db_activity::mutable_mtask() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_activity.mtask)
  return _internal_mutable_mtask();
}

// map<int64, .pbdb.activity_drawcompliance> mdrawcompliance = 3;
inline int db_activity::_internal_mdrawcompliance_size() const {
  return _impl_.mdrawcompliance_.size();
}
inline int db_activity::mdrawcompliance_size() const {
  return _internal_mdrawcompliance_size();
}
inline void db_activity::clear_mdrawcompliance() {
  _impl_.mdrawcompliance_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::activity_drawcompliance >&
db_activity::_internal_mdrawcompliance() const {
  return _impl_.mdrawcompliance_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::activity_drawcompliance >&
db_activity::mdrawcompliance() const {
  // @@protoc_insertion_point(field_map:pbdb.db_activity.mdrawcompliance)
  return _internal_mdrawcompliance();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::activity_drawcompliance >*
db_activity::_internal_mutable_mdrawcompliance() {
  return _impl_.mdrawcompliance_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int64_t, ::pbdb::activity_drawcompliance >*
db_activity::mutable_mdrawcompliance() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_activity.mdrawcompliance)
  return _internal_mutable_mdrawcompliance();
}

// -------------------------------------------------------------------

// db_task_data_schedule

// optional int32 mtype = 1;
inline bool db_task_data_schedule::_internal_has_mtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_task_data_schedule::has_mtype() const {
  return _internal_has_mtype();
}
inline void db_task_data_schedule::clear_mtype() {
  _impl_.mtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t db_task_data_schedule::_internal_mtype() const {
  return _impl_.mtype_;
}
inline int32_t db_task_data_schedule::mtype() const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.data_schedule.mtype)
  return _internal_mtype();
}
inline void db_task_data_schedule::_internal_set_mtype(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mtype_ = value;
}
inline void db_task_data_schedule::set_mtype(int32_t value) {
  _internal_set_mtype(value);
  // @@protoc_insertion_point(field_set:pbdb.db_task.data_schedule.mtype)
}

// optional int32 mvalue = 2;
inline bool db_task_data_schedule::_internal_has_mvalue() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_task_data_schedule::has_mvalue() const {
  return _internal_has_mvalue();
}
inline void db_task_data_schedule::clear_mvalue() {
  _impl_.mvalue_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t db_task_data_schedule::_internal_mvalue() const {
  return _impl_.mvalue_;
}
inline int32_t db_task_data_schedule::mvalue() const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.data_schedule.mvalue)
  return _internal_mvalue();
}
inline void db_task_data_schedule::_internal_set_mvalue(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mvalue_ = value;
}
inline void db_task_data_schedule::set_mvalue(int32_t value) {
  _internal_set_mvalue(value);
  // @@protoc_insertion_point(field_set:pbdb.db_task.data_schedule.mvalue)
}

// optional int32 msumint = 3;
inline bool db_task_data_schedule::_internal_has_msumint() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_task_data_schedule::has_msumint() const {
  return _internal_has_msumint();
}
inline void db_task_data_schedule::clear_msumint() {
  _impl_.msumint_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t db_task_data_schedule::_internal_msumint() const {
  return _impl_.msumint_;
}
inline int32_t db_task_data_schedule::msumint() const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.data_schedule.msumint)
  return _internal_msumint();
}
inline void db_task_data_schedule::_internal_set_msumint(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.msumint_ = value;
}
inline void db_task_data_schedule::set_msumint(int32_t value) {
  _internal_set_msumint(value);
  // @@protoc_insertion_point(field_set:pbdb.db_task.data_schedule.msumint)
}

// -------------------------------------------------------------------

// db_task_data

// optional int32 mtaskid = 1;
inline bool db_task_data::_internal_has_mtaskid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_task_data::has_mtaskid() const {
  return _internal_has_mtaskid();
}
inline void db_task_data::clear_mtaskid() {
  _impl_.mtaskid_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t db_task_data::_internal_mtaskid() const {
  return _impl_.mtaskid_;
}
inline int32_t db_task_data::mtaskid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.data.mtaskid)
  return _internal_mtaskid();
}
inline void db_task_data::_internal_set_mtaskid(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mtaskid_ = value;
}
inline void db_task_data::set_mtaskid(int32_t value) {
  _internal_set_mtaskid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_task.data.mtaskid)
}

// optional int32 mreceiveutc = 2;
inline bool db_task_data::_internal_has_mreceiveutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_task_data::has_mreceiveutc() const {
  return _internal_has_mreceiveutc();
}
inline void db_task_data::clear_mreceiveutc() {
  _impl_.mreceiveutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t db_task_data::_internal_mreceiveutc() const {
  return _impl_.mreceiveutc_;
}
inline int32_t db_task_data::mreceiveutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.data.mreceiveutc)
  return _internal_mreceiveutc();
}
inline void db_task_data::_internal_set_mreceiveutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mreceiveutc_ = value;
}
inline void db_task_data::set_mreceiveutc(int32_t value) {
  _internal_set_mreceiveutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_task.data.mreceiveutc)
}

// optional int32 mfinshutc = 3;
inline bool db_task_data::_internal_has_mfinshutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_task_data::has_mfinshutc() const {
  return _internal_has_mfinshutc();
}
inline void db_task_data::clear_mfinshutc() {
  _impl_.mfinshutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t db_task_data::_internal_mfinshutc() const {
  return _impl_.mfinshutc_;
}
inline int32_t db_task_data::mfinshutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.data.mfinshutc)
  return _internal_mfinshutc();
}
inline void db_task_data::_internal_set_mfinshutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mfinshutc_ = value;
}
inline void db_task_data::set_mfinshutc(int32_t value) {
  _internal_set_mfinshutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_task.data.mfinshutc)
}

// repeated .pbdb.db_task.data_schedule mschedules = 4;
inline int db_task_data::_internal_mschedules_size() const {
  return _impl_.mschedules_.size();
}
inline int db_task_data::mschedules_size() const {
  return _internal_mschedules_size();
}
inline void db_task_data::clear_mschedules() {
  _impl_.mschedules_.Clear();
}
inline ::pbdb::db_task_data_schedule* db_task_data::mutable_mschedules(int index) {
  // @@protoc_insertion_point(field_mutable:pbdb.db_task.data.mschedules)
  return _impl_.mschedules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_task_data_schedule >*
db_task_data::mutable_mschedules() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.db_task.data.mschedules)
  return &_impl_.mschedules_;
}
inline const ::pbdb::db_task_data_schedule& db_task_data::_internal_mschedules(int index) const {
  return _impl_.mschedules_.Get(index);
}
inline const ::pbdb::db_task_data_schedule& db_task_data::mschedules(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.data.mschedules)
  return _internal_mschedules(index);
}
inline ::pbdb::db_task_data_schedule* db_task_data::_internal_add_mschedules() {
  return _impl_.mschedules_.Add();
}
inline ::pbdb::db_task_data_schedule* db_task_data::add_mschedules() {
  ::pbdb::db_task_data_schedule* _add = _internal_add_mschedules();
  // @@protoc_insertion_point(field_add:pbdb.db_task.data.mschedules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_task_data_schedule >&
db_task_data::mschedules() const {
  // @@protoc_insertion_point(field_list:pbdb.db_task.data.mschedules)
  return _impl_.mschedules_;
}

// optional bool mreceive = 5;
inline bool db_task_data::_internal_has_mreceive() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool db_task_data::has_mreceive() const {
  return _internal_has_mreceive();
}
inline void db_task_data::clear_mreceive() {
  _impl_.mreceive_ = false;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline bool db_task_data::_internal_mreceive() const {
  return _impl_.mreceive_;
}
inline bool db_task_data::mreceive() const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.data.mreceive)
  return _internal_mreceive();
}
inline void db_task_data::_internal_set_mreceive(bool value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mreceive_ = value;
}
inline void db_task_data::set_mreceive(bool value) {
  _internal_set_mreceive(value);
  // @@protoc_insertion_point(field_set:pbdb.db_task.data.mreceive)
}

// -------------------------------------------------------------------

// db_task_complete

// repeated .pbdb.db_task.data mhistory = 1;
inline int db_task_complete::_internal_mhistory_size() const {
  return _impl_.mhistory_.size();
}
inline int db_task_complete::mhistory_size() const {
  return _internal_mhistory_size();
}
inline void db_task_complete::clear_mhistory() {
  _impl_.mhistory_.Clear();
}
inline ::pbdb::db_task_data* db_task_complete::mutable_mhistory(int index) {
  // @@protoc_insertion_point(field_mutable:pbdb.db_task.complete.mhistory)
  return _impl_.mhistory_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_task_data >*
db_task_complete::mutable_mhistory() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.db_task.complete.mhistory)
  return &_impl_.mhistory_;
}
inline const ::pbdb::db_task_data& db_task_complete::_internal_mhistory(int index) const {
  return _impl_.mhistory_.Get(index);
}
inline const ::pbdb::db_task_data& db_task_complete::mhistory(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.complete.mhistory)
  return _internal_mhistory(index);
}
inline ::pbdb::db_task_data* db_task_complete::_internal_add_mhistory() {
  return _impl_.mhistory_.Add();
}
inline ::pbdb::db_task_data* db_task_complete::add_mhistory() {
  ::pbdb::db_task_data* _add = _internal_add_mhistory();
  // @@protoc_insertion_point(field_add:pbdb.db_task.complete.mhistory)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::pbdb::db_task_data >&
db_task_complete::mhistory() const {
  // @@protoc_insertion_point(field_list:pbdb.db_task.complete.mhistory)
  return _impl_.mhistory_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// db_task

// optional int64 mid = 1;
inline bool db_task::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_task::has_mid() const {
  return _internal_has_mid();
}
inline void db_task::clear_mid() {
  _impl_.mid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_task::_internal_mid() const {
  return _impl_.mid_;
}
inline int64_t db_task::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_task.mid)
  return _internal_mid();
}
inline void db_task::_internal_set_mid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mid_ = value;
}
inline void db_task::set_mid(int64_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_task.mid)
}

// map<int32, .pbdb.db_task.data> mrundatas = 2;
inline int db_task::_internal_mrundatas_size() const {
  return _impl_.mrundatas_.size();
}
inline int db_task::mrundatas_size() const {
  return _internal_mrundatas_size();
}
inline void db_task::clear_mrundatas() {
  _impl_.mrundatas_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >&
db_task::_internal_mrundatas() const {
  return _impl_.mrundatas_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >&
db_task::mrundatas() const {
  // @@protoc_insertion_point(field_map:pbdb.db_task.mrundatas)
  return _internal_mrundatas();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >*
db_task::_internal_mutable_mrundatas() {
  return _impl_.mrundatas_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_data >*
db_task::mutable_mrundatas() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_task.mrundatas)
  return _internal_mutable_mrundatas();
}

// map<int32, .pbdb.db_task.complete> mcompleteddatas = 3;
inline int db_task::_internal_mcompleteddatas_size() const {
  return _impl_.mcompleteddatas_.size();
}
inline int db_task::mcompleteddatas_size() const {
  return _internal_mcompleteddatas_size();
}
inline void db_task::clear_mcompleteddatas() {
  _impl_.mcompleteddatas_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_complete >&
db_task::_internal_mcompleteddatas() const {
  return _impl_.mcompleteddatas_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_complete >&
db_task::mcompleteddatas() const {
  // @@protoc_insertion_point(field_map:pbdb.db_task.mcompleteddatas)
  return _internal_mcompleteddatas();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_complete >*
db_task::_internal_mutable_mcompleteddatas() {
  return _impl_.mcompleteddatas_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_task_complete >*
db_task::mutable_mcompleteddatas() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_task.mcompleteddatas)
  return _internal_mutable_mcompleteddatas();
}

// -------------------------------------------------------------------

// db_familyer

// optional int64 mid = 1;
inline bool db_familyer::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_familyer::has_mid() const {
  return _internal_has_mid();
}
inline void db_familyer::clear_mid() {
  _impl_.mid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_familyer::_internal_mid() const {
  return _impl_.mid_;
}
inline int64_t db_familyer::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_familyer.mid)
  return _internal_mid();
}
inline void db_familyer::_internal_set_mid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mid_ = value;
}
inline void db_familyer::set_mid(int64_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_familyer.mid)
}

// optional int32 mjoinutc = 2;
inline bool db_familyer::_internal_has_mjoinutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_familyer::has_mjoinutc() const {
  return _internal_has_mjoinutc();
}
inline void db_familyer::clear_mjoinutc() {
  _impl_.mjoinutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t db_familyer::_internal_mjoinutc() const {
  return _impl_.mjoinutc_;
}
inline int32_t db_familyer::mjoinutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_familyer.mjoinutc)
  return _internal_mjoinutc();
}
inline void db_familyer::_internal_set_mjoinutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mjoinutc_ = value;
}
inline void db_familyer::set_mjoinutc(int32_t value) {
  _internal_set_mjoinutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_familyer.mjoinutc)
}

// optional int32 mlastsignutc = 3;
inline bool db_familyer::_internal_has_mlastsignutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_familyer::has_mlastsignutc() const {
  return _internal_has_mlastsignutc();
}
inline void db_familyer::clear_mlastsignutc() {
  _impl_.mlastsignutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t db_familyer::_internal_mlastsignutc() const {
  return _impl_.mlastsignutc_;
}
inline int32_t db_familyer::mlastsignutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_familyer.mlastsignutc)
  return _internal_mlastsignutc();
}
inline void db_familyer::_internal_set_mlastsignutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mlastsignutc_ = value;
}
inline void db_familyer::set_mlastsignutc(int32_t value) {
  _internal_set_mlastsignutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_familyer.mlastsignutc)
}

// optional int32 mlastleaveutc = 4;
inline bool db_familyer::_internal_has_mlastleaveutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool db_familyer::has_mlastleaveutc() const {
  return _internal_has_mlastleaveutc();
}
inline void db_familyer::clear_mlastleaveutc() {
  _impl_.mlastleaveutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t db_familyer::_internal_mlastleaveutc() const {
  return _impl_.mlastleaveutc_;
}
inline int32_t db_familyer::mlastleaveutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_familyer.mlastleaveutc)
  return _internal_mlastleaveutc();
}
inline void db_familyer::_internal_set_mlastleaveutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mlastleaveutc_ = value;
}
inline void db_familyer::set_mlastleaveutc(int32_t value) {
  _internal_set_mlastleaveutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_familyer.mlastleaveutc)
}

// optional .pbdb.db_familyer.eposition mposition = 5;
inline bool db_familyer::_internal_has_mposition() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool db_familyer::has_mposition() const {
  return _internal_has_mposition();
}
inline void db_familyer::clear_mposition() {
  _impl_.mposition_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::pbdb::db_familyer_eposition db_familyer::_internal_mposition() const {
  return static_cast< ::pbdb::db_familyer_eposition >(_impl_.mposition_);
}
inline ::pbdb::db_familyer_eposition db_familyer::mposition() const {
  // @@protoc_insertion_point(field_get:pbdb.db_familyer.mposition)
  return _internal_mposition();
}
inline void db_familyer::_internal_set_mposition(::pbdb::db_familyer_eposition value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.mposition_ = value;
}
inline void db_familyer::set_mposition(::pbdb::db_familyer_eposition value) {
  _internal_set_mposition(value);
  // @@protoc_insertion_point(field_set:pbdb.db_familyer.mposition)
}

// -------------------------------------------------------------------

// db_family

// optional int64 mid = 1;
inline bool db_family::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_family::has_mid() const {
  return _internal_has_mid();
}
inline void db_family::clear_mid() {
  _impl_.mid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t db_family::_internal_mid() const {
  return _impl_.mid_;
}
inline int64_t db_family::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_family.mid)
  return _internal_mid();
}
inline void db_family::_internal_set_mid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mid_ = value;
}
inline void db_family::set_mid(int64_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_family.mid)
}

// optional int32 mcreateutc = 2;
inline bool db_family::_internal_has_mcreateutc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool db_family::has_mcreateutc() const {
  return _internal_has_mcreateutc();
}
inline void db_family::clear_mcreateutc() {
  _impl_.mcreateutc_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t db_family::_internal_mcreateutc() const {
  return _impl_.mcreateutc_;
}
inline int32_t db_family::mcreateutc() const {
  // @@protoc_insertion_point(field_get:pbdb.db_family.mcreateutc)
  return _internal_mcreateutc();
}
inline void db_family::_internal_set_mcreateutc(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.mcreateutc_ = value;
}
inline void db_family::set_mcreateutc(int32_t value) {
  _internal_set_mcreateutc(value);
  // @@protoc_insertion_point(field_set:pbdb.db_family.mcreateutc)
}

// optional string mname = 3;
inline bool db_family::_internal_has_mname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_family::has_mname() const {
  return _internal_has_mname();
}
inline void db_family::clear_mname() {
  _impl_.mname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& db_family::mname() const {
  // @@protoc_insertion_point(field_get:pbdb.db_family.mname)
  return _internal_mname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void db_family::set_mname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.mname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.db_family.mname)
}
inline std::string* db_family::mutable_mname() {
  std::string* _s = _internal_mutable_mname();
  // @@protoc_insertion_point(field_mutable:pbdb.db_family.mname)
  return _s;
}
inline const std::string& db_family::_internal_mname() const {
  return _impl_.mname_.Get();
}
inline void db_family::_internal_set_mname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mname_.Set(value, GetArenaForAllocation());
}
inline std::string* db_family::_internal_mutable_mname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mname_.Mutable(GetArenaForAllocation());
}
inline std::string* db_family::release_mname() {
  // @@protoc_insertion_point(field_release:pbdb.db_family.mname)
  if (!_internal_has_mname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.mname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mname_.IsDefault()) {
    _impl_.mname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void db_family::set_allocated_mname(std::string* mname) {
  if (mname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mname_.SetAllocated(mname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mname_.IsDefault()) {
    _impl_.mname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_family.mname)
}

// optional int64 mleader = 4;
inline bool db_family::_internal_has_mleader() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool db_family::has_mleader() const {
  return _internal_has_mleader();
}
inline void db_family::clear_mleader() {
  _impl_.mleader_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline int64_t db_family::_internal_mleader() const {
  return _impl_.mleader_;
}
inline int64_t db_family::mleader() const {
  // @@protoc_insertion_point(field_get:pbdb.db_family.mleader)
  return _internal_mleader();
}
inline void db_family::_internal_set_mleader(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.mleader_ = value;
}
inline void db_family::set_mleader(int64_t value) {
  _internal_set_mleader(value);
  // @@protoc_insertion_point(field_set:pbdb.db_family.mleader)
}

// optional int32 mlv = 5;
inline bool db_family::_internal_has_mlv() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool db_family::has_mlv() const {
  return _internal_has_mlv();
}
inline void db_family::clear_mlv() {
  _impl_.mlv_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t db_family::_internal_mlv() const {
  return _impl_.mlv_;
}
inline int32_t db_family::mlv() const {
  // @@protoc_insertion_point(field_get:pbdb.db_family.mlv)
  return _internal_mlv();
}
inline void db_family::_internal_set_mlv(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.mlv_ = value;
}
inline void db_family::set_mlv(int32_t value) {
  _internal_set_mlv(value);
  // @@protoc_insertion_point(field_set:pbdb.db_family.mlv)
}

// optional int32 mexp = 6;
inline bool db_family::_internal_has_mexp() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool db_family::has_mexp() const {
  return _internal_has_mexp();
}
inline void db_family::clear_mexp() {
  _impl_.mexp_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline int32_t db_family::_internal_mexp() const {
  return _impl_.mexp_;
}
inline int32_t db_family::mexp() const {
  // @@protoc_insertion_point(field_get:pbdb.db_family.mexp)
  return _internal_mexp();
}
inline void db_family::_internal_set_mexp(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.mexp_ = value;
}
inline void db_family::set_mexp(int32_t value) {
  _internal_set_mexp(value);
  // @@protoc_insertion_point(field_set:pbdb.db_family.mexp)
}

// repeated int64 mmember = 7;
inline int db_family::_internal_mmember_size() const {
  return _impl_.mmember_.size();
}
inline int db_family::mmember_size() const {
  return _internal_mmember_size();
}
inline void db_family::clear_mmember() {
  _impl_.mmember_.Clear();
}
inline int64_t db_family::_internal_mmember(int index) const {
  return _impl_.mmember_.Get(index);
}
inline int64_t db_family::mmember(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.db_family.mmember)
  return _internal_mmember(index);
}
inline void db_family::set_mmember(int index, int64_t value) {
  _impl_.mmember_.Set(index, value);
  // @@protoc_insertion_point(field_set:pbdb.db_family.mmember)
}
inline void db_family::_internal_add_mmember(int64_t value) {
  _impl_.mmember_.Add(value);
}
inline void db_family::add_mmember(int64_t value) {
  _internal_add_mmember(value);
  // @@protoc_insertion_point(field_add:pbdb.db_family.mmember)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_family::_internal_mmember() const {
  return _impl_.mmember_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_family::mmember() const {
  // @@protoc_insertion_point(field_list:pbdb.db_family.mmember)
  return _internal_mmember();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_family::_internal_mutable_mmember() {
  return &_impl_.mmember_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_family::mutable_mmember() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.db_family.mmember)
  return _internal_mutable_mmember();
}

// repeated int64 mapplylist = 8;
inline int db_family::_internal_mapplylist_size() const {
  return _impl_.mapplylist_.size();
}
inline int db_family::mapplylist_size() const {
  return _internal_mapplylist_size();
}
inline void db_family::clear_mapplylist() {
  _impl_.mapplylist_.Clear();
}
inline int64_t db_family::_internal_mapplylist(int index) const {
  return _impl_.mapplylist_.Get(index);
}
inline int64_t db_family::mapplylist(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.db_family.mapplylist)
  return _internal_mapplylist(index);
}
inline void db_family::set_mapplylist(int index, int64_t value) {
  _impl_.mapplylist_.Set(index, value);
  // @@protoc_insertion_point(field_set:pbdb.db_family.mapplylist)
}
inline void db_family::_internal_add_mapplylist(int64_t value) {
  _impl_.mapplylist_.Add(value);
}
inline void db_family::add_mapplylist(int64_t value) {
  _internal_add_mapplylist(value);
  // @@protoc_insertion_point(field_add:pbdb.db_family.mapplylist)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_family::_internal_mapplylist() const {
  return _impl_.mapplylist_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_family::mapplylist() const {
  // @@protoc_insertion_point(field_list:pbdb.db_family.mapplylist)
  return _internal_mapplylist();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_family::_internal_mutable_mapplylist() {
  return &_impl_.mapplylist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_family::mutable_mapplylist() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.db_family.mapplylist)
  return _internal_mutable_mapplylist();
}

// -------------------------------------------------------------------

// db_friends

// optional int64 mid = 1;
inline bool db_friends::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_friends::has_mid() const {
  return _internal_has_mid();
}
inline void db_friends::clear_mid() {
  _impl_.mid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_friends::_internal_mid() const {
  return _impl_.mid_;
}
inline int64_t db_friends::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_friends.mid)
  return _internal_mid();
}
inline void db_friends::_internal_set_mid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mid_ = value;
}
inline void db_friends::set_mid(int64_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_friends.mid)
}

// repeated int64 mfriends = 2;
inline int db_friends::_internal_mfriends_size() const {
  return _impl_.mfriends_.size();
}
inline int db_friends::mfriends_size() const {
  return _internal_mfriends_size();
}
inline void db_friends::clear_mfriends() {
  _impl_.mfriends_.Clear();
}
inline int64_t db_friends::_internal_mfriends(int index) const {
  return _impl_.mfriends_.Get(index);
}
inline int64_t db_friends::mfriends(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.db_friends.mfriends)
  return _internal_mfriends(index);
}
inline void db_friends::set_mfriends(int index, int64_t value) {
  _impl_.mfriends_.Set(index, value);
  // @@protoc_insertion_point(field_set:pbdb.db_friends.mfriends)
}
inline void db_friends::_internal_add_mfriends(int64_t value) {
  _impl_.mfriends_.Add(value);
}
inline void db_friends::add_mfriends(int64_t value) {
  _internal_add_mfriends(value);
  // @@protoc_insertion_point(field_add:pbdb.db_friends.mfriends)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_friends::_internal_mfriends() const {
  return _impl_.mfriends_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_friends::mfriends() const {
  // @@protoc_insertion_point(field_list:pbdb.db_friends.mfriends)
  return _internal_mfriends();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_friends::_internal_mutable_mfriends() {
  return &_impl_.mfriends_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_friends::mutable_mfriends() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.db_friends.mfriends)
  return _internal_mutable_mfriends();
}

// repeated int64 mapplyfriends = 3;
inline int db_friends::_internal_mapplyfriends_size() const {
  return _impl_.mapplyfriends_.size();
}
inline int db_friends::mapplyfriends_size() const {
  return _internal_mapplyfriends_size();
}
inline void db_friends::clear_mapplyfriends() {
  _impl_.mapplyfriends_.Clear();
}
inline int64_t db_friends::_internal_mapplyfriends(int index) const {
  return _impl_.mapplyfriends_.Get(index);
}
inline int64_t db_friends::mapplyfriends(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.db_friends.mapplyfriends)
  return _internal_mapplyfriends(index);
}
inline void db_friends::set_mapplyfriends(int index, int64_t value) {
  _impl_.mapplyfriends_.Set(index, value);
  // @@protoc_insertion_point(field_set:pbdb.db_friends.mapplyfriends)
}
inline void db_friends::_internal_add_mapplyfriends(int64_t value) {
  _impl_.mapplyfriends_.Add(value);
}
inline void db_friends::add_mapplyfriends(int64_t value) {
  _internal_add_mapplyfriends(value);
  // @@protoc_insertion_point(field_add:pbdb.db_friends.mapplyfriends)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_friends::_internal_mapplyfriends() const {
  return _impl_.mapplyfriends_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_friends::mapplyfriends() const {
  // @@protoc_insertion_point(field_list:pbdb.db_friends.mapplyfriends)
  return _internal_mapplyfriends();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_friends::_internal_mutable_mapplyfriends() {
  return &_impl_.mapplyfriends_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_friends::mutable_mapplyfriends() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.db_friends.mapplyfriends)
  return _internal_mutable_mapplyfriends();
}

// -------------------------------------------------------------------

// dbcross_test

// optional string mname = 1;
inline bool dbcross_test::_internal_has_mname() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool dbcross_test::has_mname() const {
  return _internal_has_mname();
}
inline void dbcross_test::clear_mname() {
  _impl_.mname_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& dbcross_test::mname() const {
  // @@protoc_insertion_point(field_get:pbdb.dbcross_test.mname)
  return _internal_mname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void dbcross_test::set_mname(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.mname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.dbcross_test.mname)
}
inline std::string* dbcross_test::mutable_mname() {
  std::string* _s = _internal_mutable_mname();
  // @@protoc_insertion_point(field_mutable:pbdb.dbcross_test.mname)
  return _s;
}
inline const std::string& dbcross_test::_internal_mname() const {
  return _impl_.mname_.Get();
}
inline void dbcross_test::_internal_set_mname(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mname_.Set(value, GetArenaForAllocation());
}
inline std::string* dbcross_test::_internal_mutable_mname() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mname_.Mutable(GetArenaForAllocation());
}
inline std::string* dbcross_test::release_mname() {
  // @@protoc_insertion_point(field_release:pbdb.dbcross_test.mname)
  if (!_internal_has_mname()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.mname_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mname_.IsDefault()) {
    _impl_.mname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void dbcross_test::set_allocated_mname(std::string* mname) {
  if (mname != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mname_.SetAllocated(mname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mname_.IsDefault()) {
    _impl_.mname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.dbcross_test.mname)
}

// repeated int64 mvalue = 2;
inline int dbcross_test::_internal_mvalue_size() const {
  return _impl_.mvalue_.size();
}
inline int dbcross_test::mvalue_size() const {
  return _internal_mvalue_size();
}
inline void dbcross_test::clear_mvalue() {
  _impl_.mvalue_.Clear();
}
inline int64_t dbcross_test::_internal_mvalue(int index) const {
  return _impl_.mvalue_.Get(index);
}
inline int64_t dbcross_test::mvalue(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.dbcross_test.mvalue)
  return _internal_mvalue(index);
}
inline void dbcross_test::set_mvalue(int index, int64_t value) {
  _impl_.mvalue_.Set(index, value);
  // @@protoc_insertion_point(field_set:pbdb.dbcross_test.mvalue)
}
inline void dbcross_test::_internal_add_mvalue(int64_t value) {
  _impl_.mvalue_.Add(value);
}
inline void dbcross_test::add_mvalue(int64_t value) {
  _internal_add_mvalue(value);
  // @@protoc_insertion_point(field_add:pbdb.dbcross_test.mvalue)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
dbcross_test::_internal_mvalue() const {
  return _impl_.mvalue_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
dbcross_test::mvalue() const {
  // @@protoc_insertion_point(field_list:pbdb.dbcross_test.mvalue)
  return _internal_mvalue();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
dbcross_test::_internal_mutable_mvalue() {
  return &_impl_.mvalue_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
dbcross_test::mutable_mvalue() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.dbcross_test.mvalue)
  return _internal_mutable_mvalue();
}

// -------------------------------------------------------------------

// db_testlua_luadata

// optional string mkey = 1;
inline bool db_testlua_luadata::_internal_has_mkey() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_testlua_luadata::has_mkey() const {
  return _internal_has_mkey();
}
inline void db_testlua_luadata::clear_mkey() {
  _impl_.mkey_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& db_testlua_luadata::mkey() const {
  // @@protoc_insertion_point(field_get:pbdb.db_testlua.luadata.mkey)
  return _internal_mkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void db_testlua_luadata::set_mkey(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.mkey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.db_testlua.luadata.mkey)
}
inline std::string* db_testlua_luadata::mutable_mkey() {
  std::string* _s = _internal_mutable_mkey();
  // @@protoc_insertion_point(field_mutable:pbdb.db_testlua.luadata.mkey)
  return _s;
}
inline const std::string& db_testlua_luadata::_internal_mkey() const {
  return _impl_.mkey_.Get();
}
inline void db_testlua_luadata::_internal_set_mkey(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mkey_.Set(value, GetArenaForAllocation());
}
inline std::string* db_testlua_luadata::_internal_mutable_mkey() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.mkey_.Mutable(GetArenaForAllocation());
}
inline std::string* db_testlua_luadata::release_mkey() {
  // @@protoc_insertion_point(field_release:pbdb.db_testlua.luadata.mkey)
  if (!_internal_has_mkey()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.mkey_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mkey_.IsDefault()) {
    _impl_.mkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void db_testlua_luadata::set_allocated_mkey(std::string* mkey) {
  if (mkey != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.mkey_.SetAllocated(mkey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mkey_.IsDefault()) {
    _impl_.mkey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_testlua.luadata.mkey)
}

// optional string mval = 2;
inline bool db_testlua_luadata::_internal_has_mval() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool db_testlua_luadata::has_mval() const {
  return _internal_has_mval();
}
inline void db_testlua_luadata::clear_mval() {
  _impl_.mval_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& db_testlua_luadata::mval() const {
  // @@protoc_insertion_point(field_get:pbdb.db_testlua.luadata.mval)
  return _internal_mval();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void db_testlua_luadata::set_mval(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.mval_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:pbdb.db_testlua.luadata.mval)
}
inline std::string* db_testlua_luadata::mutable_mval() {
  std::string* _s = _internal_mutable_mval();
  // @@protoc_insertion_point(field_mutable:pbdb.db_testlua.luadata.mval)
  return _s;
}
inline const std::string& db_testlua_luadata::_internal_mval() const {
  return _impl_.mval_.Get();
}
inline void db_testlua_luadata::_internal_set_mval(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.mval_.Set(value, GetArenaForAllocation());
}
inline std::string* db_testlua_luadata::_internal_mutable_mval() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.mval_.Mutable(GetArenaForAllocation());
}
inline std::string* db_testlua_luadata::release_mval() {
  // @@protoc_insertion_point(field_release:pbdb.db_testlua.luadata.mval)
  if (!_internal_has_mval()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.mval_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mval_.IsDefault()) {
    _impl_.mval_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void db_testlua_luadata::set_allocated_mval(std::string* mval) {
  if (mval != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.mval_.SetAllocated(mval, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.mval_.IsDefault()) {
    _impl_.mval_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:pbdb.db_testlua.luadata.mval)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// db_testlua

// optional int64 mid = 1;
inline bool db_testlua::_internal_has_mid() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool db_testlua::has_mid() const {
  return _internal_has_mid();
}
inline void db_testlua::clear_mid() {
  _impl_.mid_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int64_t db_testlua::_internal_mid() const {
  return _impl_.mid_;
}
inline int64_t db_testlua::mid() const {
  // @@protoc_insertion_point(field_get:pbdb.db_testlua.mid)
  return _internal_mid();
}
inline void db_testlua::_internal_set_mid(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mid_ = value;
}
inline void db_testlua::set_mid(int64_t value) {
  _internal_set_mid(value);
  // @@protoc_insertion_point(field_set:pbdb.db_testlua.mid)
}

// repeated int64 mvalue = 2;
inline int db_testlua::_internal_mvalue_size() const {
  return _impl_.mvalue_.size();
}
inline int db_testlua::mvalue_size() const {
  return _internal_mvalue_size();
}
inline void db_testlua::clear_mvalue() {
  _impl_.mvalue_.Clear();
}
inline int64_t db_testlua::_internal_mvalue(int index) const {
  return _impl_.mvalue_.Get(index);
}
inline int64_t db_testlua::mvalue(int index) const {
  // @@protoc_insertion_point(field_get:pbdb.db_testlua.mvalue)
  return _internal_mvalue(index);
}
inline void db_testlua::set_mvalue(int index, int64_t value) {
  _impl_.mvalue_.Set(index, value);
  // @@protoc_insertion_point(field_set:pbdb.db_testlua.mvalue)
}
inline void db_testlua::_internal_add_mvalue(int64_t value) {
  _impl_.mvalue_.Add(value);
}
inline void db_testlua::add_mvalue(int64_t value) {
  _internal_add_mvalue(value);
  // @@protoc_insertion_point(field_add:pbdb.db_testlua.mvalue)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_testlua::_internal_mvalue() const {
  return _impl_.mvalue_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
db_testlua::mvalue() const {
  // @@protoc_insertion_point(field_list:pbdb.db_testlua.mvalue)
  return _internal_mvalue();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_testlua::_internal_mutable_mvalue() {
  return &_impl_.mvalue_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
db_testlua::mutable_mvalue() {
  // @@protoc_insertion_point(field_mutable_list:pbdb.db_testlua.mvalue)
  return _internal_mutable_mvalue();
}

// map<int32, .pbdb.db_testlua.luadata> mdatas = 3;
inline int db_testlua::_internal_mdatas_size() const {
  return _impl_.mdatas_.size();
}
inline int db_testlua::mdatas_size() const {
  return _internal_mdatas_size();
}
inline void db_testlua::clear_mdatas() {
  _impl_.mdatas_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_testlua_luadata >&
db_testlua::_internal_mdatas() const {
  return _impl_.mdatas_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_testlua_luadata >&
db_testlua::mdatas() const {
  // @@protoc_insertion_point(field_map:pbdb.db_testlua.mdatas)
  return _internal_mdatas();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_testlua_luadata >*
db_testlua::_internal_mutable_mdatas() {
  return _impl_.mdatas_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< int32_t, ::pbdb::db_testlua_luadata >*
db_testlua::mutable_mdatas() {
  // @@protoc_insertion_point(field_mutable_map:pbdb.db_testlua.mdatas)
  return _internal_mutable_mdatas();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbdb

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::pbdb::db_keyvalue_ekv> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbdb::db_keyvalue_ekv>() {
  return ::pbdb::db_keyvalue_ekv_descriptor();
}
template <> struct is_proto_enum< ::pbdb::db_familyer_eposition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbdb::db_familyer_eposition>() {
  return ::pbdb::db_familyer_eposition_descriptor();
}
template <> struct is_proto_enum< ::pbdb::ENUM_DB> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbdb::ENUM_DB>() {
  return ::pbdb::ENUM_DB_descriptor();
}
template <> struct is_proto_enum< ::pbdb::eranklist> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pbdb::eranklist>() {
  return ::pbdb::eranklist_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_db_2eproto
